export const MOCK_SELECTED_FILES = [
  {
    path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
    name: "generate-tests.tsx",
    content:
      'import { createFileRoute } from "@tanstack/react-router";\nimport { useState } from "react";\nimport { Container, Paper, Center, Box, Stepper } from "@mantine/core";\nimport { useDependencies } from "src/hooks/use-dependencies";\nimport { useRepoConnection } from "src/hooks/use-repo-connection";\nimport { StepperNavigationButtons } from "src/components/stepper-navigation-buttons";\nimport { StepOneUploadFiles } from "src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files";\nimport { StepTwoDescribeRelations } from "src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations";\nimport { StepThreeViewResults } from "src/routes/(generate-tests)/-components/step-three-view-results/step-three-view-results";\nimport { useFileTree } from "./-components/step-one-upload-files/use-file-tree";\n\n// Interface to make SelectedRepoFile compatible with FileWithPath\ninterface FileCompatible {\n  path: string;\n  name: string;\n  size: number;\n  text: string;\n}\n\nexport const Route = createFileRoute("/(generate-tests)/generate-tests")({\n  component: Index,\n});\n\nfunction Index() {\n  const [currentStep, setCurrentStep] = useState(0);\n\n  const [repoUrl, setRepoUrl] = useState(\n    "https://github.com/piotrnajda3000/handoff.git"\n  );\n  const [accessToken, setAccessToken] = useState(\n    "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"\n  );\n\n  // Repository connection hook - manages selected files internally\n  const repoConnectionData = useRepoConnection();\n  const { selectedFiles } = repoConnectionData;\n\n  // Convert SelectedRepoFile to FileWithPath for existing dependencies hook\n  const fileCompatibleFiles: FileCompatible[] = selectedFiles.map((file) => ({\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    text: file.content, // Add content for compatibility\n  }));\n\n  // File Tree Management Hook\n  const { fileTree, expandedDirectories, toggleDirectoryExpansion } =\n    useFileTree({\n      repoFiles: repoConnectionData.repoFiles,\n      selectedFiles,\n    });\n\n  // Feature Name State\n  const [featureName, setFeatureName] = useState("");\n\n  const dependenciesData = useDependencies(fileCompatibleFiles);\n\n  const stepTitles = ["Connect Repository", "Generate Tests", "Review Results"];\n  const totalSteps = stepTitles.length;\n\n  const canProceedToNext = currentStep === 0 ? selectedFiles.length > 0 : true;\n\n  const getNextButtonTooltip = () => {\n    if (currentStep === 0) {\n      if (selectedFiles.length === 0) {\n        return "Please select files from your repository to continue";\n      }\n    }\n    if (currentStep === totalSteps - 1) {\n      return "Complete the process";\n    }\n    return "";\n  };\n\n  const handleNext = () => {\n    if (currentStep < totalSteps - 1) {\n      setCurrentStep(currentStep + 1);\n    }\n  };\n\n  const handlePrevious = () => {\n    if (currentStep > 0) {\n      setCurrentStep(currentStep - 1);\n    }\n  };\n\n  const renderStepContent = () => {\n    switch (currentStep) {\n      case 0:\n        return (\n          <StepOneUploadFiles\n            repoConnectionData={repoConnectionData}\n            repoUrl={repoUrl}\n            setRepoUrl={setRepoUrl}\n            accessToken={accessToken}\n            setAccessToken={setAccessToken}\n            fileTree={fileTree}\n            expandedDirectories={expandedDirectories}\n            featureName={featureName}\n            setFeatureName={setFeatureName}\n            toggleDirectoryExpansion={toggleDirectoryExpansion}\n          />\n        );\n      case 1:\n        return (\n          <StepTwoDescribeRelations\n            files={fileCompatibleFiles}\n            dependenciesData={dependenciesData}\n          />\n        );\n      case 2:\n        return <StepThreeViewResults />;\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <Container size="md" className="h-full flex flex-col">\n      <Center className="my-auto">\n        <Paper className="w-full max-w-[700px] h-full shadow-lg rounded-md p-xl">\n          <div className="flex flex-col">\n            {/* Step Progress Indicator */}\n            <Box>\n              <Stepper active={currentStep} size="sm">\n                {stepTitles.map((title, index) => (\n                  <Stepper.Step key={index} label={title} data-qa={`step`} />\n                ))}\n              </Stepper>\n            </Box>\n\n            {/* Step Content */}\n            <div className="mt-xl">{renderStepContent()}</div>\n\n            {/* Navigation */}\n            <div className="mt-xl">\n              <StepperNavigationButtons\n                currentStep={currentStep}\n                totalSteps={totalSteps}\n                onNext={handleNext}\n                onPrevious={handlePrevious}\n                canProceedToNext={canProceedToNext}\n                nextButtonTooltip={getNextButtonTooltip()}\n              />\n            </div>\n          </div>\n        </Paper>\n      </Center>\n    </Container>\n  );\n}\n',
    size: 4902,
    dependents: [],
  },
  {
    path: "ui/src/hooks/use-dependencies.tsx",
    name: "use-dependencies.tsx",
    content:
      'import { useState } from "react";\nimport type { Edge } from "../routes/(generate-tests)/-components/interactive-canvas/interactive-canvas";\n\nexport interface Dependency {\n  id: string;\n  from: string;\n  to: string;\n  connection: string;\n}\n\n// Make the hook more flexible to accept file-like objects\ninterface FileWithPathOrContent {\n  path?: string;\n  name: string;\n  size?: number;\n}\n\nexport function useDependencies(files: FileWithPathOrContent[]) {\n  const [dependencies, setDependencies] = useState<Dependency[]>([]);\n\n  // Generate file options for select dropdowns\n  const fileOptions = files.map((file) => ({\n    value: file.path || file.name,\n    label: file.path || file.name,\n  }));\n\n  const connectionOptions = [\n    { value: "uses", label: "uses" },\n    { value: "tests", label: "tests" },\n    { value: "describes", label: "describes" },\n  ];\n\n  const addDependency = () => {\n    const newDependency: Dependency = {\n      id: crypto.randomUUID(),\n      from: "",\n      to: "",\n      connection: "uses",\n    };\n    setDependencies([...dependencies, newDependency]);\n  };\n\n  const updateDependency = (\n    id: string,\n    field: keyof Dependency,\n    value: string\n  ) => {\n    setDependencies(\n      dependencies.map((dep) =>\n        dep.id === id ? { ...dep, [field]: value } : dep\n      )\n    );\n  };\n\n  const removeDependency = (id: string) => {\n    setDependencies(dependencies.filter((dep) => dep.id !== id));\n  };\n\n  // Convert dependencies to edges for the canvas\n  const convertDependenciesToEdges = (): Edge[] => {\n    // Create mapping from file path/name to node ID\n    const fileToNodeIdMap = new Map<string, string>();\n    files.forEach((file, index) => {\n      const fileIdentifier = file.path || file.name;\n      fileToNodeIdMap.set(fileIdentifier, `file-${index}`);\n    });\n\n    // Convert dependencies to edges\n    return dependencies\n      .filter((dep) => {\n        // Only include dependencies where both from and to files exist\n        return fileToNodeIdMap.has(dep.from) && fileToNodeIdMap.has(dep.to);\n      })\n      .map((dep) => ({\n        id: dep.id,\n        from: fileToNodeIdMap.get(dep.from)!,\n        to: fileToNodeIdMap.get(dep.to)!,\n        description: dep.connection,\n      }));\n  };\n\n  const edges = convertDependenciesToEdges();\n\n  const generateDependencies = () => {\n    // For now, this is a placeholder. In a real implementation, this could:\n    // - Use AI to analyze files and suggest dependencies\n    // - Parse imports/exports to find relationships\n    // - Add some basic dependencies based on file structure\n    console.log("Generate dependencies functionality to be implemented");\n  };\n\n  return {\n    dependencies,\n    fileOptions,\n    connectionOptions,\n    edges,\n    addDependency,\n    updateDependency,\n    removeDependency,\n    generateDependencies,\n  };\n}\n',
    size: 2822,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/hooks/use-repo-connection.ts",
    name: "use-repo-connection.ts",
    content:
      'import { useState, useCallback } from "react";\nimport {\n  type RepoConnection,\n  type RepoFile,\n  type SelectedRepoFile,\n} from "../types/repo";\nimport { apiPost } from "../utils/api";\nimport { getImportedFilesToSelect } from "../utils/import-parser.utils";\n\nexport interface UseRepoConnectionReturn {\n  // Connection state\n  connection: RepoConnection | null;\n  isConnected: boolean;\n  isConnecting: boolean;\n  connectionError: string | null;\n\n  // File listing state\n  repoFiles: RepoFile[];\n  isLoadingFiles: boolean;\n  fileLoadError: string | null;\n\n  // Selected files state\n  selectedFiles: SelectedRepoFile[];\n\n  // File content loading state\n  loadingFiles: Set<string>;\n\n  // Actions\n  connectToRepo: (repoUrl: string, token: string) => Promise<void>;\n  disconnect: () => void;\n  loadRepoFiles: () => Promise<void>;\n  toggleFileSelection: (\n    file: RepoFile,\n    autoSelectImports?: boolean\n  ) => Promise<void>;\n  autoSelectImportedFiles: (file: SelectedRepoFile) => Promise<void>;\n  clearSelectedFiles: () => void;\n}\n\nexport function useRepoConnection(): UseRepoConnectionReturn {\n  const [connection, setConnection] = useState<RepoConnection | null>(null);\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [connectionError, setConnectionError] = useState<string | null>(null);\n\n  const [repoFiles, setRepoFiles] = useState<RepoFile[]>([]);\n  const [isLoadingFiles, setIsLoadingFiles] = useState(false);\n  const [fileLoadError, setFileLoadError] = useState<string | null>(null);\n\n  const [selectedFiles, setSelectedFiles] = useState<SelectedRepoFile[]>([]);\n  const [loadingFiles, setLoadingFiles] = useState<Set<string>>(new Set());\n\n  const parseRepoUrl = (url: string) => {\n    // Support both HTTPS and SSH GitHub URLs\n    const githubHttpsMatch = url.match(\n      /https:\\/\\/github\\.com\\/([^\\/]+)\\/([^\\/]+)(?:\\.git)?/\n    );\n    const githubSshMatch = url.match(\n      /git@github\\.com:([^\\/]+)\\/([^\\/]+)(?:\\.git)?/\n    );\n\n    if (githubHttpsMatch) {\n      return {\n        provider: "github" as const,\n        owner: githubHttpsMatch[1],\n        repo: githubHttpsMatch[2].replace(".git", ""),\n      };\n    }\n\n    if (githubSshMatch) {\n      return {\n        provider: "github" as const,\n        owner: githubSshMatch[1],\n        repo: githubSshMatch[2].replace(".git", ""),\n      };\n    }\n\n    throw new Error(\n      "Unsupported repository URL format. Please use a GitHub HTTPS or SSH URL."\n    );\n  };\n\n  const connectToRepo = useCallback(async (repoUrl: string, token: string) => {\n    setIsConnecting(true);\n    setConnectionError(null);\n\n    try {\n      const { provider, owner, repo } = parseRepoUrl(repoUrl);\n\n      // Test the connection by making a simple API call\n      await apiPost({\n        endpoint: "/repo/test-connection",\n        body: { provider, owner, repo, token },\n      });\n\n      const newConnection: RepoConnection = {\n        provider,\n        url: repoUrl,\n        token,\n        owner,\n        repo,\n      };\n\n      setConnection(newConnection);\n      console.log("Successfully connected to repository:", { owner, repo });\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : "Failed to connect to repository";\n      setConnectionError(errorMessage);\n      console.error("Repository connection failed:", error);\n    } finally {\n      setIsConnecting(false);\n    }\n  }, []);\n\n  const disconnect = useCallback(() => {\n    setConnection(null);\n    setRepoFiles([]);\n    setSelectedFiles([]);\n    setLoadingFiles(new Set());\n    setConnectionError(null);\n    setFileLoadError(null);\n  }, []);\n\n  const loadRepoFiles = useCallback(async () => {\n    if (!connection) return;\n\n    setIsLoadingFiles(true);\n    setFileLoadError(null);\n\n    try {\n      const response = await apiPost<typeof connection, RepoFile[]>({\n        endpoint: "/repo/list-files",\n        body: connection,\n      });\n\n      // Filter to only show supported file types\n      const supportedExtensions = [".js", ".jsx", ".ts", ".tsx"];\n      const filteredFiles = response.filter(\n        (file) =>\n          file.type === "file" &&\n          supportedExtensions.some((ext) =>\n            file.path.toLowerCase().endsWith(ext)\n          )\n      );\n\n      setRepoFiles(filteredFiles);\n      console.log("Loaded repository files:", filteredFiles.length);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : "Failed to load repository files";\n      setFileLoadError(errorMessage);\n      console.error("Failed to load repository files:", error);\n    } finally {\n      setIsLoadingFiles(false);\n    }\n  }, [connection]);\n\n  const selectFileWithoutAutoImports = useCallback(\n    async (file: RepoFile) => {\n      if (!connection) return null;\n\n      // Set loading state for this file\n      setLoadingFiles((prev) => new Set([...prev, file.path]));\n\n      try {\n        const response = await apiPost<\n          { connection: RepoConnection; filePath: string },\n          { content: string }\n        >({\n          endpoint: "/repo/get-file-content",\n          body: { connection, filePath: file.path },\n        });\n\n        const selectedFile: SelectedRepoFile = {\n          path: file.path,\n          name: file.name,\n          content: response.content,\n          size: file.size || 0,\n        };\n\n        setSelectedFiles((prev) => [...prev, selectedFile]);\n        console.log("Added file to selection:", file.path);\n        return selectedFile;\n      } catch (error) {\n        console.error("Failed to fetch file content:", error);\n        return null;\n      } finally {\n        // Remove loading state for this file\n        setLoadingFiles((prev) => {\n          const newSet = new Set(prev);\n          newSet.delete(file.path);\n          return newSet;\n        });\n      }\n    },\n    [connection]\n  );\n\n  const autoSelectImportedFiles = useCallback(\n    async (file: SelectedRepoFile) => {\n      if (!connection) return;\n\n      try {\n        // Get imported files that should be auto-selected\n        const importedFiles = getImportedFilesToSelect(\n          file.content,\n          file.path,\n          repoFiles\n        );\n\n        console.log({\n          content: file.content,\n          path: file.path,\n          repoFiles: repoFiles,\n        });\n\n        console.log(\n          `Found ${importedFiles.length} imported files for ${file.path}:`,\n          importedFiles.map((f) => f.path)\n        );\n\n        // Filter out files that are already selected\n        const filesToSelect = importedFiles.filter(\n          (importedFile) =>\n            !selectedFiles.some(\n              (selected) => selected.path === importedFile.path\n            )\n        );\n\n        if (filesToSelect.length === 0) {\n          console.log("No new imported files to select");\n          return;\n        }\n\n        console.log(`Auto-selecting ${filesToSelect.length} imported files...`);\n\n        // Select each imported file (without triggering auto-select recursively)\n        for (const importedFile of filesToSelect) {\n          await selectFileWithoutAutoImports(importedFile);\n        }\n      } catch (error) {\n        console.error("Failed to auto-select imported files:", error);\n      }\n    },\n    [connection, repoFiles, selectedFiles, selectFileWithoutAutoImports]\n  );\n\n  const toggleFileSelection = useCallback(\n    async (file: RepoFile, autoSelectImports = true) => {\n      if (!connection) return;\n\n      const isSelected = selectedFiles.some((f) => f.path === file.path);\n\n      if (isSelected) {\n        // Remove from selection\n        setSelectedFiles((prev) => prev.filter((f) => f.path !== file.path));\n      } else {\n        // Add to selection - need to fetch file content\n        const selectedFile = await selectFileWithoutAutoImports(file);\n\n        // Auto-select imported files if requested and file was successfully selected\n        if (autoSelectImports && selectedFile) {\n          // Use a small delay to ensure state has updated\n          setTimeout(() => {\n            autoSelectImportedFiles(selectedFile);\n          }, 100);\n        }\n      }\n    },\n    [\n      connection,\n      selectedFiles,\n      selectFileWithoutAutoImports,\n      autoSelectImportedFiles,\n    ]\n  );\n\n  const clearSelectedFiles = useCallback(() => {\n    setSelectedFiles([]);\n  }, []);\n\n  return {\n    // Connection state\n    connection,\n    isConnected: !!connection,\n    isConnecting,\n    connectionError,\n\n    // File listing state\n    repoFiles,\n    isLoadingFiles,\n    fileLoadError,\n\n    // Selected files state\n    selectedFiles,\n\n    // File content loading state\n    loadingFiles,\n\n    // Actions\n    connectToRepo,\n    disconnect,\n    loadRepoFiles,\n    toggleFileSelection,\n    autoSelectImportedFiles,\n    clearSelectedFiles,\n  };\n}\n',
    size: 8799,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/components/stepper-navigation-buttons/index.ts",
    name: "index.ts",
    content:
      'export { StepperNavigationButtons } from "./stepper-navigation-buttons";\n',
    size: 73,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
    name: "step-one-upload-files.tsx",
    content:
      '// # 7. Main Step One Upload Files Component\n// Orchestrates the file upload and selection process with repository connection\n\nimport { Title, Text } from "@mantine/core";\nimport { useCallback } from "react";\nimport { type UseRepoConnectionReturn } from "src/hooks/use-repo-connection";\n\n// # 7.1 Extracted Component Imports\nimport { ConnectionForm } from "src/routes/(generate-tests)/-components/step-one-upload-files/connection-form";\nimport { RepositoryHeader } from "src/routes/(generate-tests)/-components/step-one-upload-files/repository-header";\nimport { FileTreeDisplay } from "src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display";\nimport type { TreeNode } from "./tree-item";\n\n// # 7.2 Component Props Interface\ninterface StepOneUploadFilesProps {\n  repoConnectionData: UseRepoConnectionReturn;\n  repoUrl: string;\n  setRepoUrl: (repoUrl: string) => void;\n  accessToken: string;\n  setAccessToken: (accessToken: string) => void;\n  fileTree: TreeNode[];\n  expandedDirectories: Set<string>;\n  featureName: string;\n  setFeatureName: (featureName: string) => void;\n  toggleDirectoryExpansion: (path: string) => void;\n}\n\n// # 7.3 Main Component Implementation\n// Orchestrates the complete file upload and selection workflow\nexport function StepOneUploadFiles({\n  repoConnectionData,\n  repoUrl,\n  setRepoUrl,\n  accessToken,\n  setAccessToken,\n  fileTree,\n  expandedDirectories,\n  featureName,\n  setFeatureName,\n  toggleDirectoryExpansion,\n}: StepOneUploadFilesProps) {\n  // # 7.3.2 Repository Connection Data\n  const {\n    connection,\n    isConnected,\n    isConnecting,\n    connectionError,\n    repoFiles,\n    isLoadingFiles,\n    fileLoadError,\n    selectedFiles,\n    loadingFiles,\n    connectToRepo,\n    disconnect,\n    loadRepoFiles,\n    toggleFileSelection,\n  } = repoConnectionData;\n\n  // # 7.3.5 Event Handlers (Memoized to prevent unnecessary re-renders)\n\n  // # 7.3.5.1 Connection Handlers\n  const handleConnect = useCallback(async () => {\n    if (!repoUrl.trim() || !accessToken.trim()) {\n      return;\n    }\n    await connectToRepo(repoUrl.trim(), accessToken.trim());\n  }, [repoUrl, accessToken, connectToRepo]);\n\n  const handleDisconnect = useCallback(() => {\n    disconnect();\n    setRepoUrl("");\n    setAccessToken("");\n  }, [disconnect, setRepoUrl, setAccessToken]);\n\n  // # 7.3.5.2 File Management Handlers\n  const handleLoadFiles = useCallback(() => {\n    loadRepoFiles();\n  }, [loadRepoFiles]);\n\n  // # 7.3.5.3 Feature Name Handler\n  const handleFeatureNameChange = useCallback((value: string) => {\n    setFeatureName(value);\n  }, []);\n\n  // # 7.3.6 Conditional Rendering\n\n  // # 7.3.6.1 Connection Form State\n  if (!isConnected) {\n    return (\n      <ConnectionForm\n        repoUrl={repoUrl}\n        accessToken={accessToken}\n        isConnecting={isConnecting}\n        connectionError={connectionError}\n        onRepoUrlChange={setRepoUrl}\n        onAccessTokenChange={setAccessToken}\n        onConnect={handleConnect}\n      />\n    );\n  }\n\n  // # 7.3.6.2 Connected State\n  return (\n    <div className="gap-lg">\n      {/* # 7.3.6.2.1 Page Header */}\n      <div className="text-center">\n        <Title order={1} size="h2" className="mb-md">\n          Repository Connected\n        </Title>\n        <Text size="lg" className="text-gray-600">\n          Select the files you want to analyze from {connection?.owner}/\n          {connection?.repo}\n        </Text>\n      </div>\n\n      {/* # 7.3.6.2.2 Repository Management */}\n      <RepositoryHeader\n        connection={connection}\n        isLoadingFiles={isLoadingFiles}\n        onRefresh={handleLoadFiles}\n        onDisconnect={handleDisconnect}\n      />\n\n      {/* # 7.3.6.2.3 File Tree Display */}\n      <FileTreeDisplay\n        repoFiles={repoFiles}\n        selectedFiles={selectedFiles}\n        fileTree={fileTree}\n        isLoadingFiles={isLoadingFiles}\n        fileLoadError={fileLoadError}\n        loadingFiles={loadingFiles}\n        expandedDirectories={expandedDirectories}\n        featureName={featureName}\n        onLoadFiles={handleLoadFiles}\n        onToggleExpanded={toggleDirectoryExpansion}\n        onToggleSelection={toggleFileSelection}\n        onFeatureNameChange={handleFeatureNameChange}\n      />\n    </div>\n  );\n}\n',
    size: 4227,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/connection-form.tsx",
    name: "connection-form.tsx",
    content:
      '// # 4. Repository Connection Form Component\n// Handles GitHub repository authentication and connection\n\nimport {\n  Stack,\n  Box,\n  Title,\n  Text,\n  TextInput,\n  PasswordInput,\n  Button,\n  Alert,\n  Paper,\n  Group,\n} from "@mantine/core";\nimport { IconBrandGithub, IconAlertCircle } from "@tabler/icons-react";\n\n// # 4.1 Component Props Interface\ninterface ConnectionFormProps {\n  repoUrl: string;\n  accessToken: string;\n  isConnecting: boolean;\n  connectionError: string | null;\n  onRepoUrlChange: (url: string) => void;\n  onAccessTokenChange: (token: string) => void;\n  onConnect: () => void;\n}\n\n// # 4.2 Main Connection Form Component\n// Provides UI for GitHub repository connection with validation and error handling\nexport function ConnectionForm({\n  repoUrl,\n  accessToken,\n  isConnecting,\n  connectionError,\n  onRepoUrlChange,\n  onAccessTokenChange,\n  onConnect,\n}: ConnectionFormProps) {\n  // # 4.2.1 Form Validation\n  const isFormValid = repoUrl.trim() && accessToken.trim();\n\n  return (\n    <Stack className="gap-lg">\n      {/* # 4.2.2 Header Section */}\n      <Box className="text-center">\n        <Title order={1} size="h2" className="mb-md">\n          Welcome to Handoff\n        </Title>\n        <Text className="text-gray-600">\n          Connect your repository to generate natural language test cases\n        </Text>\n      </Box>\n\n      {/* # 4.2.3 Connection Form */}\n      <Paper className="border-gray-200 rounded-md p-xl">\n        <Stack className="gap-md">\n          {/* # 4.2.3.1 Form Header */}\n          <Group className="gap-xs">\n            <IconBrandGithub size={24} />\n            <Title order={3} size="h4">\n              Connect Your Repository\n            </Title>\n          </Group>\n\n          {/* # 4.2.3.2 Form Description */}\n          <Text size="sm" className="text-gray-600">\n            Connect to your GitHub repository (including private repos) to\n            select and analyze your code files.\n          </Text>\n\n          {/* # 4.2.3.3 Repository URL Input */}\n          <TextInput\n            label="Repository URL"\n            placeholder="https://github.com/username/repository or git@github.com:username/repository.git"\n            value={repoUrl}\n            onChange={(e) => onRepoUrlChange(e.currentTarget.value)}\n            required\n          />\n\n          {/* # 4.2.3.4 Access Token Input */}\n          <PasswordInput\n            label="Personal Access Token"\n            placeholder="Your GitHub personal access token"\n            description="Create a token at https://github.com/settings/tokens with \'repo\' scope for private repositories"\n            value={accessToken}\n            onChange={(e) => onAccessTokenChange(e.currentTarget.value)}\n            required\n          />\n\n          {/* # 4.2.3.5 Error Display */}\n          {connectionError && (\n            <Alert\n              icon={<IconAlertCircle size="1rem" />}\n              title="Connection Error"\n              color="red"\n            >\n              {connectionError}\n            </Alert>\n          )}\n\n          {/* # 4.2.3.6 Connect Button */}\n          <Button\n            onClick={onConnect}\n            loading={isConnecting}\n            disabled={!isFormValid}\n            leftSection={<IconBrandGithub size="1rem" />}\n          >\n            {isConnecting ? "Connecting..." : "Connect Repository"}\n          </Button>\n        </Stack>\n      </Paper>\n    </Stack>\n  );\n}\n',
    size: 3400,
    dependents: [
      {
        name: "step-one-upload-files.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/repository-header.tsx",
    name: "repository-header.tsx",
    content:
      '// # 5. Repository Header Component\n// Displays connection status and provides repository management controls\n\nimport { Paper, Group, Text, Button, ActionIcon, Tooltip } from "@mantine/core";\nimport { IconCheck, IconX, IconRefresh } from "@tabler/icons-react";\nimport type { RepoConnection } from "src/types/repo";\n\n// # 5.1 Component Props Interface\ninterface RepositoryHeaderProps {\n  connection: RepoConnection | null;\n  isLoadingFiles: boolean;\n  onRefresh: () => void;\n  onDisconnect: () => void;\n}\n\n// # 5.2 Main Repository Header Component\n// Shows connected repository info and provides tree management controls\nexport function RepositoryHeader({\n  connection,\n  isLoadingFiles,\n  onRefresh,\n  onDisconnect,\n}: RepositoryHeaderProps) {\n  return (\n    <Paper className="border-gray-200 rounded-md p-md">\n      <Group className="justify-between">\n        {/* # 5.2.1 Connection Status */}\n        <Group className="gap-xs">\n          <IconCheck size="1rem" color="green" />\n          <Text size="sm" className="font-medium">\n            Connected to {connection?.owner}/{connection?.repo}\n          </Text>\n        </Group>\n\n        {/* # 5.2.2 Action Controls */}\n        <Group className="gap-xs">\n          {/* # 5.2.2.2 Refresh Control */}\n          <Tooltip label="Refresh file list">\n            <ActionIcon\n              variant="light"\n              onClick={onRefresh}\n              loading={isLoadingFiles}\n            >\n              <IconRefresh size="1rem" />\n            </ActionIcon>\n          </Tooltip>\n\n          {/* # 5.2.2.3 Disconnect Control */}\n          <Button\n            size="xs"\n            variant="subtle"\n            color="red"\n            onClick={onDisconnect}\n            leftSection={<IconX size="1rem" />}\n          >\n            Disconnect\n          </Button>\n        </Group>\n      </Group>\n    </Paper>\n  );\n}\n',
    size: 1857,
    dependents: [
      {
        name: "step-one-upload-files.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
      },
    ],
  },
  {
    path: "ui/src/types/repo.ts",
    name: "repo.ts",
    content:
      '// Repository connection types\nexport interface RepoConnection {\n  provider: "github" | "gitlab" | "bitbucket";\n  url: string;\n  token: string;\n  owner: string;\n  repo: string;\n}\n\nexport interface RepoFile {\n  path: string;\n  name: string;\n  type: "file" | "dir";\n  size?: number;\n  content?: string;\n  sha?: string;\n}\n\nexport interface RepoFileTree {\n  path: string;\n  mode: string;\n  type: "blob" | "tree";\n  sha: string;\n  size?: number;\n  url: string;\n}\n\nexport interface SelectedRepoFile {\n  path: string;\n  name: string;\n  content: string;\n  size: number;\n}\n\n// API Response types\nexport interface GitHubContent {\n  name: string;\n  path: string;\n  sha: string;\n  size: number;\n  url: string;\n  html_url: string;\n  git_url: string;\n  download_url: string;\n  type: "file" | "dir";\n  content?: string;\n  encoding?: string;\n}\n\nexport interface GitHubTreeResponse {\n  sha: string;\n  url: string;\n  tree: RepoFileTree[];\n  truncated: boolean;\n}\n',
    size: 945,
    dependents: [
      {
        name: "repository-header.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/repository-header.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display.tsx",
    name: "file-tree-display.tsx",
    content:
      '// # 6. File Tree Display Component\n// Handles the display of file tree structure with loading and error states\n\nimport React, { useMemo } from "react";\nimport { Box, Text, Loader, Alert, Button, TextInput } from "@mantine/core";\nimport { IconAlertCircle } from "@tabler/icons-react";\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\nimport { TreeItem, type TreeNode } from "./tree-item";\n\n// # 6.1 Component Props Interface\ninterface FileTreeDisplayProps {\n  repoFiles: RepoFile[];\n  selectedFiles: SelectedRepoFile[];\n  fileTree: TreeNode[];\n  isLoadingFiles: boolean;\n  fileLoadError: string | null;\n  loadingFiles: Set<string>;\n  expandedDirectories: Set<string>;\n  featureName: string;\n  onLoadFiles: () => void;\n  onToggleExpanded: (path: string) => void;\n  onToggleSelection: (file: RepoFile) => void;\n  onFeatureNameChange: (value: string) => void;\n}\n\n// # 6.2 Main File Tree Display Component\n// Manages different display states and renders the tree structure\nexport const FileTreeDisplay = React.memo(function FileTreeDisplay({\n  repoFiles,\n  selectedFiles,\n  fileTree,\n  isLoadingFiles,\n  fileLoadError,\n  loadingFiles,\n  expandedDirectories,\n  featureName,\n  onLoadFiles,\n  onToggleExpanded,\n  onToggleSelection,\n  onFeatureNameChange,\n}: FileTreeDisplayProps) {\n  // # 6.2.1 Render Tree Function\n  // Creates TreeItem components for each root node (memoized to prevent recreation)\n  const renderedTree = useMemo(() => {\n    return fileTree.map((node) => (\n      <TreeItem\n        key={node.path}\n        node={node}\n        expandedDirectories={expandedDirectories}\n        selectedFiles={selectedFiles}\n        loadingFiles={loadingFiles}\n        onToggleExpanded={onToggleExpanded}\n        onToggleSelection={onToggleSelection}\n      />\n    ));\n  }, [\n    fileTree,\n    expandedDirectories,\n    selectedFiles,\n    loadingFiles,\n    onToggleExpanded,\n    onToggleSelection,\n  ]);\n\n  return (\n    <>\n      {/* # 6.2.2 Empty State - No Files Loaded */}\n      {!repoFiles.length && !isLoadingFiles && !fileLoadError && (\n        <Box className="my-xl text-center">\n          <Text className="text-gray-600 mb-md" size="sm">\n            Click "Load Files" to browse your repository files\n          </Text>\n          <Button onClick={onLoadFiles} variant="light">\n            Load Files\n          </Button>\n        </Box>\n      )}\n\n      {/* # 6.2.3 Loading State */}\n      {isLoadingFiles && (\n        <Box className="my-xl text-center">\n          <Loader size="sm" className="mb-md" />\n          <Text size="sm" className="text-gray-600">\n            Loading repository files...\n          </Text>\n        </Box>\n      )}\n\n      {/* # 6.2.4 Error State */}\n      {fileLoadError && (\n        <Alert\n          icon={<IconAlertCircle size="1rem" />}\n          title="Error Loading Files"\n          color="red"\n          className="mb-md"\n        >\n          {fileLoadError}\n        </Alert>\n      )}\n\n      {/* # 6.2.5 Files Display */}\n      {repoFiles.length > 0 && (\n        <div>\n          {/* # 6.2.5.0 Feature Name Input */}\n          <TextInput\n            label="Feature Name"\n            description="The feature you are doing the handoff for"\n            value={featureName}\n            onChange={(event) => onFeatureNameChange(event.currentTarget.value)}\n            placeholder="Enter feature name..."\n          />\n\n          {/* # 6.2.5.1 File Count Summary */}\n          <Text size="sm" className="text-gray-600 mt-md mb-xs text-xs">\n            {selectedFiles.length} of {repoFiles.length} files selected â€¢ Only\n            JavaScript/TypeScript files are shown\n          </Text>\n\n          {/* # 6.2.5.2 Scrollable Tree Container */}\n          <div className="h-[400px] overflow-y-auto flex flex-col gap-xs">\n            {renderedTree}\n          </div>\n        </div>\n      )}\n    </>\n  );\n});\n',
    size: 3841,
    dependents: [
      {
        name: "step-one-upload-files.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/tree-item.tsx",
    name: "tree-item.tsx",
    content:
      '// # 1. Tree Item Component\n// This component renders individual nodes in the file tree structure\n\nimport React, { useCallback, useMemo } from "react";\nimport { Checkbox, ActionIcon, Collapse, Loader } from "@mantine/core";\nimport clsx from "clsx";\nimport {\n  IconFile,\n  IconFolder,\n  IconFolderOpen,\n  IconChevronRight,\n  IconChevronDown,\n} from "@tabler/icons-react";\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\nimport styles from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-item.module.css";\n\n// # 1.1 TreeNode Interface\n// Represents a single node in the file tree structure\nexport interface TreeNode {\n  path: string;\n  name: string;\n  type: "file" | "directory";\n  file?: RepoFile;\n  children: TreeNode[];\n  depth: number;\n}\n\n// # 1.2 TreeItem Props Interface\ninterface TreeItemProps {\n  node: TreeNode;\n  expandedDirectories: Set<string>;\n  selectedFiles: SelectedRepoFile[];\n  loadingFiles: Set<string>;\n  onToggleExpanded: (path: string) => void;\n  onToggleSelection: (file: RepoFile) => void;\n}\n\n// # 1.3 Main TreeItem Component\n// Renders a single tree node with expand/collapse and selection functionality\nexport const TreeItem = React.memo(function TreeItem({\n  node,\n  expandedDirectories,\n  selectedFiles,\n  loadingFiles,\n  onToggleExpanded,\n  onToggleSelection,\n}: TreeItemProps) {\n  // # 1.3.1 Node State Calculations\n  const hasChildren = node.children.length > 0;\n  const isFile = node.type === "file";\n  const isExpanded = expandedDirectories.has(node.path);\n  const isSelected = node.file\n    ? selectedFiles.some((f) => f.path === node.file!.path)\n    : false;\n  const isLoading = node.file ? loadingFiles.has(node.file.path) : false;\n\n  // # 1.3.2 Click Handler\n  // Handles clicks on files (selection) and directories (expand/collapse)\n  const handleClick = useCallback(() => {\n    if (isFile && node.file && !isLoading) {\n      onToggleSelection(node.file);\n    } else if (hasChildren) {\n      onToggleExpanded(node.path);\n    }\n  }, [\n    isFile,\n    node.file,\n    node.path,\n    isLoading,\n    hasChildren,\n    onToggleSelection,\n    onToggleExpanded,\n  ]);\n\n  const paperStyle = useMemo(() => {\n    return {\n      "--node-depth-margin": `${node.depth * 20}px`,\n    } as React.CSSProperties;\n  }, [node.depth]);\n\n  return (\n    <div>\n      {/* # 1.3.3 Node Container */}\n      <div\n        className={`${styles.nodeContainer} ${\n          isFile && isSelected ? styles.selected : ""\n        } p-xs rounded-sm shadow-xs border border-gray-200`}\n        style={paperStyle}\n        onClick={handleClick}\n      >\n        <div className="flex gap-xs  justify-between">\n          {/* # 1.3.4 Left Content Group */}\n          <div\n            className={`${styles.contentGroup} items-center flex flex-1 gap-xs`}\n          >\n            {/* # 1.3.4.1 Expansion Controls */}\n            {!isFile && hasChildren && (\n              <ActionIcon\n                variant="transparent"\n                size="sm"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  onToggleExpanded(node.path);\n                }}\n              >\n                {isExpanded ? (\n                  <IconChevronDown size="0.8rem" />\n                ) : (\n                  <IconChevronRight size="0.8rem" />\n                )}\n              </ActionIcon>\n            )}\n            {!isFile && !hasChildren && (\n              <div className="w-5" /> // Spacer for alignment\n            )}\n\n            {/* # 1.3.4.2 File Selection Checkbox or Loading Spinner */}\n            {isFile ? (\n              <div className={`${styles.checkboxContainer} w-5 h-5`}>\n                {isLoading ? (\n                  <Loader size="xs" />\n                ) : (\n                  <Checkbox\n                    checked={isSelected}\n                    onChange={() => {}} // Controlled by parent click\n                    size="sm"\n                  />\n                )}\n              </div>\n            ) : null}\n\n            {/* # 1.3.4.3 Node Icon */}\n            {isFile ? (\n              <IconFile size="1rem" />\n            ) : (\n              <>\n                {isExpanded ? (\n                  <IconFolderOpen size="1rem" />\n                ) : (\n                  <IconFolder size="1rem" />\n                )}\n              </>\n            )}\n\n            {/* # 1.3.4.4 Node Name */}\n            <div className={styles.nodeNameContainer}>\n              <div\n                className={clsx(\n                  isFile ? "font-medium" : "text-gray-600",\n                  "text-sm select-none"\n                )}\n              >\n                {node.name}\n              </div>\n            </div>\n          </div>\n\n          {/* # 1.3.5 Right Content - File Size */}\n          {isFile && node.file?.size && (\n            <p className="text-gray-600 text-xs">\n              {Math.round(node.file.size / 1024)}KB\n            </p>\n          )}\n        </div>\n      </div>\n\n      {/* # 1.3.6 Children Container */}\n      {!isFile && hasChildren && (\n        <Collapse in={isExpanded} transitionDuration={0}>\n          <div className="mt-xs gap-xs flex flex-col">\n            {node.children.map((child) => (\n              <TreeItem\n                key={child.path}\n                node={child}\n                expandedDirectories={expandedDirectories}\n                selectedFiles={selectedFiles}\n                loadingFiles={loadingFiles}\n                onToggleExpanded={onToggleExpanded}\n                onToggleSelection={onToggleSelection}\n              />\n            ))}\n          </div>\n        </Collapse>\n      )}\n    </div>\n  );\n});\n',
    size: 5619,
    dependents: [
      {
        name: "file-tree-display.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations.tsx",
    name: "step-two-describe-relations.tsx",
    content:
      'import { useState } from "react";\nimport {\n  Stack,\n  Box,\n  Title,\n  Text,\n  Tabs,\n  Button,\n  Select,\n  Group,\n  Paper,\n  ActionIcon,\n  Space,\n} from "@mantine/core";\nimport { IconPlus, IconSparkles, IconTrash } from "@tabler/icons-react";\n// Use a more flexible file interface that works with both uploaded and repo files\ninterface FileWithPathLike {\n  path?: string;\n  name: string;\n  size?: number;\n}\nimport { InteractiveCanvas } from "src/routes/(generate-tests)/-components/interactive-canvas/interactive-canvas";\nimport type { Dependency } from "src/hooks/use-dependencies";\n\ninterface DependenciesData {\n  dependencies: Dependency[];\n  fileOptions: { value: string; label: string }[];\n  connectionOptions: { value: string; label: string }[];\n  edges: Array<{ id: string; from: string; to: string; description: string }>;\n  addDependency: () => void;\n  updateDependency: (\n    id: string,\n    field: keyof Dependency,\n    value: string\n  ) => void;\n  removeDependency: (id: string) => void;\n  generateDependencies: () => void;\n}\n\ninterface StepTwoDescribeRelationsProps {\n  files: FileWithPathLike[];\n  dependenciesData: DependenciesData;\n}\n\nexport function StepTwoDescribeRelations({\n  files,\n  dependenciesData,\n}: StepTwoDescribeRelationsProps) {\n  const [activeTab, setActiveTab] = useState<string>("describe");\n  const {\n    dependencies,\n    fileOptions,\n    connectionOptions,\n    edges,\n    addDependency,\n    updateDependency,\n    removeDependency,\n    generateDependencies,\n  } = dependenciesData;\n\n  return (\n    <Stack className="gap-lg">\n      <Box className="text-center">\n        <Title order={2} className="mb-md">\n          Configure File Relationships\n        </Title>\n        <Text size="lg" className="text-gray-600">\n          Describe file relationships or visualize them interactively\n        </Text>\n      </Box>\n\n      {files.length > 0 ? (\n        <Tabs\n          value={activeTab}\n          onChange={(value) => setActiveTab(value || "describe")}\n        >\n          <Tabs.List grow>\n            <Tabs.Tab value="describe">Describe</Tabs.Tab>\n            <Tabs.Tab value="visualize">Visualize</Tabs.Tab>\n          </Tabs.List>\n\n          <Space h="md" />\n\n          <Tabs.Panel value="describe">\n            <Stack className="gap-md">\n              <Group className="justify-between items-center">\n                <Text size="lg" className="font-medium">\n                  Dependencies\n                </Text>\n                <Group gap="xs">\n                  <Button\n                    leftSection={<IconSparkles size={16} />}\n                    onClick={generateDependencies}\n                    variant="light"\n                  >\n                    Generate\n                  </Button>\n                  <Button\n                    leftSection={<IconPlus size={16} />}\n                    onClick={addDependency}\n                    variant="light"\n                  >\n                    Add\n                  </Button>\n                </Group>\n              </Group>\n\n              {dependencies.length === 0 ? (\n                <Paper className="border-gray-200 rounded-md p-lg">\n                  <Text className="text-center text-gray-600">\n                    No dependencies defined yet. Click "Generate" or "Add" to\n                    get started.\n                  </Text>\n                </Paper>\n              ) : (\n                <Stack className="gap-sm">\n                  {dependencies.map((dependency) => (\n                    <Paper\n                      key={dependency.id}\n                      className="border-gray-200 rounded-md p-md"\n                    >\n                      <Group className="justify-between flex-end">\n                        <Group className="flex-1 flex-end wrap-nowrap">\n                          <Select\n                            label="From"\n                            placeholder="Select file"\n                            data={fileOptions}\n                            value={dependency.from}\n                            comboboxProps={{\n                              width: "max-content",\n                              position: "bottom-start",\n                              middlewares: { flip: false, shift: false },\n                            }}\n                            onChange={(value) =>\n                              updateDependency(\n                                dependency.id,\n                                "from",\n                                value || ""\n                              )\n                            }\n                            style={{ minWidth: 200 }}\n                          />\n                          <Select\n                            label="Connection"\n                            data={connectionOptions}\n                            value={dependency.connection}\n                            onChange={(value) =>\n                              updateDependency(\n                                dependency.id,\n                                "connection",\n                                value || "uses"\n                              )\n                            }\n                            className="min-w-[120px]"\n                          />\n                          <Select\n                            label="To"\n                            placeholder="Select file"\n                            data={fileOptions}\n                            value={dependency.to}\n                            onChange={(value) =>\n                              updateDependency(dependency.id, "to", value || "")\n                            }\n                            className="min-w-[200px]"\n                          />\n                        </Group>\n                        <div className={Select.classes.wrapper}>\n                          <Box className="flex items-center h-[var(--input-height)]">\n                            <ActionIcon\n                              variant="subtle"\n                              color="red"\n                              onClick={() => removeDependency(dependency.id)}\n                            >\n                              <IconTrash size={16} />\n                            </ActionIcon>\n                          </Box>\n                        </div>\n                      </Group>\n                    </Paper>\n                  ))}\n                </Stack>\n              )}\n            </Stack>\n          </Tabs.Panel>\n\n          <Tabs.Panel value="visualize">\n            <Stack className="gap-md">\n              <Text size="sm" className="text-gray-600">\n                Drag nodes to organize them. Use mouse wheel to zoom, click and\n                drag empty space to pan.\n              </Text>\n              <InteractiveCanvas files={files} edges={edges} />\n            </Stack>\n          </Tabs.Panel>\n        </Tabs>\n      ) : (\n        <Text className="text-center text-orange-500">\n          No files available. Please go back to step 1 and upload some files.\n        </Text>\n      )}\n    </Stack>\n  );\n}\n',
    size: 7011,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/interactive-canvas/interactive-canvas.tsx",
    name: "interactive-canvas.tsx",
    content:
      '/* eslint-disable react-refresh/only-export-components */\nimport { useRef, useState, useMemo, useEffect } from "react";\nimport { Box } from "@mantine/core";\n// Make the canvas work with any file-like object that has a name\ninterface FileWithName {\n  name: string;\n}\nimport * as d3 from "d3";\n\n// ## 1. Type Definitions and Interfaces\n// ### 1.1. Point interface for coordinates\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n// ### 1.2. Node position interface (SVG coordinate space)\nexport interface NodePosition {\n  x: number;\n  y: number;\n}\n\n// ### 1.3. File node data interface\ninterface FileNodeData {\n  id: string;\n  name: string;\n  position: NodePosition;\n}\n\n// ### 1.4. Edge interface for connections between nodes\nexport interface Edge {\n  id: string;\n  from: string;\n  to: string;\n  description: string;\n}\n\n// ### 1.5. Canvas state interface\nexport interface CanvasState {\n  zoom: number;\n  pan: Point;\n  selectedNodeId: string | null;\n  isDragging: boolean;\n  dragType: "canvas" | "node" | null;\n  draggedNodeId: string | null;\n  dragStartPoint: Point | null;\n}\n\n// ### 1.6. Interactive canvas component props\ninterface InteractiveCanvasProps {\n  files: FileWithName[];\n  edges?: Edge[];\n}\n\n// ## 2. Constants and Configuration\nconst NODE_WIDTH = 120;\nconst NODE_HEIGHT = 60;\nconst GRID_SPACING = 180;\nexport const MIN_ZOOM = 0.1;\nexport const MAX_ZOOM = 3;\n\n// ## 3. Canvas Action Functions - Pure functions for testability\n\n// ### 3.1. dragCanvas - Pan the canvas view\nexport function dragCanvas(\n  state: CanvasState,\n  startPoint: Point,\n  currentPoint: Point\n): CanvasState {\n  // #### 3.1.1. Calculate movement delta\n  const deltaX = currentPoint.x - startPoint.x;\n  const deltaY = currentPoint.y - startPoint.y;\n\n  // #### 3.1.2. Return new state with updated pan position\n  return {\n    ...state,\n    pan: {\n      x: state.pan.x + deltaX,\n      y: state.pan.y + deltaY,\n    },\n  };\n}\n\n// ### 3.2. zoom - Zoom in/out at a specific point\nexport function zoom(\n  state: CanvasState,\n  zoomPoint: Point,\n  zoomDelta: number\n): CanvasState {\n  // #### 3.2.1. Calculate new zoom level within bounds\n  const newZoom = Math.max(\n    MIN_ZOOM,\n    Math.min(MAX_ZOOM, state.zoom * (1 + zoomDelta))\n  );\n\n  // #### 3.2.2. Early return if zoom didn\'t change\n  if (newZoom === state.zoom) {\n    return state;\n  }\n\n  // #### 3.2.3. Calculate zoom ratio and adjust pan to zoom at point\n  const zoomRatio = newZoom / state.zoom;\n\n  return {\n    ...state,\n    zoom: newZoom,\n    pan: {\n      x: zoomPoint.x - (zoomPoint.x - state.pan.x) * zoomRatio,\n      y: zoomPoint.y - (zoomPoint.y - state.pan.y) * zoomRatio,\n    },\n  };\n}\n\n// ### 3.3. dragNode - Move a specific node\nexport function dragNode(\n  nodePositions: Record<string, NodePosition>,\n  nodeId: string,\n  startPoint: Point,\n  currentPoint: Point,\n  canvasZoom: number,\n  initialNodePosition: NodePosition\n): Record<string, NodePosition> {\n  // #### 3.3.1. Calculate delta in screen space\n  const screenDeltaX = currentPoint.x - startPoint.x;\n  const screenDeltaY = currentPoint.y - startPoint.y;\n\n  // #### 3.3.2. Convert to SVG space (account for zoom)\n  const svgDeltaX = screenDeltaX / canvasZoom;\n  const svgDeltaY = screenDeltaY / canvasZoom;\n\n  // #### 3.3.3. Return new node positions with updated node\n  return {\n    ...nodePositions,\n    [nodeId]: {\n      x: initialNodePosition.x + svgDeltaX,\n      y: initialNodePosition.y + svgDeltaY,\n    },\n  };\n}\n\n// ### 3.4. clickNode - Handle node selection/interaction\nexport function clickNode(state: CanvasState, nodeId: string): CanvasState {\n  return {\n    ...state,\n    selectedNodeId: state.selectedNodeId === nodeId ? null : nodeId,\n  };\n}\n\n// ## 4. InteractiveCanvas Component\nexport function InteractiveCanvas({\n  files,\n  edges = [],\n}: InteractiveCanvasProps) {\n  // ### 4.1. State Management\n  // #### 4.1.1. Canvas state (zoom, pan, selection, dragging)\n  const [canvasState, setCanvasState] = useState<CanvasState>({\n    zoom: 1,\n    pan: { x: 0, y: 0 },\n    selectedNodeId: null,\n    isDragging: false,\n    dragType: null,\n    draggedNodeId: null,\n    dragStartPoint: null,\n  });\n\n  // #### 4.1.2. Node positions state\n  const [nodePositions, setNodePositions] = useState<\n    Record<string, NodePosition>\n  >({});\n\n  // ### 4.2. References for D3 Operations\n  const containerRef = useRef<HTMLDivElement>(null);\n  const svgRef = useRef<SVGSVGElement>(null);\n  const gRef = useRef<SVGGElement>(null);\n  const zoomBehaviorRef = useRef<d3.ZoomBehavior<\n    SVGSVGElement,\n    unknown\n  > | null>(null);\n  const initialNodePositionRef = useRef<NodePosition>({ x: 0, y: 0 });\n\n  // #### 4.2.1. State refs for drag callbacks (to avoid stale closures)\n  const canvasStateRef = useRef(canvasState);\n  const nodePositionsRef = useRef(nodePositions);\n\n  // ### 4.3. Sync Effects - Keep refs in sync with state\n  useEffect(() => {\n    canvasStateRef.current = canvasState;\n  }, [canvasState]);\n\n  useEffect(() => {\n    nodePositionsRef.current = nodePositions;\n  }, [nodePositions]);\n\n  // ### 4.4. Computed Data\n  // #### 4.4.1. Generate file nodes data with positions\n  const fileNodes = useMemo((): FileNodeData[] => {\n    return files.map((file, index) => ({\n      id: `file-${index}`,\n      name: file.name,\n      position:\n        nodePositions[`file-${index}`] ||\n        calculateInitialPosition(index, files.length),\n    }));\n  }, [files, nodePositions]);\n\n  // ### 4.5. Helper Functions\n  // #### 4.5.1. Calculate initial grid position for nodes\n  function calculateInitialPosition(\n    index: number,\n    totalFiles: number\n  ): NodePosition {\n    const nodesPerRow = Math.ceil(Math.sqrt(totalFiles));\n    const row = Math.floor(index / nodesPerRow);\n    const col = index % nodesPerRow;\n\n    return {\n      x: col * GRID_SPACING + NODE_WIDTH / 2,\n      y: row * GRID_SPACING + NODE_HEIGHT / 2,\n    };\n  }\n\n  // ### 4.6. Initialization Effects\n  // #### 4.6.1. Initialize node positions when files change\n  useEffect(() => {\n    const initialPositions: Record<string, NodePosition> = {};\n    files.forEach((_, index) => {\n      const nodeId = `file-${index}`;\n      if (!nodePositions[nodeId]) {\n        initialPositions[nodeId] = calculateInitialPosition(\n          index,\n          files.length\n        );\n      }\n    });\n\n    if (Object.keys(initialPositions).length > 0) {\n      setNodePositions((prev) => ({ ...prev, ...initialPositions }));\n    }\n  }, [files, nodePositions]);\n\n  // ### 4.7. D3 Setup Effects\n  // #### 4.7.1. Initialize SVG and setup D3 behaviors (only once)\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const container = d3.select(containerRef.current);\n\n    // ##### 4.7.1.1. Clear any existing content\n    container.selectAll("*").remove();\n\n    // ##### 4.7.1.2. Create SVG element\n    const svg = container\n      .append("svg")\n      .attr("width", "100%")\n      .attr("height", "100%")\n      .style("user-select", "none");\n\n    svgRef.current = svg.node();\n\n    // ##### 4.7.1.3. Create main group for zoom/pan transforms\n    const g = svg.append("g");\n    gRef.current = g.node();\n\n    // ##### 4.7.1.4. Setup grid pattern for visual grid background\n    const defs = svg.append("defs");\n    const pattern = defs\n      .append("pattern")\n      .attr("id", "grid")\n      .attr("width", 20)\n      .attr("height", 20)\n      .attr("patternUnits", "userSpaceOnUse");\n\n    pattern\n      .append("path")\n      .attr("d", "M 20 0 L 0 0 0 20")\n      .attr("fill", "none")\n      .attr("stroke", "var(--mantine-color-gray-2)")\n      .attr("stroke-width", 0.5)\n      .attr("opacity", 0.5);\n\n    // ##### 4.7.1.5. Add grid background rectangle\n    g.append("rect")\n      .attr("x", -2000)\n      .attr("y", -2000)\n      .attr("width", 4000)\n      .attr("height", 4000)\n      .attr("fill", "url(#grid)");\n\n    // ##### 4.7.1.6. Add arrow marker definition for edges\n    const arrowMarker = defs\n      .append("marker")\n      .attr("id", "arrow")\n      .attr("viewBox", "0 -5 10 10")\n      .attr("refX", 8)\n      .attr("refY", 0)\n      .attr("markerWidth", 6)\n      .attr("markerHeight", 6)\n      .attr("orient", "auto");\n\n    arrowMarker\n      .append("path")\n      .attr("d", "M0,-5L10,0L0,5")\n      .attr("fill", "var(--mantine-color-gray-6)");\n\n    // ##### 4.7.1.7. Setup zoom behavior - apply to SVG, not container\n    const zoomBehavior = d3\n      .zoom<SVGSVGElement, unknown>()\n      .scaleExtent([MIN_ZOOM, MAX_ZOOM])\n      .on("zoom", (event) => {\n        const transform = event.transform;\n\n        // Update canvas state with new zoom/pan values\n        setCanvasState((prev) => ({\n          ...prev,\n          zoom: transform.k,\n          pan: { x: transform.x, y: transform.y },\n        }));\n\n        // Apply transform to the main group\n        g.attr("transform", transform.toString());\n      });\n\n    zoomBehaviorRef.current = zoomBehavior;\n\n    // ##### 4.7.1.8. Apply zoom behavior to SVG element for proper event handling\n    svg.call(zoomBehaviorRef.current);\n\n    // ##### 4.7.1.9. Sync initial state with D3 zoom\n    const initialTransform = d3.zoomIdentity\n      .translate(canvasState.pan.x, canvasState.pan.y)\n      .scale(canvasState.zoom);\n\n    svg.call(zoomBehavior.transform, initialTransform);\n\n    // ##### 4.7.1.10. Cleanup function to remove event listeners\n    return () => {\n      if (zoomBehaviorRef.current) {\n        svg.on(".zoom", null);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Remove dependencies to prevent recreation\n\n  // #### 4.5.2. Calculate edge connection points between nodes\n  const calculateEdgePoints = (fromPos: NodePosition, toPos: NodePosition) => {\n    // ##### 4.5.2.1. Calculate direction vector between nodes\n    const dx = toPos.x - fromPos.x;\n    const dy = toPos.y - fromPos.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // ##### 4.5.2.2. Handle case where nodes are at same position\n    if (distance === 0) {\n      return { x1: fromPos.x, y1: fromPos.y, x2: toPos.x, y2: toPos.y };\n    }\n\n    // ##### 4.5.2.3. Normalize direction vector to unit vector\n    const unitX = dx / distance;\n    const unitY = dy / distance;\n\n    // ##### 4.5.2.4. Calculate connection points at node edges\n    // From node: start from edge in direction of target\n    const fromRadius = Math.max(NODE_WIDTH, NODE_HEIGHT) / 2;\n    const x1 = fromPos.x + unitX * fromRadius;\n    const y1 = fromPos.y + unitY * fromRadius;\n\n    // To node: end at edge from direction of source\n    const toRadius = Math.max(NODE_WIDTH, NODE_HEIGHT) / 2;\n    const x2 = toPos.x - unitX * toRadius;\n    const y2 = toPos.y - unitY * toRadius;\n\n    return { x1, y1, x2, y2 };\n  };\n\n  // ### 4.8. Rendering Effects\n  // #### 4.8.1. Render edges with D3\n  useEffect(() => {\n    if (!gRef.current) return;\n\n    const g = d3.select(gRef.current);\n\n    // ##### 4.8.1.1. Helper function to get node position by ID\n    const getNodePosition = (nodeId: string): NodePosition | null => {\n      const node = fileNodes.find((n) => n.id === nodeId);\n      return node ? node.position : null;\n    };\n\n    // ##### 4.8.1.2. Filter valid edges (both from and to nodes exist)\n    const validEdges = edges.filter((edge) => {\n      const fromPos = getNodePosition(edge.from);\n      const toPos = getNodePosition(edge.to);\n      return fromPos && toPos;\n    });\n\n    // ##### 4.8.1.3. Data join for edges using D3 pattern\n    const edgeLines = g\n      .selectAll<SVGLineElement, Edge>("line.edge")\n      .data(validEdges, (d) => d.id);\n\n    // ##### 4.8.1.4. Enter selection for new edges\n    const enterEdges = edgeLines\n      .enter()\n      .append("line")\n      .attr("class", "edge")\n      .attr("stroke", "var(--mantine-color-gray-6)")\n      .attr("stroke-width", 2)\n      .attr("marker-end", "url(#arrow)")\n      .attr("opacity", 0.7);\n\n    // ##### 4.8.1.5. Merge enter and update selections\n    const allEdges = enterEdges.merge(edgeLines);\n\n    // ##### 4.8.1.6. Update edge positions with proper node-to-node connections\n    allEdges.each(function (d) {\n      const fromPos = getNodePosition(d.from);\n      const toPos = getNodePosition(d.to);\n\n      if (fromPos && toPos) {\n        const { x1, y1, x2, y2 } = calculateEdgePoints(fromPos, toPos);\n\n        d3.select(this)\n          .attr("x1", x1)\n          .attr("y1", y1)\n          .attr("x2", x2)\n          .attr("y2", y2);\n      }\n    });\n\n    // ##### 4.8.1.7. Remove edges that are no longer needed\n    edgeLines.exit().remove();\n\n    // ##### 4.8.1.8. Data join for edge labels\n    const edgeLabels = g\n      .selectAll<SVGTextElement, Edge>("text.edge-label")\n      .data(validEdges, (d) => d.id);\n\n    // ##### 4.8.1.9. Enter selection for new edge labels\n    const enterLabels = edgeLabels\n      .enter()\n      .append("text")\n      .attr("class", "edge-label")\n      .attr("text-anchor", "middle")\n      .attr("dominant-baseline", "middle")\n      .style("font-size", "10px")\n      .style("font-family", "var(--mantine-font-family)")\n      .style("fill", "var(--mantine-color-gray-7)")\n      .style("background", "white")\n      .style("pointer-events", "none");\n\n    // ##### 4.8.1.10. Merge enter and update selections for labels\n    const allLabels = enterLabels.merge(edgeLabels);\n\n    // ##### 4.8.1.11. Update edge label positions and text - position above the line\n    allLabels.each(function (d) {\n      const fromPos = getNodePosition(d.from);\n      const toPos = getNodePosition(d.to);\n\n      if (fromPos && toPos) {\n        const { x1, y1, x2, y2 } = calculateEdgePoints(fromPos, toPos);\n\n        // Calculate midpoint of the actual edge line\n        const midX = (x1 + x2) / 2;\n        const midY = (y1 + y2) / 2;\n\n        // Calculate perpendicular offset to position text above the line\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n          // Perpendicular vector (rotated 90 degrees)\n          const perpX = -dy / distance;\n          const perpY = dx / distance;\n\n          // Offset text above the line\n          const offsetDistance = 12; // pixels above the line\n          const textX = midX + perpX * offsetDistance;\n          const textY = midY + perpY * offsetDistance;\n\n          d3.select(this).attr("x", textX).attr("y", textY).text(d.description);\n        }\n      }\n    });\n\n    // ##### 4.8.1.12. Remove labels that are no longer needed\n    edgeLabels.exit().remove();\n  }, [edges, fileNodes, nodePositions]);\n\n  // #### 4.8.2. Render nodes with D3\n  useEffect(() => {\n    if (!gRef.current) return;\n\n    const g = d3.select(gRef.current);\n\n    // ##### 4.8.2.1. Setup drag behavior for nodes\n    const dragBehavior = d3\n      .drag<SVGGElement, FileNodeData>()\n      .on("start", (event, d) => {\n        // Prevent canvas zoom/pan while dragging nodes\n        event.sourceEvent.stopPropagation();\n\n        // Store initial position for the pure function\n        initialNodePositionRef.current = d.position;\n\n        // Store drag start point in screen coordinates\n        const startPoint = {\n          x: event.sourceEvent.clientX,\n          y: event.sourceEvent.clientY,\n        };\n\n        setCanvasState((prev) => ({\n          ...prev,\n          isDragging: true,\n          dragType: "node",\n          draggedNodeId: d.id,\n          dragStartPoint: startPoint,\n        }));\n      })\n      .on("drag", (event, d) => {\n        event.sourceEvent.stopPropagation();\n\n        // Get current state from refs to avoid stale closures\n        const currentCanvasState = canvasStateRef.current;\n        const currentNodePositions = nodePositionsRef.current;\n\n        if (!currentCanvasState.dragStartPoint) return;\n\n        // Get current mouse position in screen coordinates\n        const currentPoint: Point = {\n          x: event.sourceEvent.clientX,\n          y: event.sourceEvent.clientY,\n        };\n\n        // Use pure function to calculate new node positions\n        const newNodePositions = dragNode(\n          currentNodePositions,\n          d.id,\n          currentCanvasState.dragStartPoint,\n          currentPoint,\n          currentCanvasState.zoom,\n          initialNodePositionRef.current\n        );\n\n        setNodePositions(newNodePositions);\n      })\n      .on("end", (event, d) => {\n        event.sourceEvent.stopPropagation();\n\n        const currentCanvasState = canvasStateRef.current;\n\n        if (!currentCanvasState.dragStartPoint) {\n          // Reset state if no drag start point (error case)\n          setCanvasState((prev) => ({\n            ...prev,\n            isDragging: false,\n            dragType: null,\n            draggedNodeId: null,\n            dragStartPoint: null,\n          }));\n          return;\n        }\n\n        // Get end position in screen coordinates\n        const endPoint: Point = {\n          x: event.sourceEvent.clientX,\n          y: event.sourceEvent.clientY,\n        };\n\n        // Check if this was a click vs drag (movement threshold)\n        const isClick =\n          Math.abs(endPoint.x - currentCanvasState.dragStartPoint.x) < 5 &&\n          Math.abs(endPoint.y - currentCanvasState.dragStartPoint.y) < 5;\n\n        if (isClick) {\n          // Handle click - toggle node selection\n          const newCanvasState = clickNode(currentCanvasState, d.id);\n          setCanvasState({\n            ...newCanvasState,\n            isDragging: false,\n            dragType: null,\n            draggedNodeId: null,\n            dragStartPoint: null,\n          });\n        } else {\n          // Handle drag end - just reset drag state\n          setCanvasState((prev) => ({\n            ...prev,\n            isDragging: false,\n            dragType: null,\n            draggedNodeId: null,\n            dragStartPoint: null,\n          }));\n        }\n      });\n\n    // ##### 4.8.2.2. Data join for nodes using D3 pattern\n    const nodeGroups = g\n      .selectAll<SVGGElement, FileNodeData>("g.file-node")\n      .data(fileNodes, (d) => d.id);\n\n    // ##### 4.8.2.3. Enter selection for new nodes\n    const enterGroups = nodeGroups\n      .enter()\n      .append("g")\n      .attr("class", "file-node")\n      .style("cursor", "move")\n      .call(dragBehavior);\n\n    // ##### 4.8.2.4. Add rectangle shape to new node groups\n    enterGroups\n      .append("rect")\n      .attr("width", NODE_WIDTH)\n      .attr("height", NODE_HEIGHT)\n      .attr("rx", 8)\n      .attr("x", -NODE_WIDTH / 2)\n      .attr("y", -NODE_HEIGHT / 2);\n\n    // ##### 4.8.2.5. Add text labels to new node groups\n    enterGroups\n      .append("text")\n      .attr("text-anchor", "middle")\n      .attr("dominant-baseline", "middle")\n      .style("font-size", "12px")\n      .style("font-family", "var(--mantine-font-family)")\n      .style("font-weight", "500")\n      .style("pointer-events", "none")\n      .text((d) =>\n        d.name.length > 15 ? `${d.name.substring(0, 12)}...` : d.name\n      );\n\n    // ##### 4.8.2.6. Merge enter and update selections\n    const allGroups = enterGroups.merge(nodeGroups);\n\n    // ##### 4.8.2.7. Update node positions\n    allGroups.attr(\n      "transform",\n      (d) => `translate(${d.position.x}, ${d.position.y})`\n    );\n\n    // ##### 4.8.2.8. Update visual states based on selection and drag\n    allGroups\n      .select("rect")\n      .attr("fill", (d) => {\n        if (canvasState.selectedNodeId === d.id)\n          return "var(--mantine-color-blue-2)";\n        return "var(--mantine-color-blue-1)";\n      })\n      .attr("stroke", (d) => {\n        if (canvasState.selectedNodeId === d.id)\n          return "var(--mantine-color-blue-6)";\n        return "var(--mantine-color-blue-3)";\n      })\n      .attr("stroke-width", (d) => {\n        if (canvasState.selectedNodeId === d.id) return 3;\n        return 1;\n      })\n      .style("opacity", (d) => {\n        if (canvasState.draggedNodeId === d.id) return 0.8;\n        return 1;\n      });\n\n    // ##### 4.8.2.9. Update text color\n    allGroups.select("text").attr("fill", "var(--mantine-color-blue-9)");\n\n    // ##### 4.8.2.10. Setup hover effects for interactive feedback\n    allGroups\n      .on("mouseenter", function (_event, d) {\n        if (canvasState.draggedNodeId !== d.id) {\n          d3.select(this)\n            .select("rect")\n            .attr("stroke", "var(--mantine-color-blue-4)")\n            .attr("stroke-width", 2);\n        }\n      })\n      .on("mouseleave", function (_event, d) {\n        if (canvasState.draggedNodeId !== d.id) {\n          const isSelected = canvasState.selectedNodeId === d.id;\n          d3.select(this)\n            .select("rect")\n            .attr(\n              "stroke",\n              isSelected\n                ? "var(--mantine-color-blue-6)"\n                : "var(--mantine-color-blue-3)"\n            )\n            .attr("stroke-width", isSelected ? 3 : 1);\n        }\n      });\n\n    // ##### 4.8.2.11. Remove nodes that are no longer needed\n    nodeGroups.exit().remove();\n  }, [fileNodes, canvasState, nodePositions]);\n\n  // ### 4.9. Component Render - Container for D3 SVG canvas\n  return (\n    <Box\n      ref={containerRef}\n      style={{\n        width: "100%",\n        height: 400,\n        border: "1px solid var(--mantine-color-gray-3)",\n        borderRadius: "var(--mantine-radius-md)",\n        overflow: "hidden",\n        // Dynamic cursor based on interaction state\n        cursor: canvasState.isDragging\n          ? canvasState.dragType === "canvas"\n            ? "grabbing"\n            : "move"\n          : "grab",\n      }}\n    />\n  );\n}\n',
    size: 21386,
    dependents: [
      {
        name: "step-two-describe-relations.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-three-view-results/step-three-view-results.tsx",
    name: "step-three-view-results.tsx",
    content:
      'import { Stack, Box, Title, Text } from "@mantine/core";\n\nexport function StepThreeViewResults() {\n  return (\n    <Stack gap="lg">\n      <Box ta="center">\n        <Title order={2} mb="md">\n          Review Results\n        </Title>\n        <Text c="dimmed" size="lg">\n          Review and download your generated test cases\n        </Text>\n      </Box>\n      {/* This will be implemented later */}\n      <Text ta="center" c="green">\n        Coming soon: Generated test results\n      </Text>\n    </Stack>\n  );\n}\n',
    size: 510,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/use-file-tree.ts",
    name: "use-file-tree.ts",
    content:
      '// # 3. File Tree State Management Hook\n// Custom hook for managing file tree state and operations\n\nimport { useState, useEffect, useMemo, useCallback } from "react";\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\nimport { type TreeNode } from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-item";\nimport {\n  buildFileTree,\n  getFirstLevelDirectories,\n} from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-utils";\n\n// # 3.1 Hook Interface\ninterface UseFileTreeProps {\n  repoFiles: RepoFile[];\n  selectedFiles: SelectedRepoFile[];\n}\n\n// # 3.2 Hook Return Type\ninterface UseFileTreeReturn {\n  fileTree: TreeNode[];\n  expandedDirectories: Set<string>;\n  toggleDirectoryExpansion: (path: string) => void;\n}\n\n// # 3.3 Main Hook Implementation\n// Manages tree state, expansion, and provides utility functions\nexport function useFileTree({\n  repoFiles,\n}: UseFileTreeProps): UseFileTreeReturn {\n  // # 3.3.1 State Management\n  const [expandedDirectories, setExpandedDirectories] = useState<Set<string>>(\n    new Set()\n  );\n\n  // # 3.3.2 Build Tree Structure\n  // Build tree structure from files (memoized to prevent unnecessary re-renders)\n  const fileTree = useMemo(() => {\n    return repoFiles.length > 0 ? buildFileTree(repoFiles) : [];\n  }, [repoFiles]);\n\n  // # 3.3.3 Directory Expansion Functions\n\n  // # 3.3.3.1 Toggle Single Directory\n  const toggleDirectoryExpansion = useCallback((path: string) => {\n    setExpandedDirectories((prev) => {\n      const newSet = new Set(prev);\n      if (newSet.has(path)) {\n        newSet.delete(path);\n      } else {\n        newSet.add(path);\n      }\n      return newSet;\n    });\n  }, []);\n\n  // # 3.3.4 Auto-expand Effect\n  // Auto-expand first level directories when files are first loaded\n  useEffect(() => {\n    if (repoFiles.length > 0 && expandedDirectories.size === 0) {\n      const firstLevelDirs = getFirstLevelDirectories(fileTree);\n      setExpandedDirectories(new Set(firstLevelDirs));\n    }\n  }, [repoFiles.length, fileTree, expandedDirectories.size]);\n\n  // # 3.3.5 Return Hook Interface\n  return {\n    fileTree,\n    expandedDirectories,\n    toggleDirectoryExpansion,\n  };\n}\n',
    size: 2190,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/tree-utils.ts",
    name: "tree-utils.ts",
    content:
      '// # 2. Tree Utility Functions\n// Contains helper functions for building and managing file tree structures\n\nimport type { RepoFile } from "src/types/repo";\nimport type { TreeNode } from "./tree-item";\n\n// # 2.1 Build File Tree Function\n// Converts a flat list of RepoFile objects into a hierarchical tree structure\nexport function buildFileTree(files: RepoFile[]): TreeNode[] {\n  // # 2.1.1 Initialize Tree Structure\n  const tree: TreeNode[] = [];\n  const pathToNode: Map<string, TreeNode> = new Map();\n\n  // # 2.1.2 Sort Files for Proper Tree Building\n  // Sort files by path to ensure proper hierarchical construction\n  const sortedFiles = [...files].sort((a, b) => a.path.localeCompare(b.path));\n\n  // # 2.1.3 Process Each File\n  for (const file of sortedFiles) {\n    const pathParts = file.path.split("/");\n    let currentPath = "";\n\n    // # 2.1.4 Build Path Hierarchy\n    // Create directory nodes for each part of the file path\n    for (let i = 0; i < pathParts.length; i++) {\n      const part = pathParts[i];\n      const parentPath = currentPath;\n      currentPath = currentPath ? `${currentPath}/${part}` : part;\n\n      // # 2.1.5 Create Node if Not Exists\n      if (!pathToNode.has(currentPath)) {\n        const isFile = i === pathParts.length - 1;\n        const node: TreeNode = {\n          path: currentPath,\n          name: part,\n          type: isFile ? "file" : "directory",\n          file: isFile ? file : undefined,\n          children: [],\n          depth: i,\n        };\n\n        pathToNode.set(currentPath, node);\n\n        // # 2.1.6 Link to Parent or Root\n        if (parentPath && pathToNode.has(parentPath)) {\n          pathToNode.get(parentPath)!.children.push(node);\n        } else if (i === 0) {\n          tree.push(node);\n        }\n      }\n    }\n  }\n\n  return tree;\n}\n\n// # 2.2 Collect Directory Paths Function\n// Recursively collects all directory paths from a tree structure\nexport function collectDirectoryPaths(nodes: TreeNode[]): Set<string> {\n  const allDirectoryPaths = new Set<string>();\n\n  const traverse = (nodeList: TreeNode[]) => {\n    nodeList.forEach((node) => {\n      if (node.type === "directory") {\n        allDirectoryPaths.add(node.path);\n        if (node.children.length > 0) {\n          traverse(node.children);\n        }\n      }\n    });\n  };\n\n  traverse(nodes);\n  return allDirectoryPaths;\n}\n\n// # 2.3 Get First Level Directories Function\n// Extracts only the top-level directory paths from a tree\nexport function getFirstLevelDirectories(tree: TreeNode[]): string[] {\n  return tree\n    .filter((node) => node.type === "directory" && node.depth === 0)\n    .map((node) => node.path);\n}\n',
    size: 2632,
    dependents: [
      {
        name: "use-file-tree.ts",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/use-file-tree.ts",
      },
    ],
  },
];

export const MOCK_SELECTED_FILES_2 = [
  {
    path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
    name: "generate-tests.tsx",
    content:
      'import { createFileRoute } from "@tanstack/react-router";\nimport { useState } from "react";\nimport { Container, Paper, Center, Box, Stepper } from "@mantine/core";\nimport { useDependencies } from "src/hooks/use-dependencies";\nimport { useRepoConnection } from "src/hooks/use-repo-connection";\nimport { StepperNavigationButtons } from "src/components/stepper-navigation-buttons";\nimport { StepOneUploadFiles } from "src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files";\nimport { StepTwoDescribeRelations } from "src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations";\nimport { StepThreeViewResults } from "src/routes/(generate-tests)/-components/step-three-view-results/step-three-view-results";\nimport { useFileTree } from "./-components/step-one-upload-files/use-file-tree";\nimport { IconChevronRight, IconSparkles } from "@tabler/icons-react";\nimport { useAnnotate } from "src/hooks/use-annotate";\n\n// Interface to make SelectedRepoFile compatible with FileWithPath\ninterface FileCompatible {\n  path: string;\n  name: string;\n  size: number;\n  text: string;\n  dependents: {\n    name: string;\n    path: string;\n  }[];\n}\n\nexport const Route = createFileRoute("/(generate-tests)/generate-tests")({\n  component: Index,\n});\n\nfunction Index() {\n  const [currentStep, setCurrentStep] = useState(0);\n\n  const [repoUrl, setRepoUrl] = useState(\n    "https://github.com/piotrnajda3000/handoff.git"\n  );\n  const [accessToken, setAccessToken] = useState(\n    "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"\n  );\n\n  // Repository connection hook - manages selected files internally\n  const repoConnectionData = useRepoConnection();\n  const { selectedFiles } = repoConnectionData;\n\n  console.log({ selectedFiles });\n\n  // Convert SelectedRepoFile to FileWithPath for existing dependencies hook\n  const fileCompatibleFiles: FileCompatible[] = selectedFiles.map((file) => ({\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    text: file.content, // Add content for compatibility\n    dependents: file.dependents || [],\n  }));\n\n  // File Tree Management Hook\n  const { fileTree, expandedDirectories, toggleDirectoryExpansion } =\n    useFileTree({\n      repoFiles: repoConnectionData.repoFiles,\n      selectedFiles,\n    });\n\n  // Feature Name State\n  const [featureName, setFeatureName] = useState("");\n\n  const dependenciesData = useDependencies(fileCompatibleFiles);\n\n  const stepTitles = [\n    "Connect Repository",\n    "Generate Report",\n    "Review Results",\n  ];\n  const totalSteps = stepTitles.length;\n\n  const [hasGeneratedTests, setHasGeneratedTests] = useState(false);\n\n  const canProceedToNext = currentStep === 0 ? selectedFiles.length > 0 : true;\n\n  const getNextButtonTooltip = () => {\n    if (currentStep === 0) {\n      if (selectedFiles.length === 0) {\n        return "Please select files from your repository to continue";\n      }\n    }\n    if (currentStep === totalSteps - 1) {\n      return "Complete the process";\n    }\n    return "";\n  };\n\n  const handleNext = () => {\n    if (currentStep === 1) {\n      if (!hasGeneratedTests) {\n        handleGenerateTests();\n        return;\n      }\n    }\n    if (currentStep < totalSteps - 1) {\n      setCurrentStep(currentStep + 1);\n    }\n  };\n\n  const handlePrevious = () => {\n    if (currentStep > 0) {\n      setCurrentStep(currentStep - 1);\n    }\n  };\n\n  const {\n    mutateAsync: generateReport,\n    isPending: isGeneratingReport,\n    data: report,\n  } = useAnnotate();\n\n  const handleGenerateTests = () => {\n    generateReport(\n      fileCompatibleFiles.filter((file) =>\n        dependenciesData.dependencies.some(\n          (dependency) =>\n            dependency.from === file.path || dependency.to === file.path\n        )\n      )\n    ).then((res) => {\n      setHasGeneratedTests(true);\n      setCurrentStep(2);\n    });\n  };\n\n  const renderStepContent = () => {\n    switch (currentStep) {\n      case 0:\n        return (\n          <StepOneUploadFiles\n            repoConnectionData={repoConnectionData}\n            repoUrl={repoUrl}\n            setRepoUrl={setRepoUrl}\n            accessToken={accessToken}\n            setAccessToken={setAccessToken}\n            fileTree={fileTree}\n            expandedDirectories={expandedDirectories}\n            featureName={featureName}\n            setFeatureName={setFeatureName}\n            toggleDirectoryExpansion={toggleDirectoryExpansion}\n          />\n        );\n      case 1:\n        return (\n          <StepTwoDescribeRelations\n            files={fileCompatibleFiles}\n            dependenciesData={dependenciesData}\n          />\n        );\n      case 2:\n        return <StepThreeViewResults report={report} />;\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <Container size="md" className="h-full flex flex-col">\n      <Center className="my-auto">\n        <Paper className="w-full max-w-[700px] h-full shadow-lg rounded-md p-xl">\n          <div className="flex flex-col">\n            {/* Step Progress Indicator */}\n            <Box>\n              <Stepper active={currentStep} size="sm">\n                {stepTitles.map((title, index) => (\n                  <Stepper.Step key={index} label={title} data-qa={`step`} />\n                ))}\n              </Stepper>\n            </Box>\n\n            {/* Step Content */}\n            <div className="mt-xl">{renderStepContent()}</div>\n\n            {/* Navigation */}\n            <div className="mt-xl">\n              <StepperNavigationButtons\n                currentStep={currentStep}\n                totalSteps={totalSteps}\n                onNext={handleNext}\n                onPrevious={handlePrevious}\n                nextButtonLoading={isGeneratingReport}\n                canProceedToNext={canProceedToNext}\n                nextButtonTooltip={getNextButtonTooltip()}\n                nextButtonIcon={\n                  currentStep === 1 ? (\n                    <IconSparkles size={16} />\n                  ) : (\n                    <IconChevronRight size={16} />\n                  )\n                }\n                nextButtonText={currentStep === 1 ? "Generate Report" : "Next"}\n              />\n            </div>\n          </div>\n        </Paper>\n      </Center>\n    </Container>\n  );\n}\n',
    size: 6228,
    dependents: [],
  },
  {
    path: "ui/src/hooks/use-dependencies.tsx",
    name: "use-dependencies.tsx",
    content:
      'import { useState } from "react";\nimport type { Edge } from "../routes/(generate-tests)/-components/interactive-canvas/interactive-canvas";\n\nexport interface Dependency {\n  id: string;\n  from: string;\n  to: string;\n  connection: string;\n}\n\n// Make the hook more flexible to accept file-like objects\ninterface FileWithPathOrContent {\n  path?: string;\n  name: string;\n  size?: number;\n  dependents?: {\n    name: string;\n    path: string;\n  }[];\n}\n\nexport function useDependencies(files: FileWithPathOrContent[]) {\n  const [dependencies, setDependencies] = useState<Dependency[]>([]);\n\n  // Generate file options for select dropdowns\n  const fileOptions = files.map((file) => ({\n    value: file.path || file.name,\n    label: file.path || file.name,\n  }));\n\n  const connectionOptions = [\n    { value: "uses", label: "uses" },\n    { value: "tests", label: "tests" },\n    { value: "describes", label: "describes" },\n  ];\n\n  const addDependency = () => {\n    const newDependency: Dependency = {\n      id: crypto.randomUUID(),\n      from: "",\n      to: "",\n      connection: "uses",\n    };\n    setDependencies([...dependencies, newDependency]);\n  };\n\n  const updateDependency = (\n    id: string,\n    field: keyof Dependency,\n    value: string\n  ) => {\n    setDependencies(\n      dependencies.map((dep) =>\n        dep.id === id ? { ...dep, [field]: value } : dep\n      )\n    );\n  };\n\n  const removeDependency = (id: string) => {\n    setDependencies(dependencies.filter((dep) => dep.id !== id));\n  };\n\n  // Convert dependencies to edges for the canvas\n  const convertDependenciesToEdges = (): Edge[] => {\n    // Create mapping from file path/name to node ID\n    const fileToNodeIdMap = new Map<string, string>();\n    files.forEach((file, index) => {\n      const fileIdentifier = file.path || file.name;\n      fileToNodeIdMap.set(fileIdentifier, `file-${index}`);\n    });\n\n    // Convert dependencies to edges\n    return dependencies\n      .filter((dep) => {\n        // Only include dependencies where both from and to files exist\n        return fileToNodeIdMap.has(dep.from) && fileToNodeIdMap.has(dep.to);\n      })\n      .map((dep) => ({\n        id: dep.id,\n        from: fileToNodeIdMap.get(dep.from)!,\n        to: fileToNodeIdMap.get(dep.to)!,\n        description: dep.connection,\n      }));\n  };\n\n  const edges = convertDependenciesToEdges();\n\n  const generateDependencies = () => {\n    const generatedDependencies: Dependency[] = [];\n\n    // Iterate through all files and use their dependents array to create dependencies\n    files.forEach((file) => {\n      const fileIdentifier = file.path || file.name;\n\n      console.log(file);\n\n      // If this file has dependents, create dependencies for each one\n      if (file.dependents && file.dependents.length > 0) {\n        file.dependents.forEach((dependent) => {\n          // Create a dependency: dependent file "uses" current file\n          const dependency: Dependency = {\n            id: crypto.randomUUID(),\n            from: dependent.path, // The file that imports this one\n            to: fileIdentifier, // The current file being imported\n            connection: "uses", // Default connection type\n          };\n\n          // Check if this dependency already exists to avoid duplicates\n          const existsInGenerated = generatedDependencies.some(\n            (dep) => dep.from === dependency.from && dep.to === dependency.to\n          );\n          const existsInCurrent = dependencies.some(\n            (dep) => dep.from === dependency.from && dep.to === dependency.to\n          );\n\n          if (!existsInGenerated && !existsInCurrent) {\n            generatedDependencies.push(dependency);\n          }\n        });\n      }\n    });\n\n    // Add the generated dependencies to the existing ones\n    if (generatedDependencies.length > 0) {\n      setDependencies([...dependencies, ...generatedDependencies]);\n      console.log(\n        `Generated ${generatedDependencies.length} dependencies from file relationships`\n      );\n    } else {\n      console.log("No dependencies found in file relationships");\n    }\n  };\n\n  return {\n    dependencies,\n    fileOptions,\n    connectionOptions,\n    edges,\n    addDependency,\n    updateDependency,\n    removeDependency,\n    generateDependencies,\n  };\n}\n',
    size: 4240,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/hooks/use-repo-connection.ts",
    name: "use-repo-connection.ts",
    content:
      'import { useState, useCallback } from "react";\nimport {\n  type RepoConnection,\n  type RepoFile,\n  type SelectedRepoFile,\n} from "../types/repo";\nimport { apiPost } from "../utils/api";\nimport {\n  extractImportStatements,\n  extractFromPaths,\n  filterRelevantImports,\n  resolveToFullPaths,\n} from "../utils/import-parse.util";\n// import { MOCK_SELECTED_FILES } from "src/mocks/files.mock";\n\nexport interface UseRepoConnectionReturn {\n  // Connection state\n  connection: RepoConnection | null;\n  isConnected: boolean;\n  isConnecting: boolean;\n  connectionError: string | null;\n\n  // File listing state\n  repoFiles: RepoFile[];\n  isLoadingFiles: boolean;\n  fileLoadError: string | null;\n\n  // Selected files state\n  selectedFiles: SelectedRepoFile[];\n\n  // File content loading state\n  loadingFiles: Set<string>;\n\n  // Actions\n  connectToRepo: (repoUrl: string, token: string) => Promise<void>;\n  disconnect: () => void;\n  loadRepoFiles: () => Promise<void>;\n  toggleFileSelection: (file: RepoFile) => Promise<void>;\n  selectFileWithDependencies: (file: RepoFile) => Promise<void>;\n  clearSelectedFiles: () => void;\n}\n\nexport function useRepoConnection(): UseRepoConnectionReturn {\n  const [connection, setConnection] = useState<RepoConnection | null>(null);\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [connectionError, setConnectionError] = useState<string | null>(null);\n\n  const [repoFiles, setRepoFiles] = useState<RepoFile[]>([]);\n  const [isLoadingFiles, setIsLoadingFiles] = useState(false);\n  const [fileLoadError, setFileLoadError] = useState<string | null>(null);\n\n  const [selectedFiles, setSelectedFiles] =\n    // useState<SelectedRepoFile[]>(MOCK_SELECTED_FILES);\n    useState<SelectedRepoFile[]>([]);\n  const [loadingFiles, setLoadingFiles] = useState<Set<string>>(new Set());\n\n  const parseRepoUrl = (url: string) => {\n    // Support both HTTPS and SSH GitHub URLs\n    const githubHttpsMatch = url.match(\n      /https:\\/\\/github\\.com\\/([^\\/]+)\\/([^\\/]+)(?:\\.git)?/\n    );\n    const githubSshMatch = url.match(\n      /git@github\\.com:([^\\/]+)\\/([^\\/]+)(?:\\.git)?/\n    );\n\n    if (githubHttpsMatch) {\n      return {\n        provider: "github" as const,\n        owner: githubHttpsMatch[1],\n        repo: githubHttpsMatch[2].replace(".git", ""),\n      };\n    }\n\n    if (githubSshMatch) {\n      return {\n        provider: "github" as const,\n        owner: githubSshMatch[1],\n        repo: githubSshMatch[2].replace(".git", ""),\n      };\n    }\n\n    throw new Error(\n      "Unsupported repository URL format. Please use a GitHub HTTPS or SSH URL."\n    );\n  };\n\n  const connectToRepo = useCallback(async (repoUrl: string, token: string) => {\n    setIsConnecting(true);\n    setConnectionError(null);\n\n    try {\n      const { provider, owner, repo } = parseRepoUrl(repoUrl);\n\n      // Test the connection by making a simple API call\n      await apiPost({\n        endpoint: "/repo/test-connection",\n        body: { provider, owner, repo, token },\n      });\n\n      const newConnection: RepoConnection = {\n        provider,\n        url: repoUrl,\n        token,\n        owner,\n        repo,\n      };\n\n      setConnection(newConnection);\n      console.log("Successfully connected to repository:", { owner, repo });\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : "Failed to connect to repository";\n      setConnectionError(errorMessage);\n      console.error("Repository connection failed:", error);\n    } finally {\n      setIsConnecting(false);\n    }\n  }, []);\n\n  const disconnect = useCallback(() => {\n    setConnection(null);\n    setRepoFiles([]);\n    setSelectedFiles([]);\n    setLoadingFiles(new Set());\n    setConnectionError(null);\n    setFileLoadError(null);\n  }, []);\n\n  const loadRepoFiles = useCallback(async () => {\n    if (!connection) return;\n\n    setIsLoadingFiles(true);\n    setFileLoadError(null);\n\n    try {\n      const response = await apiPost<typeof connection, RepoFile[]>({\n        endpoint: "/repo/list-files",\n        body: connection,\n      });\n\n      // Filter to only show supported file types\n      const supportedExtensions = [".js", ".jsx", ".ts", ".tsx"];\n      const filteredFiles = response.filter(\n        (file) =>\n          file.type === "file" &&\n          supportedExtensions.some((ext) =>\n            file.path.toLowerCase().endsWith(ext)\n          )\n      );\n\n      setRepoFiles(filteredFiles);\n      console.log("Loaded repository files:", filteredFiles.length);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : "Failed to load repository files";\n      setFileLoadError(errorMessage);\n      console.error("Failed to load repository files:", error);\n    } finally {\n      setIsLoadingFiles(false);\n    }\n  }, [connection]);\n\n  const toggleFileSelection = useCallback(\n    async (file: RepoFile) => {\n      if (!connection) return;\n\n      const isSelected = selectedFiles.some((f) => f.path === file.path);\n\n      if (isSelected) {\n        // Remove from selection\n        setSelectedFiles((prev) => prev.filter((f) => f.path !== file.path));\n      } else {\n        // Add to selection - need to fetch file content\n        // Set loading state for this file\n        setLoadingFiles((prev) => new Set([...prev, file.path]));\n\n        try {\n          const response = await apiPost<\n            { connection: RepoConnection; filePath: string },\n            { content: string }\n          >({\n            endpoint: "/repo/get-file-content",\n            body: { connection, filePath: file.path },\n          });\n\n          const selectedFile: SelectedRepoFile = {\n            path: file.path,\n            name: file.name,\n            content: response.content,\n            size: file.size || 0,\n          };\n\n          setSelectedFiles((prev) => [...prev, selectedFile]);\n          console.log("Added file to selection:", file.path);\n        } catch (error) {\n          console.error("Failed to fetch file content:", error);\n        } finally {\n          // Remove loading state for this file\n          setLoadingFiles((prev) => {\n            const newSet = new Set(prev);\n            newSet.delete(file.path);\n            return newSet;\n          });\n        }\n      }\n    },\n    [connection, selectedFiles]\n  );\n\n  const selectFileWithDependencies = useCallback(\n    async (file: RepoFile) => {\n      if (!connection) return;\n\n      // Keep track of files being processed to avoid circular dependencies\n      const processingFiles = new Set<string>();\n      const processedFiles = new Set<string>();\n\n      const processFile = async (\n        targetFile: RepoFile,\n        parentFile?: RepoFile\n      ): Promise<void> => {\n        // Skip if already selected or being processed\n        const isAlreadySelected = selectedFiles.some(\n          (f) => f.path === targetFile.path\n        );\n\n        if (\n          isAlreadySelected ||\n          processingFiles.has(targetFile.path) ||\n          processedFiles.has(targetFile.path)\n        ) {\n          // If file is already selected but we have a new parent, update dependents\n          if (isAlreadySelected && parentFile) {\n            setSelectedFiles((prev) =>\n              prev.map((f) => {\n                if (f.path === targetFile.path) {\n                  const existingDependents = f.dependents || [];\n                  // Check if this parent is already in dependents\n                  const isParentAlreadyDependent = existingDependents.some(\n                    (dep) => dep.path === parentFile.path\n                  );\n\n                  if (!isParentAlreadyDependent) {\n                    return {\n                      ...f,\n                      dependents: [\n                        ...existingDependents,\n                        { name: parentFile.name, path: parentFile.path },\n                      ],\n                    };\n                  }\n                }\n                return f;\n              })\n            );\n          }\n          return;\n        }\n\n        // Mark as processing\n        processingFiles.add(targetFile.path);\n\n        // Set loading state for this file\n        setLoadingFiles((prev) => new Set([...prev, targetFile.path]));\n\n        try {\n          // Fetch file content\n          const response = await apiPost<\n            { connection: RepoConnection; filePath: string },\n            { content: string }\n          >({\n            endpoint: "/repo/get-file-content",\n            body: { connection, filePath: targetFile.path },\n          });\n\n          processedFiles.add(targetFile.path);\n\n          const selectedFile: SelectedRepoFile = {\n            path: targetFile.path,\n            name: targetFile.name,\n            content: response.content,\n            size: targetFile.size || 0,\n            // Initialize dependents array with parent if this file has one\n            dependents: parentFile\n              ? [{ name: parentFile.name, path: parentFile.path }]\n              : [],\n          };\n\n          // Add to selected files\n          setSelectedFiles((prev) => [...prev, selectedFile]);\n          console.log("Added file to selection:", targetFile.path);\n\n          // Parse imports and recursively select dependencies\n          const imports = extractImportStatements(response.content);\n          const fromPaths = extractFromPaths(imports);\n\n          // Create all possible paths from repoFiles for filtering\n          const allRepoPaths = repoFiles.map((f) =>\n            f.path.split("/").slice(0, -1).join("/")\n          );\n\n          // Get the root folder - assume it\'s the first segment of any file path\n          const rootFolder = targetFile.path.split("/")[0];\n\n          const relevantImports = filterRelevantImports(\n            fromPaths,\n            allRepoPaths,\n            rootFolder\n          );\n\n          const fullImportPaths = resolveToFullPaths(\n            relevantImports,\n            targetFile.path,\n            rootFolder\n          );\n\n          // Find matching files and recursively process them\n          for (const importPath of fullImportPaths) {\n            // Try to find the file with exact path match first\n            let matchingFile = repoFiles.find((f) => f.path === importPath);\n\n            // If not found, try with common extensions\n            if (!matchingFile) {\n              const extensions = [".ts", ".tsx", ".js", ".jsx"];\n              for (const ext of extensions) {\n                matchingFile = repoFiles.find(\n                  (f) => f.path === `${importPath}${ext}`\n                );\n                if (matchingFile) break;\n              }\n            }\n\n            // If still not found, try removing extension and looking for index files\n            if (!matchingFile) {\n              const indexFiles = [\n                "index.ts",\n                "index.tsx",\n                "index.js",\n                "index.jsx",\n              ];\n              for (const indexFile of indexFiles) {\n                matchingFile = repoFiles.find(\n                  (f) => f.path === `${importPath}/${indexFile}`\n                );\n                if (matchingFile) break;\n              }\n            }\n\n            if (matchingFile) {\n              // Pass current file as parent to track dependents\n              await processFile(matchingFile, targetFile);\n            }\n          }\n        } catch (error) {\n          console.error(\n            `Failed to fetch file content for ${targetFile.path}:`,\n            error\n          );\n        } finally {\n          // Remove loading state for this file\n          setLoadingFiles((prev) => {\n            const newSet = new Set(prev);\n            newSet.delete(targetFile.path);\n            return newSet;\n          });\n\n          // Remove from processing set\n          processingFiles.delete(targetFile.path);\n        }\n      };\n\n      // Start processing from the root file\n      await processFile(file);\n    },\n    [connection, selectedFiles, repoFiles]\n  );\n\n  const clearSelectedFiles = useCallback(() => {\n    setSelectedFiles([]);\n  }, []);\n\n  return {\n    // Connection state\n    connection,\n    isConnected: !!connection,\n    isConnecting,\n    connectionError,\n\n    // File listing state\n    repoFiles,\n    isLoadingFiles,\n    fileLoadError,\n\n    // Selected files state\n    selectedFiles,\n\n    // File content loading state\n    loadingFiles,\n\n    // Actions\n    connectToRepo,\n    disconnect,\n    loadRepoFiles,\n    toggleFileSelection,\n    selectFileWithDependencies,\n    clearSelectedFiles,\n  };\n}\n',
    size: 12482,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/mocks/files.mock.ts",
    name: "files.mock.ts",
    content:
      'export const FILES_TO_TEXT = [\n  {\n    name: "index.tsx",\n    text: \'import { createFileRoute } from "@tanstack/react-router";\\nimport { useEffect, useMemo, useState } from "react";\\nimport {\\n  Container,\\n  Paper,\\n  Stack,\\n  Center,\\n  Title,\\n  Text,\\n  Box,\\n  Button,\\n  Group,\\n  Stepper,\\n  Tooltip,\\n} from "@mantine/core";\\nimport {\\n  IconChevronLeft,\\n  IconChevronRight,\\n  IconCheck,\\n} from "@tabler/icons-react";\\nimport { FileDropzone } from "../../components/dropzone/dropzone";\\nimport { useDropzone } from "../../components/dropzone/use-dropzone";\\n\\nexport const Route = createFileRoute("/generate-tests/")({\\n  component: Index,\\n});\\n\\nfunction Index() {\\n  const [currentStep, setCurrentStep] = useState(0);\\n  const {\\n    files,\\n    rejectedFiles,\\n    handleDrop,\\n    handleReject,\\n    handleDelete,\\n    handleDeleteRejected,\\n  } = useDropzone();\\n\\n  const [fileBytes, setFileBytes] = useState<Record<string, Uint8Array>>({});\\n\\n  useEffect(() => {\\n    async function getFileBytes() {\\n      if (files.length > 0) {\\n        const fileBytes = await Promise.all(\\n          files.map(async (file) => {\\n            return file.arrayBuffer().then((buffer) => new Uint8Array(buffer));\\n          })\\n        );\\n        setFileBytes(\\n          fileBytes.reduce(\\n            (acc, fileByte, index) => {\\n              acc[files[index].name] = fileByte;\\n              return acc;\\n            },\\n            {} as Record<string, Uint8Array>\\n          )\\n        );\\n      }\\n    }\\n    getFileBytes();\\n  }, [files]);\\n\\n  const fileBytesToText = useMemo(() => {\\n    return Object.entries(fileBytes).map(([name, fileByte]) => {\\n      return {\\n        name,\\n        text: new TextDecoder().decode(fileByte),\\n      };\\n    });\\n  }, [fileBytes]);\\n\\n  console.log({ fileBytesToText });\\n\\n  const stepTitles = ["Upload Files", "Generate Tests", "Review Results"];\\n  const totalSteps = stepTitles.length;\\n\\n  const canProceedToNext =\\n    currentStep === 0 ? files.length > 0 && rejectedFiles.length === 0 : true;\\n\\n  const getNextButtonTooltip = () => {\\n    if (currentStep === 0) {\\n      if (files.length === 0) {\\n        return "Please upload files to continue";\\n      }\\n      if (rejectedFiles.length > 0) {\\n        return "Please remove rejected files to continue";\\n      }\\n    }\\n    if (currentStep === totalSteps - 1) {\\n      return "Complete the process";\\n    }\\n    return "";\\n  };\\n\\n  const handleNext = () => {\\n    if (currentStep < totalSteps - 1) {\\n      setCurrentStep(currentStep + 1);\\n    }\\n  };\\n\\n  const handlePrevious = () => {\\n    if (currentStep > 0) {\\n      setCurrentStep(currentStep - 1);\\n    }\\n  };\\n\\n  const renderStepContent = () => {\\n    switch (currentStep) {\\n      case 0:\\n        return (\\n          <Stack gap="lg">\\n            <Box ta="center">\\n              <Title order={1} size="h2" mb="md">\\n                Welcome to Handoff\\n              </Title>\\n              <Text c="dimmed" size="lg">\\n                Upload your code files to generate natural language test cases\\n              </Text>\\n            </Box>\\n\\n            <FileDropzone\\n              files={files}\\n              rejectedFiles={rejectedFiles}\\n              onDrop={handleDrop}\\n              onReject={handleReject}\\n              onDelete={handleDelete}\\n              onDeleteRejected={handleDeleteRejected}\\n            />\\n          </Stack>\\n        );\\n      case 1:\\n        return (\\n          <Stack gap="lg">\\n            <Box ta="center">\\n              <Title order={2} mb="md">\\n                Generate Tests\\n              </Title>\\n              <Text c="dimmed" size="lg">\\n                Processing your files to generate test cases...\\n              </Text>\\n            </Box>\\n            {/* This will be implemented later */}\\n            <Text ta="center" c="blue">\\n              Coming soon: Test generation in progress\\n            </Text>\\n          </Stack>\\n        );\\n      case 2:\\n        return (\\n          <Stack gap="lg">\\n            <Box ta="center">\\n              <Title order={2} mb="md">\\n                Review Results\\n              </Title>\\n              <Text c="dimmed" size="lg">\\n                Review and download your generated test cases\\n              </Text>\\n            </Box>\\n            {/* This will be implemented later */}\\n            <Text ta="center" c="green">\\n              Coming soon: Generated test results\\n            </Text>\\n          </Stack>\\n        );\\n      default:\\n        return null;\\n    }\\n  };\\n\\n  return (\\n    <Container size="md" style={{ height: "100vh" }}>\\n      <Center style={{ height: "100%" }}>\\n        <Paper\\n          shadow="lg"\\n          radius="md"\\n          p="xl"\\n          style={{ width: "100%", maxWidth: 700 }}\\n        >\\n          <Stack gap="xl">\\n            {/* Step Progress Indicator */}\\n            <Box>\\n              <Stepper active={currentStep} size="sm">\\n                {stepTitles.map((title, index) => (\\n                  <Stepper.Step key={index} label={title} />\\n                ))}\\n              </Stepper>\\n            </Box>\\n\\n            {/* Step Content */}\\n            <Box>{renderStepContent()}</Box>\\n\\n            {/* Navigation */}\\n            <Group justify="space-between">\\n              <Button\\n                variant="outline"\\n                onClick={handlePrevious}\\n                disabled={currentStep === 0}\\n                data-qa="previous-button"\\n                leftSection={<IconChevronLeft size={16} />}\\n              >\\n                Previous\\n              </Button>\\n\\n              <Tooltip\\n                label={getNextButtonTooltip()}\\n                disabled={canProceedToNext && currentStep !== totalSteps - 1}\\n                position="top"\\n                data-qa="next-button-tooltip"\\n              >\\n                <Button\\n                  onClick={handleNext}\\n                  data-qa="next-button"\\n                  disabled={!canProceedToNext || currentStep === totalSteps - 1}\\n                  rightSection={\\n                    currentStep === totalSteps - 1 ? (\\n                      <IconCheck size={16} />\\n                    ) : (\\n                      <IconChevronRight size={16} />\\n                    )\\n                  }\\n                >\\n                  {currentStep === totalSteps - 1 ? "Finish" : "Next"}\\n                </Button>\\n              </Tooltip>\\n            </Group>\\n          </Stack>\\n        </Paper>\\n      </Center>\\n    </Container>\\n  );\\n}\\n\',\n  },\n  {\n    name: "dropzone.tsx",\n    text: \'import {\\n  Dropzone,\\n  type FileWithPath,\\n  type FileRejection,\\n} from "@mantine/dropzone";\\nimport { Box, Text, Group, rem, ActionIcon, Tooltip } from "@mantine/core";\\nimport {\\n  IconUpload,\\n  IconFile,\\n  IconX,\\n  IconBrandJavascript,\\n  IconBrandTypescript,\\n  IconBrandReact,\\n  IconAlertCircle,\\n} from "@tabler/icons-react";\\nimport classes from "./dropzone.module.css";\\n\\ninterface FileDropzoneProps {\\n  files: FileWithPath[];\\n  rejectedFiles?: FileRejection[];\\n  onDrop: (files: FileWithPath[]) => void;\\n  onReject: (files: FileRejection[]) => void;\\n  onDelete?: (index: number) => void;\\n  onDeleteRejected?: (index: number) => void;\\n}\\n\\nconst ALLOWED_EXTENSIONS = [".js", ".jsx", ".ts", ".tsx"];\\n\\nfunction validateFileType(file: FileWithPath): boolean {\\n  const extension = "." + file.name.toLowerCase().split(".").pop();\\n  return ALLOWED_EXTENSIONS.includes(extension);\\n}\\n\\nfunction validateFiles(files: FileWithPath[]): {\\n  acceptedFiles: FileWithPath[];\\n  rejectedFiles: FileRejection[];\\n} {\\n  const acceptedFiles: FileWithPath[] = [];\\n  const rejectedFiles: FileRejection[] = [];\\n\\n  files.forEach((file) => {\\n    if (validateFileType(file)) {\\n      acceptedFiles.push(file);\\n    } else {\\n      rejectedFiles.push({\\n        file,\\n        errors: [\\n          {\\n            code: "file-invalid-type",\\n            message: `File type not allowed. Only .js, .jsx, .ts, .tsx files are accepted.`,\\n          },\\n        ],\\n      });\\n    }\\n  });\\n\\n  return { acceptedFiles, rejectedFiles };\\n}\\n\\nfunction getFileIcon(name: string) {\\n  const extension = name.toLowerCase().split(".").pop();\\n\\n  switch (extension) {\\n    case "ts":\\n      return <IconBrandTypescript size={24} style={{ color: "#3178c6" }} />;\\n    case "tsx":\\n      return <IconBrandReact size={24} style={{ color: "#61dafb" }} />;\\n    case "js":\\n      return <IconBrandJavascript size={24} style={{ color: "#f7df1e" }} />;\\n    case "jsx":\\n      return <IconBrandReact size={24} style={{ color: "#61dafb" }} />;\\n    default:\\n      return <IconFile size={24} />;\\n  }\\n}\\n\\nexport function FileDropzone({\\n  files,\\n  rejectedFiles = [],\\n  onDrop,\\n  onReject,\\n  onDelete,\\n  onDeleteRejected,\\n}: FileDropzoneProps) {\\n  const handleDrop = (droppedFiles: FileWithPath[]) => {\\n    const { acceptedFiles, rejectedFiles } = validateFiles(droppedFiles);\\n\\n    if (acceptedFiles.length > 0) {\\n      onDrop(acceptedFiles);\\n    }\\n\\n    if (rejectedFiles.length > 0) {\\n      onReject(rejectedFiles);\\n    }\\n  };\\n\\n  const handleReject = (rejectedFiles: FileRejection[]) => {\\n    onReject(rejectedFiles);\\n  };\\n\\n  return (\\n    <>\\n      <Dropzone\\n        onDrop={handleDrop}\\n        onReject={handleReject}\\n        maxSize={5 * 1024 ** 2}\\n        accept={{\\n          "application/javascript": [".js", ".jsx"],\\n          "application/typescript": [".ts", ".tsx"],\\n          "text/*": [".js", ".jsx", ".ts", ".tsx"],\\n        }}\\n        multiple\\n        data-qa="dropzone-container"\\n        className={classes.root}\\n      >\\n        <Group\\n          justify="center"\\n          gap="xl"\\n          style={{ minHeight: rem(220), pointerEvents: "none" }}\\n          data-qa="dropzone-content"\\n        >\\n          <Dropzone.Accept>\\n            <IconUpload\\n              data-qa="dropzone-accept-icon"\\n              style={{\\n                width: rem(52),\\n                height: rem(52),\\n                color: "var(--mantine-color-blue-6)",\\n              }}\\n              stroke={1.5}\\n            />\\n          </Dropzone.Accept>\\n          <Dropzone.Reject>\\n            <IconX\\n              data-qa="dropzone-reject-icon"\\n              style={{\\n                width: rem(52),\\n                height: rem(52),\\n                color: "var(--mantine-color-red-6)",\\n              }}\\n              stroke={1.5}\\n            />\\n          </Dropzone.Reject>\\n          <Dropzone.Idle>\\n            <IconFile\\n              data-qa="dropzone-idle-icon"\\n              style={{\\n                width: rem(52),\\n                height: rem(52),\\n                color: "var(--mantine-color-dimmed)",\\n              }}\\n              stroke={1.5}\\n            />\\n          </Dropzone.Idle>\\n\\n          <div data-qa="dropzone-text-content">\\n            <Text size="xl" inline data-qa="dropzone-title">\\n              Drag files here or click to select\\n            </Text>\\n            <Text\\n              size="sm"\\n              c="dimmed"\\n              inline\\n              mt={7}\\n              data-qa="dropzone-file-types"\\n            >\\n              Upload TypeScript (.ts, .tsx) or JavaScript (.js, .jsx) files\\n            </Text>\\n            <Text\\n              size="sm"\\n              c="dimmed"\\n              inline\\n              mt={7}\\n              data-qa="dropzone-size-limit"\\n            >\\n              Files should not exceed 5MB\\n            </Text>\\n          </div>\\n        </Group>\\n      </Dropzone>\\n\\n      {(files.length > 0 || rejectedFiles.length > 0) && (\\n        <Box data-qa="selected-files-section" className="flex flex-col gap-xs">\\n          {files.map((file, index) => (\\n            <Group\\n              key={`accepted-${index}`}\\n              justify="space-between"\\n              align="center"\\n              data-qa={`selected-file-${index}`}\\n            >\\n              <Group gap="xs" align="center">\\n                {getFileIcon(file.name)}\\n                <Text size="sm" c="dimmed">\\n                  {file.name} ({(file.size / 1024).toFixed(1)} KB)\\n                </Text>\\n              </Group>\\n              {onDelete && (\\n                <ActionIcon\\n                  size="sm"\\n                  variant="subtle"\\n                  color="red"\\n                  onClick={() => onDelete(index)}\\n                  data-qa={`delete-file-${index}`}\\n                  aria-label={`Delete ${file.name}`}\\n                >\\n                  <IconX size={16} />\\n                </ActionIcon>\\n              )}\\n            </Group>\\n          ))}\\n\\n          {/* Rejected files */}\\n          {rejectedFiles.map((rejection, index) => (\\n            <Group\\n              key={`rejected-${index}`}\\n              justify="space-between"\\n              align="center"\\n              data-qa={`rejected-file-${index}`}\\n            >\\n              <Group gap="xs" align="center">\\n                <Tooltip\\n                  label={rejection.errors\\n                    .map((error) => error.message)\\n                    .join(", ")}\\n                  withArrow\\n                  position="top"\\n                  data-qa={`error-tooltip-${index}`}\\n                >\\n                  <IconAlertCircle\\n                    size={24}\\n                    style={{ color: "var(--mantine-color-red-6)" }}\\n                  />\\n                </Tooltip>\\n                <Text size="sm" c="red.6">\\n                  {rejection.file.name} (\\n                  {(rejection.file.size / 1024).toFixed(1)} KB)\\n                </Text>\\n              </Group>\\n              {onDeleteRejected && (\\n                <ActionIcon\\n                  size="sm"\\n                  variant="subtle"\\n                  color="red"\\n                  onClick={() => onDeleteRejected(index)}\\n                  data-qa={`delete-rejected-file-${index}`}\\n                  aria-label={`Delete ${rejection.file.name}`}\\n                >\\n                  <IconX size={16} />\\n                </ActionIcon>\\n              )}\\n            </Group>\\n          ))}\\n        </Box>\\n      )}\\n    </>\\n  );\\n}\\n\',\n  },\n  {\n    name: "use-dropzone.tsx",\n    text: \'import { useState } from "react";\\nimport { type FileWithPath, type FileRejection } from "@mantine/dropzone";\\n\\nexport function useDropzone() {\\n  const [files, setFiles] = useState<FileWithPath[]>([]);\\n  const [rejectedFiles, setRejectedFiles] = useState<FileRejection[]>([]);\\n\\n  const handleDrop = (droppedFiles: FileWithPath[]) => {\\n    setFiles((prevFiles) => [...prevFiles, ...droppedFiles]);\\n    console.log("Files dropped:", droppedFiles);\\n  };\\n\\n  const handleReject = (rejectedFiles: FileRejection[]) => {\\n    setRejectedFiles((prevRejected) => [...prevRejected, ...rejectedFiles]);\\n    console.log("Files rejected:", rejectedFiles);\\n  };\\n\\n  const handleDelete = (index: number) => {\\n    setFiles((currentFiles) => {\\n      const newFiles = [...currentFiles];\\n      newFiles.splice(index, 1);\\n      return newFiles;\\n    });\\n    console.log("File deleted at index:", index);\\n  };\\n\\n  const handleUpdate = (files: FileWithPath[]) => {\\n    setFiles(files);\\n    console.log("Files updated:", files);\\n  };\\n\\n  const handleDeleteRejected = (index: number) => {\\n    setRejectedFiles((currentRejected) => {\\n      const newRejected = [...currentRejected];\\n      newRejected.splice(index, 1);\\n      return newRejected;\\n    });\\n    console.log("Rejected file deleted at index:", index);\\n  };\\n\\n  return {\\n    files,\\n    rejectedFiles,\\n    handleDrop,\\n    handleReject,\\n    handleDelete,\\n    handleDeleteRejected,\\n    handleUpdate,\\n  };\\n}\\n\',\n  },\n];\n\nexport const FILES_TO_TEXT_AS_FILES = FILES_TO_TEXT.map(\n  (file) => new File([file.text], file.name, { type: "text/plain" })\n);\n\nexport const MOCK_SELECTED_FILES = [\n  {\n    path: "ui/src/routes/(generate-tests)/generate-tests.tsx",\n    name: "generate-tests.tsx",\n    content:\n      \'import { createFileRoute } from "@tanstack/react-router";\\nimport { useState } from "react";\\nimport { Container, Paper, Center, Box, Stepper } from "@mantine/core";\\nimport { useDependencies } from "src/hooks/use-dependencies";\\nimport { useRepoConnection } from "src/hooks/use-repo-connection";\\nimport { StepperNavigationButtons } from "src/components/stepper-navigation-buttons";\\nimport { StepOneUploadFiles } from "src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files";\\nimport { StepTwoDescribeRelations } from "src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations";\\nimport { StepThreeViewResults } from "src/routes/(generate-tests)/-components/step-three-view-results/step-three-view-results";\\nimport { useFileTree } from "./-components/step-one-upload-files/use-file-tree";\\n\\n// Interface to make SelectedRepoFile compatible with FileWithPath\\ninterface FileCompatible {\\n  path: string;\\n  name: string;\\n  size: number;\\n  text: string;\\n}\\n\\nexport const Route = createFileRoute("/(generate-tests)/generate-tests")({\\n  component: Index,\\n});\\n\\nfunction Index() {\\n  const [currentStep, setCurrentStep] = useState(0);\\n\\n  const [repoUrl, setRepoUrl] = useState(\\n    "https://github.com/piotrnajda3000/handoff.git"\\n  );\\n  const [accessToken, setAccessToken] = useState(\\n    "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"\\n  );\\n\\n  // Repository connection hook - manages selected files internally\\n  const repoConnectionData = useRepoConnection();\\n  const { selectedFiles } = repoConnectionData;\\n\\n  // Convert SelectedRepoFile to FileWithPath for existing dependencies hook\\n  const fileCompatibleFiles: FileCompatible[] = selectedFiles.map((file) => ({\\n    path: file.path,\\n    name: file.name,\\n    size: file.size,\\n    text: file.content, // Add content for compatibility\\n  }));\\n\\n  // File Tree Management Hook\\n  const { fileTree, expandedDirectories, toggleDirectoryExpansion } =\\n    useFileTree({\\n      repoFiles: repoConnectionData.repoFiles,\\n      selectedFiles,\\n    });\\n\\n  // Feature Name State\\n  const [featureName, setFeatureName] = useState("");\\n\\n  const dependenciesData = useDependencies(fileCompatibleFiles);\\n\\n  const stepTitles = ["Connect Repository", "Generate Tests", "Review Results"];\\n  const totalSteps = stepTitles.length;\\n\\n  const canProceedToNext = currentStep === 0 ? selectedFiles.length > 0 : true;\\n\\n  const getNextButtonTooltip = () => {\\n    if (currentStep === 0) {\\n      if (selectedFiles.length === 0) {\\n        return "Please select files from your repository to continue";\\n      }\\n    }\\n    if (currentStep === totalSteps - 1) {\\n      return "Complete the process";\\n    }\\n    return "";\\n  };\\n\\n  const handleNext = () => {\\n    if (currentStep < totalSteps - 1) {\\n      setCurrentStep(currentStep + 1);\\n    }\\n  };\\n\\n  const handlePrevious = () => {\\n    if (currentStep > 0) {\\n      setCurrentStep(currentStep - 1);\\n    }\\n  };\\n\\n  const renderStepContent = () => {\\n    switch (currentStep) {\\n      case 0:\\n        return (\\n          <StepOneUploadFiles\\n            repoConnectionData={repoConnectionData}\\n            repoUrl={repoUrl}\\n            setRepoUrl={setRepoUrl}\\n            accessToken={accessToken}\\n            setAccessToken={setAccessToken}\\n            fileTree={fileTree}\\n            expandedDirectories={expandedDirectories}\\n            featureName={featureName}\\n            setFeatureName={setFeatureName}\\n            toggleDirectoryExpansion={toggleDirectoryExpansion}\\n          />\\n        );\\n      case 1:\\n        return (\\n          <StepTwoDescribeRelations\\n            files={fileCompatibleFiles}\\n            dependenciesData={dependenciesData}\\n          />\\n        );\\n      case 2:\\n        return <StepThreeViewResults />;\\n      default:\\n        return null;\\n    }\\n  };\\n\\n  return (\\n    <Container size="md" className="h-full flex flex-col">\\n      <Center className="my-auto">\\n        <Paper className="w-full max-w-[700px] h-full shadow-lg rounded-md p-xl">\\n          <div className="flex flex-col">\\n            {/* Step Progress Indicator */}\\n            <Box>\\n              <Stepper active={currentStep} size="sm">\\n                {stepTitles.map((title, index) => (\\n                  <Stepper.Step key={index} label={title} data-qa={`step`} />\\n                ))}\\n              </Stepper>\\n            </Box>\\n\\n            {/* Step Content */}\\n            <div className="mt-xl">{renderStepContent()}</div>\\n\\n            {/* Navigation */}\\n            <div className="mt-xl">\\n              <StepperNavigationButtons\\n                currentStep={currentStep}\\n                totalSteps={totalSteps}\\n                onNext={handleNext}\\n                onPrevious={handlePrevious}\\n                canProceedToNext={canProceedToNext}\\n                nextButtonTooltip={getNextButtonTooltip()}\\n              />\\n            </div>\\n          </div>\\n        </Paper>\\n      </Center>\\n    </Container>\\n  );\\n}\\n\',\n    size: 4902,\n    dependents: [],\n  },\n  {\n    path: "ui/src/hooks/use-dependencies.tsx",\n    name: "use-dependencies.tsx",\n    content:\n      \'import { useState } from "react";\\nimport type { Edge } from "../routes/(generate-tests)/-components/interactive-canvas/interactive-canvas";\\n\\nexport interface Dependency {\\n  id: string;\\n  from: string;\\n  to: string;\\n  connection: string;\\n}\\n\\n// Make the hook more flexible to accept file-like objects\\ninterface FileWithPathOrContent {\\n  path?: string;\\n  name: string;\\n  size?: number;\\n}\\n\\nexport function useDependencies(files: FileWithPathOrContent[]) {\\n  const [dependencies, setDependencies] = useState<Dependency[]>([]);\\n\\n  // Generate file options for select dropdowns\\n  const fileOptions = files.map((file) => ({\\n    value: file.path || file.name,\\n    label: file.path || file.name,\\n  }));\\n\\n  const connectionOptions = [\\n    { value: "uses", label: "uses" },\\n    { value: "tests", label: "tests" },\\n    { value: "describes", label: "describes" },\\n  ];\\n\\n  const addDependency = () => {\\n    const newDependency: Dependency = {\\n      id: crypto.randomUUID(),\\n      from: "",\\n      to: "",\\n      connection: "uses",\\n    };\\n    setDependencies([...dependencies, newDependency]);\\n  };\\n\\n  const updateDependency = (\\n    id: string,\\n    field: keyof Dependency,\\n    value: string\\n  ) => {\\n    setDependencies(\\n      dependencies.map((dep) =>\\n        dep.id === id ? { ...dep, [field]: value } : dep\\n      )\\n    );\\n  };\\n\\n  const removeDependency = (id: string) => {\\n    setDependencies(dependencies.filter((dep) => dep.id !== id));\\n  };\\n\\n  // Convert dependencies to edges for the canvas\\n  const convertDependenciesToEdges = (): Edge[] => {\\n    // Create mapping from file path/name to node ID\\n    const fileToNodeIdMap = new Map<string, string>();\\n    files.forEach((file, index) => {\\n      const fileIdentifier = file.path || file.name;\\n      fileToNodeIdMap.set(fileIdentifier, `file-${index}`);\\n    });\\n\\n    // Convert dependencies to edges\\n    return dependencies\\n      .filter((dep) => {\\n        // Only include dependencies where both from and to files exist\\n        return fileToNodeIdMap.has(dep.from) && fileToNodeIdMap.has(dep.to);\\n      })\\n      .map((dep) => ({\\n        id: dep.id,\\n        from: fileToNodeIdMap.get(dep.from)!,\\n        to: fileToNodeIdMap.get(dep.to)!,\\n        description: dep.connection,\\n      }));\\n  };\\n\\n  const edges = convertDependenciesToEdges();\\n\\n  const generateDependencies = () => {\\n    // For now, this is a placeholder. In a real implementation, this could:\\n    // - Use AI to analyze files and suggest dependencies\\n    // - Parse imports/exports to find relationships\\n    // - Add some basic dependencies based on file structure\\n    console.log("Generate dependencies functionality to be implemented");\\n  };\\n\\n  return {\\n    dependencies,\\n    fileOptions,\\n    connectionOptions,\\n    edges,\\n    addDependency,\\n    updateDependency,\\n    removeDependency,\\n    generateDependencies,\\n  };\\n}\\n\',\n    size: 2822,\n    dependents: [\n      {\n        name: "generate-tests.tsx",\n        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/hooks/use-repo-connection.ts",\n    name: "use-repo-connection.ts",\n    content:\n      \'import { useState, useCallback } from "react";\\nimport {\\n  type RepoConnection,\\n  type RepoFile,\\n  type SelectedRepoFile,\\n} from "../types/repo";\\nimport { apiPost } from "../utils/api";\\nimport { getImportedFilesToSelect } from "../utils/import-parser.utils";\\n\\nexport interface UseRepoConnectionReturn {\\n  // Connection state\\n  connection: RepoConnection | null;\\n  isConnected: boolean;\\n  isConnecting: boolean;\\n  connectionError: string | null;\\n\\n  // File listing state\\n  repoFiles: RepoFile[];\\n  isLoadingFiles: boolean;\\n  fileLoadError: string | null;\\n\\n  // Selected files state\\n  selectedFiles: SelectedRepoFile[];\\n\\n  // File content loading state\\n  loadingFiles: Set<string>;\\n\\n  // Actions\\n  connectToRepo: (repoUrl: string, token: string) => Promise<void>;\\n  disconnect: () => void;\\n  loadRepoFiles: () => Promise<void>;\\n  toggleFileSelection: (\\n    file: RepoFile,\\n    autoSelectImports?: boolean\\n  ) => Promise<void>;\\n  autoSelectImportedFiles: (file: SelectedRepoFile) => Promise<void>;\\n  clearSelectedFiles: () => void;\\n}\\n\\nexport function useRepoConnection(): UseRepoConnectionReturn {\\n  const [connection, setConnection] = useState<RepoConnection | null>(null);\\n  const [isConnecting, setIsConnecting] = useState(false);\\n  const [connectionError, setConnectionError] = useState<string | null>(null);\\n\\n  const [repoFiles, setRepoFiles] = useState<RepoFile[]>([]);\\n  const [isLoadingFiles, setIsLoadingFiles] = useState(false);\\n  const [fileLoadError, setFileLoadError] = useState<string | null>(null);\\n\\n  const [selectedFiles, setSelectedFiles] = useState<SelectedRepoFile[]>([]);\\n  const [loadingFiles, setLoadingFiles] = useState<Set<string>>(new Set());\\n\\n  const parseRepoUrl = (url: string) => {\\n    // Support both HTTPS and SSH GitHub URLs\\n    const githubHttpsMatch = url.match(\\n      /https:\\\\/\\\\/github\\\\.com\\\\/([^\\\\/]+)\\\\/([^\\\\/]+)(?:\\\\.git)?/\\n    );\\n    const githubSshMatch = url.match(\\n      /git@github\\\\.com:([^\\\\/]+)\\\\/([^\\\\/]+)(?:\\\\.git)?/\\n    );\\n\\n    if (githubHttpsMatch) {\\n      return {\\n        provider: "github" as const,\\n        owner: githubHttpsMatch[1],\\n        repo: githubHttpsMatch[2].replace(".git", ""),\\n      };\\n    }\\n\\n    if (githubSshMatch) {\\n      return {\\n        provider: "github" as const,\\n        owner: githubSshMatch[1],\\n        repo: githubSshMatch[2].replace(".git", ""),\\n      };\\n    }\\n\\n    throw new Error(\\n      "Unsupported repository URL format. Please use a GitHub HTTPS or SSH URL."\\n    );\\n  };\\n\\n  const connectToRepo = useCallback(async (repoUrl: string, token: string) => {\\n    setIsConnecting(true);\\n    setConnectionError(null);\\n\\n    try {\\n      const { provider, owner, repo } = parseRepoUrl(repoUrl);\\n\\n      // Test the connection by making a simple API call\\n      await apiPost({\\n        endpoint: "/repo/test-connection",\\n        body: { provider, owner, repo, token },\\n      });\\n\\n      const newConnection: RepoConnection = {\\n        provider,\\n        url: repoUrl,\\n        token,\\n        owner,\\n        repo,\\n      };\\n\\n      setConnection(newConnection);\\n      console.log("Successfully connected to repository:", { owner, repo });\\n    } catch (error) {\\n      const errorMessage =\\n        error instanceof Error\\n          ? error.message\\n          : "Failed to connect to repository";\\n      setConnectionError(errorMessage);\\n      console.error("Repository connection failed:", error);\\n    } finally {\\n      setIsConnecting(false);\\n    }\\n  }, []);\\n\\n  const disconnect = useCallback(() => {\\n    setConnection(null);\\n    setRepoFiles([]);\\n    setSelectedFiles([]);\\n    setLoadingFiles(new Set());\\n    setConnectionError(null);\\n    setFileLoadError(null);\\n  }, []);\\n\\n  const loadRepoFiles = useCallback(async () => {\\n    if (!connection) return;\\n\\n    setIsLoadingFiles(true);\\n    setFileLoadError(null);\\n\\n    try {\\n      const response = await apiPost<typeof connection, RepoFile[]>({\\n        endpoint: "/repo/list-files",\\n        body: connection,\\n      });\\n\\n      // Filter to only show supported file types\\n      const supportedExtensions = [".js", ".jsx", ".ts", ".tsx"];\\n      const filteredFiles = response.filter(\\n        (file) =>\\n          file.type === "file" &&\\n          supportedExtensions.some((ext) =>\\n            file.path.toLowerCase().endsWith(ext)\\n          )\\n      );\\n\\n      setRepoFiles(filteredFiles);\\n      console.log("Loaded repository files:", filteredFiles.length);\\n    } catch (error) {\\n      const errorMessage =\\n        error instanceof Error\\n          ? error.message\\n          : "Failed to load repository files";\\n      setFileLoadError(errorMessage);\\n      console.error("Failed to load repository files:", error);\\n    } finally {\\n      setIsLoadingFiles(false);\\n    }\\n  }, [connection]);\\n\\n  const selectFileWithoutAutoImports = useCallback(\\n    async (file: RepoFile) => {\\n      if (!connection) return null;\\n\\n      // Set loading state for this file\\n      setLoadingFiles((prev) => new Set([...prev, file.path]));\\n\\n      try {\\n        const response = await apiPost<\\n          { connection: RepoConnection; filePath: string },\\n          { content: string }\\n        >({\\n          endpoint: "/repo/get-file-content",\\n          body: { connection, filePath: file.path },\\n        });\\n\\n        const selectedFile: SelectedRepoFile = {\\n          path: file.path,\\n          name: file.name,\\n          content: response.content,\\n          size: file.size || 0,\\n        };\\n\\n        setSelectedFiles((prev) => [...prev, selectedFile]);\\n        console.log("Added file to selection:", file.path);\\n        return selectedFile;\\n      } catch (error) {\\n        console.error("Failed to fetch file content:", error);\\n        return null;\\n      } finally {\\n        // Remove loading state for this file\\n        setLoadingFiles((prev) => {\\n          const newSet = new Set(prev);\\n          newSet.delete(file.path);\\n          return newSet;\\n        });\\n      }\\n    },\\n    [connection]\\n  );\\n\\n  const autoSelectImportedFiles = useCallback(\\n    async (file: SelectedRepoFile) => {\\n      if (!connection) return;\\n\\n      try {\\n        // Get imported files that should be auto-selected\\n        const importedFiles = getImportedFilesToSelect(\\n          file.content,\\n          file.path,\\n          repoFiles\\n        );\\n\\n        console.log({\\n          content: file.content,\\n          path: file.path,\\n          repoFiles: repoFiles,\\n        });\\n\\n        console.log(\\n          `Found ${importedFiles.length} imported files for ${file.path}:`,\\n          importedFiles.map((f) => f.path)\\n        );\\n\\n        // Filter out files that are already selected\\n        const filesToSelect = importedFiles.filter(\\n          (importedFile) =>\\n            !selectedFiles.some(\\n              (selected) => selected.path === importedFile.path\\n            )\\n        );\\n\\n        if (filesToSelect.length === 0) {\\n          console.log("No new imported files to select");\\n          return;\\n        }\\n\\n        console.log(`Auto-selecting ${filesToSelect.length} imported files...`);\\n\\n        // Select each imported file (without triggering auto-select recursively)\\n        for (const importedFile of filesToSelect) {\\n          await selectFileWithoutAutoImports(importedFile);\\n        }\\n      } catch (error) {\\n        console.error("Failed to auto-select imported files:", error);\\n      }\\n    },\\n    [connection, repoFiles, selectedFiles, selectFileWithoutAutoImports]\\n  );\\n\\n  const toggleFileSelection = useCallback(\\n    async (file: RepoFile, autoSelectImports = true) => {\\n      if (!connection) return;\\n\\n      const isSelected = selectedFiles.some((f) => f.path === file.path);\\n\\n      if (isSelected) {\\n        // Remove from selection\\n        setSelectedFiles((prev) => prev.filter((f) => f.path !== file.path));\\n      } else {\\n        // Add to selection - need to fetch file content\\n        const selectedFile = await selectFileWithoutAutoImports(file);\\n\\n        // Auto-select imported files if requested and file was successfully selected\\n        if (autoSelectImports && selectedFile) {\\n          // Use a small delay to ensure state has updated\\n          setTimeout(() => {\\n            autoSelectImportedFiles(selectedFile);\\n          }, 100);\\n        }\\n      }\\n    },\\n    [\\n      connection,\\n      selectedFiles,\\n      selectFileWithoutAutoImports,\\n      autoSelectImportedFiles,\\n    ]\\n  );\\n\\n  const clearSelectedFiles = useCallback(() => {\\n    setSelectedFiles([]);\\n  }, []);\\n\\n  return {\\n    // Connection state\\n    connection,\\n    isConnected: !!connection,\\n    isConnecting,\\n    connectionError,\\n\\n    // File listing state\\n    repoFiles,\\n    isLoadingFiles,\\n    fileLoadError,\\n\\n    // Selected files state\\n    selectedFiles,\\n\\n    // File content loading state\\n    loadingFiles,\\n\\n    // Actions\\n    connectToRepo,\\n    disconnect,\\n    loadRepoFiles,\\n    toggleFileSelection,\\n    autoSelectImportedFiles,\\n    clearSelectedFiles,\\n  };\\n}\\n\',\n    size: 8799,\n    dependents: [\n      {\n        name: "generate-tests.tsx",\n        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/components/stepper-navigation-buttons/index.ts",\n    name: "index.ts",\n    content:\n      \'export { StepperNavigationButtons } from "./stepper-navigation-buttons";\\n\',\n    size: 73,\n    dependents: [\n      {\n        name: "generate-tests.tsx",\n        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",\n    name: "step-one-upload-files.tsx",\n    content:\n      \'// # 7. Main Step One Upload Files Component\\n// Orchestrates the file upload and selection process with repository connection\\n\\nimport { Title, Text } from "@mantine/core";\\nimport { useCallback } from "react";\\nimport { type UseRepoConnectionReturn } from "src/hooks/use-repo-connection";\\n\\n// # 7.1 Extracted Component Imports\\nimport { ConnectionForm } from "src/routes/(generate-tests)/-components/step-one-upload-files/connection-form";\\nimport { RepositoryHeader } from "src/routes/(generate-tests)/-components/step-one-upload-files/repository-header";\\nimport { FileTreeDisplay } from "src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display";\\nimport type { TreeNode } from "./tree-item";\\n\\n// # 7.2 Component Props Interface\\ninterface StepOneUploadFilesProps {\\n  repoConnectionData: UseRepoConnectionReturn;\\n  repoUrl: string;\\n  setRepoUrl: (repoUrl: string) => void;\\n  accessToken: string;\\n  setAccessToken: (accessToken: string) => void;\\n  fileTree: TreeNode[];\\n  expandedDirectories: Set<string>;\\n  featureName: string;\\n  setFeatureName: (featureName: string) => void;\\n  toggleDirectoryExpansion: (path: string) => void;\\n}\\n\\n// # 7.3 Main Component Implementation\\n// Orchestrates the complete file upload and selection workflow\\nexport function StepOneUploadFiles({\\n  repoConnectionData,\\n  repoUrl,\\n  setRepoUrl,\\n  accessToken,\\n  setAccessToken,\\n  fileTree,\\n  expandedDirectories,\\n  featureName,\\n  setFeatureName,\\n  toggleDirectoryExpansion,\\n}: StepOneUploadFilesProps) {\\n  // # 7.3.2 Repository Connection Data\\n  const {\\n    connection,\\n    isConnected,\\n    isConnecting,\\n    connectionError,\\n    repoFiles,\\n    isLoadingFiles,\\n    fileLoadError,\\n    selectedFiles,\\n    loadingFiles,\\n    connectToRepo,\\n    disconnect,\\n    loadRepoFiles,\\n    toggleFileSelection,\\n  } = repoConnectionData;\\n\\n  // # 7.3.5 Event Handlers (Memoized to prevent unnecessary re-renders)\\n\\n  // # 7.3.5.1 Connection Handlers\\n  const handleConnect = useCallback(async () => {\\n    if (!repoUrl.trim() || !accessToken.trim()) {\\n      return;\\n    }\\n    await connectToRepo(repoUrl.trim(), accessToken.trim());\\n  }, [repoUrl, accessToken, connectToRepo]);\\n\\n  const handleDisconnect = useCallback(() => {\\n    disconnect();\\n    setRepoUrl("");\\n    setAccessToken("");\\n  }, [disconnect, setRepoUrl, setAccessToken]);\\n\\n  // # 7.3.5.2 File Management Handlers\\n  const handleLoadFiles = useCallback(() => {\\n    loadRepoFiles();\\n  }, [loadRepoFiles]);\\n\\n  // # 7.3.5.3 Feature Name Handler\\n  const handleFeatureNameChange = useCallback((value: string) => {\\n    setFeatureName(value);\\n  }, []);\\n\\n  // # 7.3.6 Conditional Rendering\\n\\n  // # 7.3.6.1 Connection Form State\\n  if (!isConnected) {\\n    return (\\n      <ConnectionForm\\n        repoUrl={repoUrl}\\n        accessToken={accessToken}\\n        isConnecting={isConnecting}\\n        connectionError={connectionError}\\n        onRepoUrlChange={setRepoUrl}\\n        onAccessTokenChange={setAccessToken}\\n        onConnect={handleConnect}\\n      />\\n    );\\n  }\\n\\n  // # 7.3.6.2 Connected State\\n  return (\\n    <div className="gap-lg">\\n      {/* # 7.3.6.2.1 Page Header */}\\n      <div className="text-center">\\n        <Title order={1} size="h2" className="mb-md">\\n          Repository Connected\\n        </Title>\\n        <Text size="lg" className="text-gray-600">\\n          Select the files you want to analyze from {connection?.owner}/\\n          {connection?.repo}\\n        </Text>\\n      </div>\\n\\n      {/* # 7.3.6.2.2 Repository Management */}\\n      <RepositoryHeader\\n        connection={connection}\\n        isLoadingFiles={isLoadingFiles}\\n        onRefresh={handleLoadFiles}\\n        onDisconnect={handleDisconnect}\\n      />\\n\\n      {/* # 7.3.6.2.3 File Tree Display */}\\n      <FileTreeDisplay\\n        repoFiles={repoFiles}\\n        selectedFiles={selectedFiles}\\n        fileTree={fileTree}\\n        isLoadingFiles={isLoadingFiles}\\n        fileLoadError={fileLoadError}\\n        loadingFiles={loadingFiles}\\n        expandedDirectories={expandedDirectories}\\n        featureName={featureName}\\n        onLoadFiles={handleLoadFiles}\\n        onToggleExpanded={toggleDirectoryExpansion}\\n        onToggleSelection={toggleFileSelection}\\n        onFeatureNameChange={handleFeatureNameChange}\\n      />\\n    </div>\\n  );\\n}\\n\',\n    size: 4227,\n    dependents: [\n      {\n        name: "generate-tests.tsx",\n        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/connection-form.tsx",\n    name: "connection-form.tsx",\n    content:\n      \'// # 4. Repository Connection Form Component\\n// Handles GitHub repository authentication and connection\\n\\nimport {\\n  Stack,\\n  Box,\\n  Title,\\n  Text,\\n  TextInput,\\n  PasswordInput,\\n  Button,\\n  Alert,\\n  Paper,\\n  Group,\\n} from "@mantine/core";\\nimport { IconBrandGithub, IconAlertCircle } from "@tabler/icons-react";\\n\\n// # 4.1 Component Props Interface\\ninterface ConnectionFormProps {\\n  repoUrl: string;\\n  accessToken: string;\\n  isConnecting: boolean;\\n  connectionError: string | null;\\n  onRepoUrlChange: (url: string) => void;\\n  onAccessTokenChange: (token: string) => void;\\n  onConnect: () => void;\\n}\\n\\n// # 4.2 Main Connection Form Component\\n// Provides UI for GitHub repository connection with validation and error handling\\nexport function ConnectionForm({\\n  repoUrl,\\n  accessToken,\\n  isConnecting,\\n  connectionError,\\n  onRepoUrlChange,\\n  onAccessTokenChange,\\n  onConnect,\\n}: ConnectionFormProps) {\\n  // # 4.2.1 Form Validation\\n  const isFormValid = repoUrl.trim() && accessToken.trim();\\n\\n  return (\\n    <Stack className="gap-lg">\\n      {/* # 4.2.2 Header Section */}\\n      <Box className="text-center">\\n        <Title order={1} size="h2" className="mb-md">\\n          Welcome to Handoff\\n        </Title>\\n        <Text className="text-gray-600">\\n          Connect your repository to generate natural language test cases\\n        </Text>\\n      </Box>\\n\\n      {/* # 4.2.3 Connection Form */}\\n      <Paper className="border-gray-200 rounded-md p-xl">\\n        <Stack className="gap-md">\\n          {/* # 4.2.3.1 Form Header */}\\n          <Group className="gap-xs">\\n            <IconBrandGithub size={24} />\\n            <Title order={3} size="h4">\\n              Connect Your Repository\\n            </Title>\\n          </Group>\\n\\n          {/* # 4.2.3.2 Form Description */}\\n          <Text size="sm" className="text-gray-600">\\n            Connect to your GitHub repository (including private repos) to\\n            select and analyze your code files.\\n          </Text>\\n\\n          {/* # 4.2.3.3 Repository URL Input */}\\n          <TextInput\\n            label="Repository URL"\\n            placeholder="https://github.com/username/repository or git@github.com:username/repository.git"\\n            value={repoUrl}\\n            onChange={(e) => onRepoUrlChange(e.currentTarget.value)}\\n            required\\n          />\\n\\n          {/* # 4.2.3.4 Access Token Input */}\\n          <PasswordInput\\n            label="Personal Access Token"\\n            placeholder="Your GitHub personal access token"\\n            description="Create a token at https://github.com/settings/tokens with \\\'repo\\\' scope for private repositories"\\n            value={accessToken}\\n            onChange={(e) => onAccessTokenChange(e.currentTarget.value)}\\n            required\\n          />\\n\\n          {/* # 4.2.3.5 Error Display */}\\n          {connectionError && (\\n            <Alert\\n              icon={<IconAlertCircle size="1rem" />}\\n              title="Connection Error"\\n              color="red"\\n            >\\n              {connectionError}\\n            </Alert>\\n          )}\\n\\n          {/* # 4.2.3.6 Connect Button */}\\n          <Button\\n            onClick={onConnect}\\n            loading={isConnecting}\\n            disabled={!isFormValid}\\n            leftSection={<IconBrandGithub size="1rem" />}\\n          >\\n            {isConnecting ? "Connecting..." : "Connect Repository"}\\n          </Button>\\n        </Stack>\\n      </Paper>\\n    </Stack>\\n  );\\n}\\n\',\n    size: 3400,\n    dependents: [\n      {\n        name: "step-one-upload-files.tsx",\n        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/repository-header.tsx",\n    name: "repository-header.tsx",\n    content:\n      \'// # 5. Repository Header Component\\n// Displays connection status and provides repository management controls\\n\\nimport { Paper, Group, Text, Button, ActionIcon, Tooltip } from "@mantine/core";\\nimport { IconCheck, IconX, IconRefresh } from "@tabler/icons-react";\\nimport type { RepoConnection } from "src/types/repo";\\n\\n// # 5.1 Component Props Interface\\ninterface RepositoryHeaderProps {\\n  connection: RepoConnection | null;\\n  isLoadingFiles: boolean;\\n  onRefresh: () => void;\\n  onDisconnect: () => void;\\n}\\n\\n// # 5.2 Main Repository Header Component\\n// Shows connected repository info and provides tree management controls\\nexport function RepositoryHeader({\\n  connection,\\n  isLoadingFiles,\\n  onRefresh,\\n  onDisconnect,\\n}: RepositoryHeaderProps) {\\n  return (\\n    <Paper className="border-gray-200 rounded-md p-md">\\n      <Group className="justify-between">\\n        {/* # 5.2.1 Connection Status */}\\n        <Group className="gap-xs">\\n          <IconCheck size="1rem" color="green" />\\n          <Text size="sm" className="font-medium">\\n            Connected to {connection?.owner}/{connection?.repo}\\n          </Text>\\n        </Group>\\n\\n        {/* # 5.2.2 Action Controls */}\\n        <Group className="gap-xs">\\n          {/* # 5.2.2.2 Refresh Control */}\\n          <Tooltip label="Refresh file list">\\n            <ActionIcon\\n              variant="light"\\n              onClick={onRefresh}\\n              loading={isLoadingFiles}\\n            >\\n              <IconRefresh size="1rem" />\\n            </ActionIcon>\\n          </Tooltip>\\n\\n          {/* # 5.2.2.3 Disconnect Control */}\\n          <Button\\n            size="xs"\\n            variant="subtle"\\n            color="red"\\n            onClick={onDisconnect}\\n            leftSection={<IconX size="1rem" />}\\n          >\\n            Disconnect\\n          </Button>\\n        </Group>\\n      </Group>\\n    </Paper>\\n  );\\n}\\n\',\n    size: 1857,\n    dependents: [\n      {\n        name: "step-one-upload-files.tsx",\n        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/types/repo.ts",\n    name: "repo.ts",\n    content:\n      \'// Repository connection types\\nexport interface RepoConnection {\\n  provider: "github" | "gitlab" | "bitbucket";\\n  url: string;\\n  token: string;\\n  owner: string;\\n  repo: string;\\n}\\n\\nexport interface RepoFile {\\n  path: string;\\n  name: string;\\n  type: "file" | "dir";\\n  size?: number;\\n  content?: string;\\n  sha?: string;\\n}\\n\\nexport interface RepoFileTree {\\n  path: string;\\n  mode: string;\\n  type: "blob" | "tree";\\n  sha: string;\\n  size?: number;\\n  url: string;\\n}\\n\\nexport interface SelectedRepoFile {\\n  path: string;\\n  name: string;\\n  content: string;\\n  size: number;\\n}\\n\\n// API Response types\\nexport interface GitHubContent {\\n  name: string;\\n  path: string;\\n  sha: string;\\n  size: number;\\n  url: string;\\n  html_url: string;\\n  git_url: string;\\n  download_url: string;\\n  type: "file" | "dir";\\n  content?: string;\\n  encoding?: string;\\n}\\n\\nexport interface GitHubTreeResponse {\\n  sha: string;\\n  url: string;\\n  tree: RepoFileTree[];\\n  truncated: boolean;\\n}\\n\',\n    size: 945,\n    dependents: [\n      {\n        name: "repository-header.tsx",\n        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/repository-header.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display.tsx",\n    name: "file-tree-display.tsx",\n    content:\n      \'// # 6. File Tree Display Component\\n// Handles the display of file tree structure with loading and error states\\n\\nimport React, { useMemo } from "react";\\nimport { Box, Text, Loader, Alert, Button, TextInput } from "@mantine/core";\\nimport { IconAlertCircle } from "@tabler/icons-react";\\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\\nimport { TreeItem, type TreeNode } from "./tree-item";\\n\\n// # 6.1 Component Props Interface\\ninterface FileTreeDisplayProps {\\n  repoFiles: RepoFile[];\\n  selectedFiles: SelectedRepoFile[];\\n  fileTree: TreeNode[];\\n  isLoadingFiles: boolean;\\n  fileLoadError: string | null;\\n  loadingFiles: Set<string>;\\n  expandedDirectories: Set<string>;\\n  featureName: string;\\n  onLoadFiles: () => void;\\n  onToggleExpanded: (path: string) => void;\\n  onToggleSelection: (file: RepoFile) => void;\\n  onFeatureNameChange: (value: string) => void;\\n}\\n\\n// # 6.2 Main File Tree Display Component\\n// Manages different display states and renders the tree structure\\nexport const FileTreeDisplay = React.memo(function FileTreeDisplay({\\n  repoFiles,\\n  selectedFiles,\\n  fileTree,\\n  isLoadingFiles,\\n  fileLoadError,\\n  loadingFiles,\\n  expandedDirectories,\\n  featureName,\\n  onLoadFiles,\\n  onToggleExpanded,\\n  onToggleSelection,\\n  onFeatureNameChange,\\n}: FileTreeDisplayProps) {\\n  // # 6.2.1 Render Tree Function\\n  // Creates TreeItem components for each root node (memoized to prevent recreation)\\n  const renderedTree = useMemo(() => {\\n    return fileTree.map((node) => (\\n      <TreeItem\\n        key={node.path}\\n        node={node}\\n        expandedDirectories={expandedDirectories}\\n        selectedFiles={selectedFiles}\\n        loadingFiles={loadingFiles}\\n        onToggleExpanded={onToggleExpanded}\\n        onToggleSelection={onToggleSelection}\\n      />\\n    ));\\n  }, [\\n    fileTree,\\n    expandedDirectories,\\n    selectedFiles,\\n    loadingFiles,\\n    onToggleExpanded,\\n    onToggleSelection,\\n  ]);\\n\\n  return (\\n    <>\\n      {/* # 6.2.2 Empty State - No Files Loaded */}\\n      {!repoFiles.length && !isLoadingFiles && !fileLoadError && (\\n        <Box className="my-xl text-center">\\n          <Text className="text-gray-600 mb-md" size="sm">\\n            Click "Load Files" to browse your repository files\\n          </Text>\\n          <Button onClick={onLoadFiles} variant="light">\\n            Load Files\\n          </Button>\\n        </Box>\\n      )}\\n\\n      {/* # 6.2.3 Loading State */}\\n      {isLoadingFiles && (\\n        <Box className="my-xl text-center">\\n          <Loader size="sm" className="mb-md" />\\n          <Text size="sm" className="text-gray-600">\\n            Loading repository files...\\n          </Text>\\n        </Box>\\n      )}\\n\\n      {/* # 6.2.4 Error State */}\\n      {fileLoadError && (\\n        <Alert\\n          icon={<IconAlertCircle size="1rem" />}\\n          title="Error Loading Files"\\n          color="red"\\n          className="mb-md"\\n        >\\n          {fileLoadError}\\n        </Alert>\\n      )}\\n\\n      {/* # 6.2.5 Files Display */}\\n      {repoFiles.length > 0 && (\\n        <div>\\n          {/* # 6.2.5.0 Feature Name Input */}\\n          <TextInput\\n            label="Feature Name"\\n            description="The feature you are doing the handoff for"\\n            value={featureName}\\n            onChange={(event) => onFeatureNameChange(event.currentTarget.value)}\\n            placeholder="Enter feature name..."\\n          />\\n\\n          {/* # 6.2.5.1 File Count Summary */}\\n          <Text size="sm" className="text-gray-600 mt-md mb-xs text-xs">\\n            {selectedFiles.length} of {repoFiles.length} files selected â€¢ Only\\n            JavaScript/TypeScript files are shown\\n          </Text>\\n\\n          {/* # 6.2.5.2 Scrollable Tree Container */}\\n          <div className="h-[400px] overflow-y-auto flex flex-col gap-xs">\\n            {renderedTree}\\n          </div>\\n        </div>\\n      )}\\n    </>\\n  );\\n});\\n\',\n    size: 3841,\n    dependents: [\n      {\n        name: "step-one-upload-files.tsx",\n        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/tree-item.tsx",\n    name: "tree-item.tsx",\n    content:\n      \'// # 1. Tree Item Component\\n// This component renders individual nodes in the file tree structure\\n\\nimport React, { useCallback, useMemo } from "react";\\nimport { Checkbox, ActionIcon, Collapse, Loader } from "@mantine/core";\\nimport clsx from "clsx";\\nimport {\\n  IconFile,\\n  IconFolder,\\n  IconFolderOpen,\\n  IconChevronRight,\\n  IconChevronDown,\\n} from "@tabler/icons-react";\\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\\nimport styles from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-item.module.css";\\n\\n// # 1.1 TreeNode Interface\\n// Represents a single node in the file tree structure\\nexport interface TreeNode {\\n  path: string;\\n  name: string;\\n  type: "file" | "directory";\\n  file?: RepoFile;\\n  children: TreeNode[];\\n  depth: number;\\n}\\n\\n// # 1.2 TreeItem Props Interface\\ninterface TreeItemProps {\\n  node: TreeNode;\\n  expandedDirectories: Set<string>;\\n  selectedFiles: SelectedRepoFile[];\\n  loadingFiles: Set<string>;\\n  onToggleExpanded: (path: string) => void;\\n  onToggleSelection: (file: RepoFile) => void;\\n}\\n\\n// # 1.3 Main TreeItem Component\\n// Renders a single tree node with expand/collapse and selection functionality\\nexport const TreeItem = React.memo(function TreeItem({\\n  node,\\n  expandedDirectories,\\n  selectedFiles,\\n  loadingFiles,\\n  onToggleExpanded,\\n  onToggleSelection,\\n}: TreeItemProps) {\\n  // # 1.3.1 Node State Calculations\\n  const hasChildren = node.children.length > 0;\\n  const isFile = node.type === "file";\\n  const isExpanded = expandedDirectories.has(node.path);\\n  const isSelected = node.file\\n    ? selectedFiles.some((f) => f.path === node.file!.path)\\n    : false;\\n  const isLoading = node.file ? loadingFiles.has(node.file.path) : false;\\n\\n  // # 1.3.2 Click Handler\\n  // Handles clicks on files (selection) and directories (expand/collapse)\\n  const handleClick = useCallback(() => {\\n    if (isFile && node.file && !isLoading) {\\n      onToggleSelection(node.file);\\n    } else if (hasChildren) {\\n      onToggleExpanded(node.path);\\n    }\\n  }, [\\n    isFile,\\n    node.file,\\n    node.path,\\n    isLoading,\\n    hasChildren,\\n    onToggleSelection,\\n    onToggleExpanded,\\n  ]);\\n\\n  const paperStyle = useMemo(() => {\\n    return {\\n      "--node-depth-margin": `${node.depth * 20}px`,\\n    } as React.CSSProperties;\\n  }, [node.depth]);\\n\\n  return (\\n    <div>\\n      {/* # 1.3.3 Node Container */}\\n      <div\\n        className={`${styles.nodeContainer} ${\\n          isFile && isSelected ? styles.selected : ""\\n        } p-xs rounded-sm shadow-xs border border-gray-200`}\\n        style={paperStyle}\\n        onClick={handleClick}\\n      >\\n        <div className="flex gap-xs  justify-between">\\n          {/* # 1.3.4 Left Content Group */}\\n          <div\\n            className={`${styles.contentGroup} items-center flex flex-1 gap-xs`}\\n          >\\n            {/* # 1.3.4.1 Expansion Controls */}\\n            {!isFile && hasChildren && (\\n              <ActionIcon\\n                variant="transparent"\\n                size="sm"\\n                onClick={(e) => {\\n                  e.stopPropagation();\\n                  onToggleExpanded(node.path);\\n                }}\\n              >\\n                {isExpanded ? (\\n                  <IconChevronDown size="0.8rem" />\\n                ) : (\\n                  <IconChevronRight size="0.8rem" />\\n                )}\\n              </ActionIcon>\\n            )}\\n            {!isFile && !hasChildren && (\\n              <div className="w-5" /> // Spacer for alignment\\n            )}\\n\\n            {/* # 1.3.4.2 File Selection Checkbox or Loading Spinner */}\\n            {isFile ? (\\n              <div className={`${styles.checkboxContainer} w-5 h-5`}>\\n                {isLoading ? (\\n                  <Loader size="xs" />\\n                ) : (\\n                  <Checkbox\\n                    checked={isSelected}\\n                    onChange={() => {}} // Controlled by parent click\\n                    size="sm"\\n                  />\\n                )}\\n              </div>\\n            ) : null}\\n\\n            {/* # 1.3.4.3 Node Icon */}\\n            {isFile ? (\\n              <IconFile size="1rem" />\\n            ) : (\\n              <>\\n                {isExpanded ? (\\n                  <IconFolderOpen size="1rem" />\\n                ) : (\\n                  <IconFolder size="1rem" />\\n                )}\\n              </>\\n            )}\\n\\n            {/* # 1.3.4.4 Node Name */}\\n            <div className={styles.nodeNameContainer}>\\n              <div\\n                className={clsx(\\n                  isFile ? "font-medium" : "text-gray-600",\\n                  "text-sm select-none"\\n                )}\\n              >\\n                {node.name}\\n              </div>\\n            </div>\\n          </div>\\n\\n          {/* # 1.3.5 Right Content - File Size */}\\n          {isFile && node.file?.size && (\\n            <p className="text-gray-600 text-xs">\\n              {Math.round(node.file.size / 1024)}KB\\n            </p>\\n          )}\\n        </div>\\n      </div>\\n\\n      {/* # 1.3.6 Children Container */}\\n      {!isFile && hasChildren && (\\n        <Collapse in={isExpanded} transitionDuration={0}>\\n          <div className="mt-xs gap-xs flex flex-col">\\n            {node.children.map((child) => (\\n              <TreeItem\\n                key={child.path}\\n                node={child}\\n                expandedDirectories={expandedDirectories}\\n                selectedFiles={selectedFiles}\\n                loadingFiles={loadingFiles}\\n                onToggleExpanded={onToggleExpanded}\\n                onToggleSelection={onToggleSelection}\\n              />\\n            ))}\\n          </div>\\n        </Collapse>\\n      )}\\n    </div>\\n  );\\n});\\n\',\n    size: 5619,\n    dependents: [\n      {\n        name: "file-tree-display.tsx",\n        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations.tsx",\n    name: "step-two-describe-relations.tsx",\n    content:\n      \'import { useState } from "react";\\nimport {\\n  Stack,\\n  Box,\\n  Title,\\n  Text,\\n  Tabs,\\n  Button,\\n  Select,\\n  Group,\\n  Paper,\\n  ActionIcon,\\n  Space,\\n} from "@mantine/core";\\nimport { IconPlus, IconSparkles, IconTrash } from "@tabler/icons-react";\\n// Use a more flexible file interface that works with both uploaded and repo files\\ninterface FileWithPathLike {\\n  path?: string;\\n  name: string;\\n  size?: number;\\n}\\nimport { InteractiveCanvas } from "src/routes/(generate-tests)/-components/interactive-canvas/interactive-canvas";\\nimport type { Dependency } from "src/hooks/use-dependencies";\\n\\ninterface DependenciesData {\\n  dependencies: Dependency[];\\n  fileOptions: { value: string; label: string }[];\\n  connectionOptions: { value: string; label: string }[];\\n  edges: Array<{ id: string; from: string; to: string; description: string }>;\\n  addDependency: () => void;\\n  updateDependency: (\\n    id: string,\\n    field: keyof Dependency,\\n    value: string\\n  ) => void;\\n  removeDependency: (id: string) => void;\\n  generateDependencies: () => void;\\n}\\n\\ninterface StepTwoDescribeRelationsProps {\\n  files: FileWithPathLike[];\\n  dependenciesData: DependenciesData;\\n}\\n\\nexport function StepTwoDescribeRelations({\\n  files,\\n  dependenciesData,\\n}: StepTwoDescribeRelationsProps) {\\n  const [activeTab, setActiveTab] = useState<string>("describe");\\n  const {\\n    dependencies,\\n    fileOptions,\\n    connectionOptions,\\n    edges,\\n    addDependency,\\n    updateDependency,\\n    removeDependency,\\n    generateDependencies,\\n  } = dependenciesData;\\n\\n  return (\\n    <Stack className="gap-lg">\\n      <Box className="text-center">\\n        <Title order={2} className="mb-md">\\n          Configure File Relationships\\n        </Title>\\n        <Text size="lg" className="text-gray-600">\\n          Describe file relationships or visualize them interactively\\n        </Text>\\n      </Box>\\n\\n      {files.length > 0 ? (\\n        <Tabs\\n          value={activeTab}\\n          onChange={(value) => setActiveTab(value || "describe")}\\n        >\\n          <Tabs.List grow>\\n            <Tabs.Tab value="describe">Describe</Tabs.Tab>\\n            <Tabs.Tab value="visualize">Visualize</Tabs.Tab>\\n          </Tabs.List>\\n\\n          <Space h="md" />\\n\\n          <Tabs.Panel value="describe">\\n            <Stack className="gap-md">\\n              <Group className="justify-between items-center">\\n                <Text size="lg" className="font-medium">\\n                  Dependencies\\n                </Text>\\n                <Group gap="xs">\\n                  <Button\\n                    leftSection={<IconSparkles size={16} />}\\n                    onClick={generateDependencies}\\n                    variant="light"\\n                  >\\n                    Generate\\n                  </Button>\\n                  <Button\\n                    leftSection={<IconPlus size={16} />}\\n                    onClick={addDependency}\\n                    variant="light"\\n                  >\\n                    Add\\n                  </Button>\\n                </Group>\\n              </Group>\\n\\n              {dependencies.length === 0 ? (\\n                <Paper className="border-gray-200 rounded-md p-lg">\\n                  <Text className="text-center text-gray-600">\\n                    No dependencies defined yet. Click "Generate" or "Add" to\\n                    get started.\\n                  </Text>\\n                </Paper>\\n              ) : (\\n                <Stack className="gap-sm">\\n                  {dependencies.map((dependency) => (\\n                    <Paper\\n                      key={dependency.id}\\n                      className="border-gray-200 rounded-md p-md"\\n                    >\\n                      <Group className="justify-between flex-end">\\n                        <Group className="flex-1 flex-end wrap-nowrap">\\n                          <Select\\n                            label="From"\\n                            placeholder="Select file"\\n                            data={fileOptions}\\n                            value={dependency.from}\\n                            comboboxProps={{\\n                              width: "max-content",\\n                              position: "bottom-start",\\n                              middlewares: { flip: false, shift: false },\\n                            }}\\n                            onChange={(value) =>\\n                              updateDependency(\\n                                dependency.id,\\n                                "from",\\n                                value || ""\\n                              )\\n                            }\\n                            style={{ minWidth: 200 }}\\n                          />\\n                          <Select\\n                            label="Connection"\\n                            data={connectionOptions}\\n                            value={dependency.connection}\\n                            onChange={(value) =>\\n                              updateDependency(\\n                                dependency.id,\\n                                "connection",\\n                                value || "uses"\\n                              )\\n                            }\\n                            className="min-w-[120px]"\\n                          />\\n                          <Select\\n                            label="To"\\n                            placeholder="Select file"\\n                            data={fileOptions}\\n                            value={dependency.to}\\n                            onChange={(value) =>\\n                              updateDependency(dependency.id, "to", value || "")\\n                            }\\n                            className="min-w-[200px]"\\n                          />\\n                        </Group>\\n                        <div className={Select.classes.wrapper}>\\n                          <Box className="flex items-center h-[var(--input-height)]">\\n                            <ActionIcon\\n                              variant="subtle"\\n                              color="red"\\n                              onClick={() => removeDependency(dependency.id)}\\n                            >\\n                              <IconTrash size={16} />\\n                            </ActionIcon>\\n                          </Box>\\n                        </div>\\n                      </Group>\\n                    </Paper>\\n                  ))}\\n                </Stack>\\n              )}\\n            </Stack>\\n          </Tabs.Panel>\\n\\n          <Tabs.Panel value="visualize">\\n            <Stack className="gap-md">\\n              <Text size="sm" className="text-gray-600">\\n                Drag nodes to organize them. Use mouse wheel to zoom, click and\\n                drag empty space to pan.\\n              </Text>\\n              <InteractiveCanvas files={files} edges={edges} />\\n            </Stack>\\n          </Tabs.Panel>\\n        </Tabs>\\n      ) : (\\n        <Text className="text-center text-orange-500">\\n          No files available. Please go back to step 1 and upload some files.\\n        </Text>\\n      )}\\n    </Stack>\\n  );\\n}\\n\',\n    size: 7011,\n    dependents: [\n      {\n        name: "generate-tests.tsx",\n        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/interactive-canvas/interactive-canvas.tsx",\n    name: "interactive-canvas.tsx",\n    content:\n      \'/* eslint-disable react-refresh/only-export-components */\\nimport { useRef, useState, useMemo, useEffect } from "react";\\nimport { Box } from "@mantine/core";\\n// Make the canvas work with any file-like object that has a name\\ninterface FileWithName {\\n  name: string;\\n}\\nimport * as d3 from "d3";\\n\\n// ## 1. Type Definitions and Interfaces\\n// ### 1.1. Point interface for coordinates\\nexport interface Point {\\n  x: number;\\n  y: number;\\n}\\n\\n// ### 1.2. Node position interface (SVG coordinate space)\\nexport interface NodePosition {\\n  x: number;\\n  y: number;\\n}\\n\\n// ### 1.3. File node data interface\\ninterface FileNodeData {\\n  id: string;\\n  name: string;\\n  position: NodePosition;\\n}\\n\\n// ### 1.4. Edge interface for connections between nodes\\nexport interface Edge {\\n  id: string;\\n  from: string;\\n  to: string;\\n  description: string;\\n}\\n\\n// ### 1.5. Canvas state interface\\nexport interface CanvasState {\\n  zoom: number;\\n  pan: Point;\\n  selectedNodeId: string | null;\\n  isDragging: boolean;\\n  dragType: "canvas" | "node" | null;\\n  draggedNodeId: string | null;\\n  dragStartPoint: Point | null;\\n}\\n\\n// ### 1.6. Interactive canvas component props\\ninterface InteractiveCanvasProps {\\n  files: FileWithName[];\\n  edges?: Edge[];\\n}\\n\\n// ## 2. Constants and Configuration\\nconst NODE_WIDTH = 120;\\nconst NODE_HEIGHT = 60;\\nconst GRID_SPACING = 180;\\nexport const MIN_ZOOM = 0.1;\\nexport const MAX_ZOOM = 3;\\n\\n// ## 3. Canvas Action Functions - Pure functions for testability\\n\\n// ### 3.1. dragCanvas - Pan the canvas view\\nexport function dragCanvas(\\n  state: CanvasState,\\n  startPoint: Point,\\n  currentPoint: Point\\n): CanvasState {\\n  // #### 3.1.1. Calculate movement delta\\n  const deltaX = currentPoint.x - startPoint.x;\\n  const deltaY = currentPoint.y - startPoint.y;\\n\\n  // #### 3.1.2. Return new state with updated pan position\\n  return {\\n    ...state,\\n    pan: {\\n      x: state.pan.x + deltaX,\\n      y: state.pan.y + deltaY,\\n    },\\n  };\\n}\\n\\n// ### 3.2. zoom - Zoom in/out at a specific point\\nexport function zoom(\\n  state: CanvasState,\\n  zoomPoint: Point,\\n  zoomDelta: number\\n): CanvasState {\\n  // #### 3.2.1. Calculate new zoom level within bounds\\n  const newZoom = Math.max(\\n    MIN_ZOOM,\\n    Math.min(MAX_ZOOM, state.zoom * (1 + zoomDelta))\\n  );\\n\\n  // #### 3.2.2. Early return if zoom didn\\\'t change\\n  if (newZoom === state.zoom) {\\n    return state;\\n  }\\n\\n  // #### 3.2.3. Calculate zoom ratio and adjust pan to zoom at point\\n  const zoomRatio = newZoom / state.zoom;\\n\\n  return {\\n    ...state,\\n    zoom: newZoom,\\n    pan: {\\n      x: zoomPoint.x - (zoomPoint.x - state.pan.x) * zoomRatio,\\n      y: zoomPoint.y - (zoomPoint.y - state.pan.y) * zoomRatio,\\n    },\\n  };\\n}\\n\\n// ### 3.3. dragNode - Move a specific node\\nexport function dragNode(\\n  nodePositions: Record<string, NodePosition>,\\n  nodeId: string,\\n  startPoint: Point,\\n  currentPoint: Point,\\n  canvasZoom: number,\\n  initialNodePosition: NodePosition\\n): Record<string, NodePosition> {\\n  // #### 3.3.1. Calculate delta in screen space\\n  const screenDeltaX = currentPoint.x - startPoint.x;\\n  const screenDeltaY = currentPoint.y - startPoint.y;\\n\\n  // #### 3.3.2. Convert to SVG space (account for zoom)\\n  const svgDeltaX = screenDeltaX / canvasZoom;\\n  const svgDeltaY = screenDeltaY / canvasZoom;\\n\\n  // #### 3.3.3. Return new node positions with updated node\\n  return {\\n    ...nodePositions,\\n    [nodeId]: {\\n      x: initialNodePosition.x + svgDeltaX,\\n      y: initialNodePosition.y + svgDeltaY,\\n    },\\n  };\\n}\\n\\n// ### 3.4. clickNode - Handle node selection/interaction\\nexport function clickNode(state: CanvasState, nodeId: string): CanvasState {\\n  return {\\n    ...state,\\n    selectedNodeId: state.selectedNodeId === nodeId ? null : nodeId,\\n  };\\n}\\n\\n// ## 4. InteractiveCanvas Component\\nexport function InteractiveCanvas({\\n  files,\\n  edges = [],\\n}: InteractiveCanvasProps) {\\n  // ### 4.1. State Management\\n  // #### 4.1.1. Canvas state (zoom, pan, selection, dragging)\\n  const [canvasState, setCanvasState] = useState<CanvasState>({\\n    zoom: 1,\\n    pan: { x: 0, y: 0 },\\n    selectedNodeId: null,\\n    isDragging: false,\\n    dragType: null,\\n    draggedNodeId: null,\\n    dragStartPoint: null,\\n  });\\n\\n  // #### 4.1.2. Node positions state\\n  const [nodePositions, setNodePositions] = useState<\\n    Record<string, NodePosition>\\n  >({});\\n\\n  // ### 4.2. References for D3 Operations\\n  const containerRef = useRef<HTMLDivElement>(null);\\n  const svgRef = useRef<SVGSVGElement>(null);\\n  const gRef = useRef<SVGGElement>(null);\\n  const zoomBehaviorRef = useRef<d3.ZoomBehavior<\\n    SVGSVGElement,\\n    unknown\\n  > | null>(null);\\n  const initialNodePositionRef = useRef<NodePosition>({ x: 0, y: 0 });\\n\\n  // #### 4.2.1. State refs for drag callbacks (to avoid stale closures)\\n  const canvasStateRef = useRef(canvasState);\\n  const nodePositionsRef = useRef(nodePositions);\\n\\n  // ### 4.3. Sync Effects - Keep refs in sync with state\\n  useEffect(() => {\\n    canvasStateRef.current = canvasState;\\n  }, [canvasState]);\\n\\n  useEffect(() => {\\n    nodePositionsRef.current = nodePositions;\\n  }, [nodePositions]);\\n\\n  // ### 4.4. Computed Data\\n  // #### 4.4.1. Generate file nodes data with positions\\n  const fileNodes = useMemo((): FileNodeData[] => {\\n    return files.map((file, index) => ({\\n      id: `file-${index}`,\\n      name: file.name,\\n      position:\\n        nodePositions[`file-${index}`] ||\\n        calculateInitialPosition(index, files.length),\\n    }));\\n  }, [files, nodePositions]);\\n\\n  // ### 4.5. Helper Functions\\n  // #### 4.5.1. Calculate initial grid position for nodes\\n  function calculateInitialPosition(\\n    index: number,\\n    totalFiles: number\\n  ): NodePosition {\\n    const nodesPerRow = Math.ceil(Math.sqrt(totalFiles));\\n    const row = Math.floor(index / nodesPerRow);\\n    const col = index % nodesPerRow;\\n\\n    return {\\n      x: col * GRID_SPACING + NODE_WIDTH / 2,\\n      y: row * GRID_SPACING + NODE_HEIGHT / 2,\\n    };\\n  }\\n\\n  // ### 4.6. Initialization Effects\\n  // #### 4.6.1. Initialize node positions when files change\\n  useEffect(() => {\\n    const initialPositions: Record<string, NodePosition> = {};\\n    files.forEach((_, index) => {\\n      const nodeId = `file-${index}`;\\n      if (!nodePositions[nodeId]) {\\n        initialPositions[nodeId] = calculateInitialPosition(\\n          index,\\n          files.length\\n        );\\n      }\\n    });\\n\\n    if (Object.keys(initialPositions).length > 0) {\\n      setNodePositions((prev) => ({ ...prev, ...initialPositions }));\\n    }\\n  }, [files, nodePositions]);\\n\\n  // ### 4.7. D3 Setup Effects\\n  // #### 4.7.1. Initialize SVG and setup D3 behaviors (only once)\\n  useEffect(() => {\\n    if (!containerRef.current) return;\\n\\n    const container = d3.select(containerRef.current);\\n\\n    // ##### 4.7.1.1. Clear any existing content\\n    container.selectAll("*").remove();\\n\\n    // ##### 4.7.1.2. Create SVG element\\n    const svg = container\\n      .append("svg")\\n      .attr("width", "100%")\\n      .attr("height", "100%")\\n      .style("user-select", "none");\\n\\n    svgRef.current = svg.node();\\n\\n    // ##### 4.7.1.3. Create main group for zoom/pan transforms\\n    const g = svg.append("g");\\n    gRef.current = g.node();\\n\\n    // ##### 4.7.1.4. Setup grid pattern for visual grid background\\n    const defs = svg.append("defs");\\n    const pattern = defs\\n      .append("pattern")\\n      .attr("id", "grid")\\n      .attr("width", 20)\\n      .attr("height", 20)\\n      .attr("patternUnits", "userSpaceOnUse");\\n\\n    pattern\\n      .append("path")\\n      .attr("d", "M 20 0 L 0 0 0 20")\\n      .attr("fill", "none")\\n      .attr("stroke", "var(--mantine-color-gray-2)")\\n      .attr("stroke-width", 0.5)\\n      .attr("opacity", 0.5);\\n\\n    // ##### 4.7.1.5. Add grid background rectangle\\n    g.append("rect")\\n      .attr("x", -2000)\\n      .attr("y", -2000)\\n      .attr("width", 4000)\\n      .attr("height", 4000)\\n      .attr("fill", "url(#grid)");\\n\\n    // ##### 4.7.1.6. Add arrow marker definition for edges\\n    const arrowMarker = defs\\n      .append("marker")\\n      .attr("id", "arrow")\\n      .attr("viewBox", "0 -5 10 10")\\n      .attr("refX", 8)\\n      .attr("refY", 0)\\n      .attr("markerWidth", 6)\\n      .attr("markerHeight", 6)\\n      .attr("orient", "auto");\\n\\n    arrowMarker\\n      .append("path")\\n      .attr("d", "M0,-5L10,0L0,5")\\n      .attr("fill", "var(--mantine-color-gray-6)");\\n\\n    // ##### 4.7.1.7. Setup zoom behavior - apply to SVG, not container\\n    const zoomBehavior = d3\\n      .zoom<SVGSVGElement, unknown>()\\n      .scaleExtent([MIN_ZOOM, MAX_ZOOM])\\n      .on("zoom", (event) => {\\n        const transform = event.transform;\\n\\n        // Update canvas state with new zoom/pan values\\n        setCanvasState((prev) => ({\\n          ...prev,\\n          zoom: transform.k,\\n          pan: { x: transform.x, y: transform.y },\\n        }));\\n\\n        // Apply transform to the main group\\n        g.attr("transform", transform.toString());\\n      });\\n\\n    zoomBehaviorRef.current = zoomBehavior;\\n\\n    // ##### 4.7.1.8. Apply zoom behavior to SVG element for proper event handling\\n    svg.call(zoomBehaviorRef.current);\\n\\n    // ##### 4.7.1.9. Sync initial state with D3 zoom\\n    const initialTransform = d3.zoomIdentity\\n      .translate(canvasState.pan.x, canvasState.pan.y)\\n      .scale(canvasState.zoom);\\n\\n    svg.call(zoomBehavior.transform, initialTransform);\\n\\n    // ##### 4.7.1.10. Cleanup function to remove event listeners\\n    return () => {\\n      if (zoomBehaviorRef.current) {\\n        svg.on(".zoom", null);\\n      }\\n    };\\n    // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, []); // Remove dependencies to prevent recreation\\n\\n  // #### 4.5.2. Calculate edge connection points between nodes\\n  const calculateEdgePoints = (fromPos: NodePosition, toPos: NodePosition) => {\\n    // ##### 4.5.2.1. Calculate direction vector between nodes\\n    const dx = toPos.x - fromPos.x;\\n    const dy = toPos.y - fromPos.y;\\n    const distance = Math.sqrt(dx * dx + dy * dy);\\n\\n    // ##### 4.5.2.2. Handle case where nodes are at same position\\n    if (distance === 0) {\\n      return { x1: fromPos.x, y1: fromPos.y, x2: toPos.x, y2: toPos.y };\\n    }\\n\\n    // ##### 4.5.2.3. Normalize direction vector to unit vector\\n    const unitX = dx / distance;\\n    const unitY = dy / distance;\\n\\n    // ##### 4.5.2.4. Calculate connection points at node edges\\n    // From node: start from edge in direction of target\\n    const fromRadius = Math.max(NODE_WIDTH, NODE_HEIGHT) / 2;\\n    const x1 = fromPos.x + unitX * fromRadius;\\n    const y1 = fromPos.y + unitY * fromRadius;\\n\\n    // To node: end at edge from direction of source\\n    const toRadius = Math.max(NODE_WIDTH, NODE_HEIGHT) / 2;\\n    const x2 = toPos.x - unitX * toRadius;\\n    const y2 = toPos.y - unitY * toRadius;\\n\\n    return { x1, y1, x2, y2 };\\n  };\\n\\n  // ### 4.8. Rendering Effects\\n  // #### 4.8.1. Render edges with D3\\n  useEffect(() => {\\n    if (!gRef.current) return;\\n\\n    const g = d3.select(gRef.current);\\n\\n    // ##### 4.8.1.1. Helper function to get node position by ID\\n    const getNodePosition = (nodeId: string): NodePosition | null => {\\n      const node = fileNodes.find((n) => n.id === nodeId);\\n      return node ? node.position : null;\\n    };\\n\\n    // ##### 4.8.1.2. Filter valid edges (both from and to nodes exist)\\n    const validEdges = edges.filter((edge) => {\\n      const fromPos = getNodePosition(edge.from);\\n      const toPos = getNodePosition(edge.to);\\n      return fromPos && toPos;\\n    });\\n\\n    // ##### 4.8.1.3. Data join for edges using D3 pattern\\n    const edgeLines = g\\n      .selectAll<SVGLineElement, Edge>("line.edge")\\n      .data(validEdges, (d) => d.id);\\n\\n    // ##### 4.8.1.4. Enter selection for new edges\\n    const enterEdges = edgeLines\\n      .enter()\\n      .append("line")\\n      .attr("class", "edge")\\n      .attr("stroke", "var(--mantine-color-gray-6)")\\n      .attr("stroke-width", 2)\\n      .attr("marker-end", "url(#arrow)")\\n      .attr("opacity", 0.7);\\n\\n    // ##### 4.8.1.5. Merge enter and update selections\\n    const allEdges = enterEdges.merge(edgeLines);\\n\\n    // ##### 4.8.1.6. Update edge positions with proper node-to-node connections\\n    allEdges.each(function (d) {\\n      const fromPos = getNodePosition(d.from);\\n      const toPos = getNodePosition(d.to);\\n\\n      if (fromPos && toPos) {\\n        const { x1, y1, x2, y2 } = calculateEdgePoints(fromPos, toPos);\\n\\n        d3.select(this)\\n          .attr("x1", x1)\\n          .attr("y1", y1)\\n          .attr("x2", x2)\\n          .attr("y2", y2);\\n      }\\n    });\\n\\n    // ##### 4.8.1.7. Remove edges that are no longer needed\\n    edgeLines.exit().remove();\\n\\n    // ##### 4.8.1.8. Data join for edge labels\\n    const edgeLabels = g\\n      .selectAll<SVGTextElement, Edge>("text.edge-label")\\n      .data(validEdges, (d) => d.id);\\n\\n    // ##### 4.8.1.9. Enter selection for new edge labels\\n    const enterLabels = edgeLabels\\n      .enter()\\n      .append("text")\\n      .attr("class", "edge-label")\\n      .attr("text-anchor", "middle")\\n      .attr("dominant-baseline", "middle")\\n      .style("font-size", "10px")\\n      .style("font-family", "var(--mantine-font-family)")\\n      .style("fill", "var(--mantine-color-gray-7)")\\n      .style("background", "white")\\n      .style("pointer-events", "none");\\n\\n    // ##### 4.8.1.10. Merge enter and update selections for labels\\n    const allLabels = enterLabels.merge(edgeLabels);\\n\\n    // ##### 4.8.1.11. Update edge label positions and text - position above the line\\n    allLabels.each(function (d) {\\n      const fromPos = getNodePosition(d.from);\\n      const toPos = getNodePosition(d.to);\\n\\n      if (fromPos && toPos) {\\n        const { x1, y1, x2, y2 } = calculateEdgePoints(fromPos, toPos);\\n\\n        // Calculate midpoint of the actual edge line\\n        const midX = (x1 + x2) / 2;\\n        const midY = (y1 + y2) / 2;\\n\\n        // Calculate perpendicular offset to position text above the line\\n        const dx = x2 - x1;\\n        const dy = y2 - y1;\\n        const distance = Math.sqrt(dx * dx + dy * dy);\\n\\n        if (distance > 0) {\\n          // Perpendicular vector (rotated 90 degrees)\\n          const perpX = -dy / distance;\\n          const perpY = dx / distance;\\n\\n          // Offset text above the line\\n          const offsetDistance = 12; // pixels above the line\\n          const textX = midX + perpX * offsetDistance;\\n          const textY = midY + perpY * offsetDistance;\\n\\n          d3.select(this).attr("x", textX).attr("y", textY).text(d.description);\\n        }\\n      }\\n    });\\n\\n    // ##### 4.8.1.12. Remove labels that are no longer needed\\n    edgeLabels.exit().remove();\\n  }, [edges, fileNodes, nodePositions]);\\n\\n  // #### 4.8.2. Render nodes with D3\\n  useEffect(() => {\\n    if (!gRef.current) return;\\n\\n    const g = d3.select(gRef.current);\\n\\n    // ##### 4.8.2.1. Setup drag behavior for nodes\\n    const dragBehavior = d3\\n      .drag<SVGGElement, FileNodeData>()\\n      .on("start", (event, d) => {\\n        // Prevent canvas zoom/pan while dragging nodes\\n        event.sourceEvent.stopPropagation();\\n\\n        // Store initial position for the pure function\\n        initialNodePositionRef.current = d.position;\\n\\n        // Store drag start point in screen coordinates\\n        const startPoint = {\\n          x: event.sourceEvent.clientX,\\n          y: event.sourceEvent.clientY,\\n        };\\n\\n        setCanvasState((prev) => ({\\n          ...prev,\\n          isDragging: true,\\n          dragType: "node",\\n          draggedNodeId: d.id,\\n          dragStartPoint: startPoint,\\n        }));\\n      })\\n      .on("drag", (event, d) => {\\n        event.sourceEvent.stopPropagation();\\n\\n        // Get current state from refs to avoid stale closures\\n        const currentCanvasState = canvasStateRef.current;\\n        const currentNodePositions = nodePositionsRef.current;\\n\\n        if (!currentCanvasState.dragStartPoint) return;\\n\\n        // Get current mouse position in screen coordinates\\n        const currentPoint: Point = {\\n          x: event.sourceEvent.clientX,\\n          y: event.sourceEvent.clientY,\\n        };\\n\\n        // Use pure function to calculate new node positions\\n        const newNodePositions = dragNode(\\n          currentNodePositions,\\n          d.id,\\n          currentCanvasState.dragStartPoint,\\n          currentPoint,\\n          currentCanvasState.zoom,\\n          initialNodePositionRef.current\\n        );\\n\\n        setNodePositions(newNodePositions);\\n      })\\n      .on("end", (event, d) => {\\n        event.sourceEvent.stopPropagation();\\n\\n        const currentCanvasState = canvasStateRef.current;\\n\\n        if (!currentCanvasState.dragStartPoint) {\\n          // Reset state if no drag start point (error case)\\n          setCanvasState((prev) => ({\\n            ...prev,\\n            isDragging: false,\\n            dragType: null,\\n            draggedNodeId: null,\\n            dragStartPoint: null,\\n          }));\\n          return;\\n        }\\n\\n        // Get end position in screen coordinates\\n        const endPoint: Point = {\\n          x: event.sourceEvent.clientX,\\n          y: event.sourceEvent.clientY,\\n        };\\n\\n        // Check if this was a click vs drag (movement threshold)\\n        const isClick =\\n          Math.abs(endPoint.x - currentCanvasState.dragStartPoint.x) < 5 &&\\n          Math.abs(endPoint.y - currentCanvasState.dragStartPoint.y) < 5;\\n\\n        if (isClick) {\\n          // Handle click - toggle node selection\\n          const newCanvasState = clickNode(currentCanvasState, d.id);\\n          setCanvasState({\\n            ...newCanvasState,\\n            isDragging: false,\\n            dragType: null,\\n            draggedNodeId: null,\\n            dragStartPoint: null,\\n          });\\n        } else {\\n          // Handle drag end - just reset drag state\\n          setCanvasState((prev) => ({\\n            ...prev,\\n            isDragging: false,\\n            dragType: null,\\n            draggedNodeId: null,\\n            dragStartPoint: null,\\n          }));\\n        }\\n      });\\n\\n    // ##### 4.8.2.2. Data join for nodes using D3 pattern\\n    const nodeGroups = g\\n      .selectAll<SVGGElement, FileNodeData>("g.file-node")\\n      .data(fileNodes, (d) => d.id);\\n\\n    // ##### 4.8.2.3. Enter selection for new nodes\\n    const enterGroups = nodeGroups\\n      .enter()\\n      .append("g")\\n      .attr("class", "file-node")\\n      .style("cursor", "move")\\n      .call(dragBehavior);\\n\\n    // ##### 4.8.2.4. Add rectangle shape to new node groups\\n    enterGroups\\n      .append("rect")\\n      .attr("width", NODE_WIDTH)\\n      .attr("height", NODE_HEIGHT)\\n      .attr("rx", 8)\\n      .attr("x", -NODE_WIDTH / 2)\\n      .attr("y", -NODE_HEIGHT / 2);\\n\\n    // ##### 4.8.2.5. Add text labels to new node groups\\n    enterGroups\\n      .append("text")\\n      .attr("text-anchor", "middle")\\n      .attr("dominant-baseline", "middle")\\n      .style("font-size", "12px")\\n      .style("font-family", "var(--mantine-font-family)")\\n      .style("font-weight", "500")\\n      .style("pointer-events", "none")\\n      .text((d) =>\\n        d.name.length > 15 ? `${d.name.substring(0, 12)}...` : d.name\\n      );\\n\\n    // ##### 4.8.2.6. Merge enter and update selections\\n    const allGroups = enterGroups.merge(nodeGroups);\\n\\n    // ##### 4.8.2.7. Update node positions\\n    allGroups.attr(\\n      "transform",\\n      (d) => `translate(${d.position.x}, ${d.position.y})`\\n    );\\n\\n    // ##### 4.8.2.8. Update visual states based on selection and drag\\n    allGroups\\n      .select("rect")\\n      .attr("fill", (d) => {\\n        if (canvasState.selectedNodeId === d.id)\\n          return "var(--mantine-color-blue-2)";\\n        return "var(--mantine-color-blue-1)";\\n      })\\n      .attr("stroke", (d) => {\\n        if (canvasState.selectedNodeId === d.id)\\n          return "var(--mantine-color-blue-6)";\\n        return "var(--mantine-color-blue-3)";\\n      })\\n      .attr("stroke-width", (d) => {\\n        if (canvasState.selectedNodeId === d.id) return 3;\\n        return 1;\\n      })\\n      .style("opacity", (d) => {\\n        if (canvasState.draggedNodeId === d.id) return 0.8;\\n        return 1;\\n      });\\n\\n    // ##### 4.8.2.9. Update text color\\n    allGroups.select("text").attr("fill", "var(--mantine-color-blue-9)");\\n\\n    // ##### 4.8.2.10. Setup hover effects for interactive feedback\\n    allGroups\\n      .on("mouseenter", function (_event, d) {\\n        if (canvasState.draggedNodeId !== d.id) {\\n          d3.select(this)\\n            .select("rect")\\n            .attr("stroke", "var(--mantine-color-blue-4)")\\n            .attr("stroke-width", 2);\\n        }\\n      })\\n      .on("mouseleave", function (_event, d) {\\n        if (canvasState.draggedNodeId !== d.id) {\\n          const isSelected = canvasState.selectedNodeId === d.id;\\n          d3.select(this)\\n            .select("rect")\\n            .attr(\\n              "stroke",\\n              isSelected\\n                ? "var(--mantine-color-blue-6)"\\n                : "var(--mantine-color-blue-3)"\\n            )\\n            .attr("stroke-width", isSelected ? 3 : 1);\\n        }\\n      });\\n\\n    // ##### 4.8.2.11. Remove nodes that are no longer needed\\n    nodeGroups.exit().remove();\\n  }, [fileNodes, canvasState, nodePositions]);\\n\\n  // ### 4.9. Component Render - Container for D3 SVG canvas\\n  return (\\n    <Box\\n      ref={containerRef}\\n      style={{\\n        width: "100%",\\n        height: 400,\\n        border: "1px solid var(--mantine-color-gray-3)",\\n        borderRadius: "var(--mantine-radius-md)",\\n        overflow: "hidden",\\n        // Dynamic cursor based on interaction state\\n        cursor: canvasState.isDragging\\n          ? canvasState.dragType === "canvas"\\n            ? "grabbing"\\n            : "move"\\n          : "grab",\\n      }}\\n    />\\n  );\\n}\\n\',\n    size: 21386,\n    dependents: [\n      {\n        name: "step-two-describe-relations.tsx",\n        path: "ui/src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/step-three-view-results/step-three-view-results.tsx",\n    name: "step-three-view-results.tsx",\n    content:\n      \'import { Stack, Box, Title, Text } from "@mantine/core";\\n\\nexport function StepThreeViewResults() {\\n  return (\\n    <Stack gap="lg">\\n      <Box ta="center">\\n        <Title order={2} mb="md">\\n          Review Results\\n        </Title>\\n        <Text c="dimmed" size="lg">\\n          Review and download your generated test cases\\n        </Text>\\n      </Box>\\n      {/* This will be implemented later */}\\n      <Text ta="center" c="green">\\n        Coming soon: Generated test results\\n      </Text>\\n    </Stack>\\n  );\\n}\\n\',\n    size: 510,\n    dependents: [\n      {\n        name: "generate-tests.tsx",\n        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/use-file-tree.ts",\n    name: "use-file-tree.ts",\n    content:\n      \'// # 3. File Tree State Management Hook\\n// Custom hook for managing file tree state and operations\\n\\nimport { useState, useEffect, useMemo, useCallback } from "react";\\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\\nimport { type TreeNode } from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-item";\\nimport {\\n  buildFileTree,\\n  getFirstLevelDirectories,\\n} from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-utils";\\n\\n// # 3.1 Hook Interface\\ninterface UseFileTreeProps {\\n  repoFiles: RepoFile[];\\n  selectedFiles: SelectedRepoFile[];\\n}\\n\\n// # 3.2 Hook Return Type\\ninterface UseFileTreeReturn {\\n  fileTree: TreeNode[];\\n  expandedDirectories: Set<string>;\\n  toggleDirectoryExpansion: (path: string) => void;\\n}\\n\\n// # 3.3 Main Hook Implementation\\n// Manages tree state, expansion, and provides utility functions\\nexport function useFileTree({\\n  repoFiles,\\n}: UseFileTreeProps): UseFileTreeReturn {\\n  // # 3.3.1 State Management\\n  const [expandedDirectories, setExpandedDirectories] = useState<Set<string>>(\\n    new Set()\\n  );\\n\\n  // # 3.3.2 Build Tree Structure\\n  // Build tree structure from files (memoized to prevent unnecessary re-renders)\\n  const fileTree = useMemo(() => {\\n    return repoFiles.length > 0 ? buildFileTree(repoFiles) : [];\\n  }, [repoFiles]);\\n\\n  // # 3.3.3 Directory Expansion Functions\\n\\n  // # 3.3.3.1 Toggle Single Directory\\n  const toggleDirectoryExpansion = useCallback((path: string) => {\\n    setExpandedDirectories((prev) => {\\n      const newSet = new Set(prev);\\n      if (newSet.has(path)) {\\n        newSet.delete(path);\\n      } else {\\n        newSet.add(path);\\n      }\\n      return newSet;\\n    });\\n  }, []);\\n\\n  // # 3.3.4 Auto-expand Effect\\n  // Auto-expand first level directories when files are first loaded\\n  useEffect(() => {\\n    if (repoFiles.length > 0 && expandedDirectories.size === 0) {\\n      const firstLevelDirs = getFirstLevelDirectories(fileTree);\\n      setExpandedDirectories(new Set(firstLevelDirs));\\n    }\\n  }, [repoFiles.length, fileTree, expandedDirectories.size]);\\n\\n  // # 3.3.5 Return Hook Interface\\n  return {\\n    fileTree,\\n    expandedDirectories,\\n    toggleDirectoryExpansion,\\n  };\\n}\\n\',\n    size: 2190,\n    dependents: [\n      {\n        name: "generate-tests.tsx",\n        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",\n      },\n    ],\n  },\n  {\n    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/tree-utils.ts",\n    name: "tree-utils.ts",\n    content:\n      \'// # 2. Tree Utility Functions\\n// Contains helper functions for building and managing file tree structures\\n\\nimport type { RepoFile } from "src/types/repo";\\nimport type { TreeNode } from "./tree-item";\\n\\n// # 2.1 Build File Tree Function\\n// Converts a flat list of RepoFile objects into a hierarchical tree structure\\nexport function buildFileTree(files: RepoFile[]): TreeNode[] {\\n  // # 2.1.1 Initialize Tree Structure\\n  const tree: TreeNode[] = [];\\n  const pathToNode: Map<string, TreeNode> = new Map();\\n\\n  // # 2.1.2 Sort Files for Proper Tree Building\\n  // Sort files by path to ensure proper hierarchical construction\\n  const sortedFiles = [...files].sort((a, b) => a.path.localeCompare(b.path));\\n\\n  // # 2.1.3 Process Each File\\n  for (const file of sortedFiles) {\\n    const pathParts = file.path.split("/");\\n    let currentPath = "";\\n\\n    // # 2.1.4 Build Path Hierarchy\\n    // Create directory nodes for each part of the file path\\n    for (let i = 0; i < pathParts.length; i++) {\\n      const part = pathParts[i];\\n      const parentPath = currentPath;\\n      currentPath = currentPath ? `${currentPath}/${part}` : part;\\n\\n      // # 2.1.5 Create Node if Not Exists\\n      if (!pathToNode.has(currentPath)) {\\n        const isFile = i === pathParts.length - 1;\\n        const node: TreeNode = {\\n          path: currentPath,\\n          name: part,\\n          type: isFile ? "file" : "directory",\\n          file: isFile ? file : undefined,\\n          children: [],\\n          depth: i,\\n        };\\n\\n        pathToNode.set(currentPath, node);\\n\\n        // # 2.1.6 Link to Parent or Root\\n        if (parentPath && pathToNode.has(parentPath)) {\\n          pathToNode.get(parentPath)!.children.push(node);\\n        } else if (i === 0) {\\n          tree.push(node);\\n        }\\n      }\\n    }\\n  }\\n\\n  return tree;\\n}\\n\\n// # 2.2 Collect Directory Paths Function\\n// Recursively collects all directory paths from a tree structure\\nexport function collectDirectoryPaths(nodes: TreeNode[]): Set<string> {\\n  const allDirectoryPaths = new Set<string>();\\n\\n  const traverse = (nodeList: TreeNode[]) => {\\n    nodeList.forEach((node) => {\\n      if (node.type === "directory") {\\n        allDirectoryPaths.add(node.path);\\n        if (node.children.length > 0) {\\n          traverse(node.children);\\n        }\\n      }\\n    });\\n  };\\n\\n  traverse(nodes);\\n  return allDirectoryPaths;\\n}\\n\\n// # 2.3 Get First Level Directories Function\\n// Extracts only the top-level directory paths from a tree\\nexport function getFirstLevelDirectories(tree: TreeNode[]): string[] {\\n  return tree\\n    .filter((node) => node.type === "directory" && node.depth === 0)\\n    .map((node) => node.path);\\n}\\n\',\n    size: 2632,\n    dependents: [\n      {\n        name: "use-file-tree.ts",\n        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/use-file-tree.ts",\n      },\n    ],\n  },\n];\n',
    size: 93383,
    dependents: [
      {
        name: "use-repo-connection.ts",
        path: "ui/src/hooks/use-repo-connection.ts",
      },
    ],
  },
  {
    path: "ui/src/components/stepper-navigation-buttons/index.ts",
    name: "index.ts",
    content:
      'export { StepperNavigationButtons } from "./stepper-navigation-buttons";\n',
    size: 73,
    dependents: [
      {
        name: "files.mock.ts",
        path: "ui/src/mocks/files.mock.ts",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
    name: "step-one-upload-files.tsx",
    content:
      '// # 7. Main Step One Upload Files Component\n// Orchestrates the file upload and selection process with repository connection\n\nimport { Title, Text } from "@mantine/core";\nimport { useCallback } from "react";\nimport { type UseRepoConnectionReturn } from "src/hooks/use-repo-connection";\n\n// # 7.1 Extracted Component Imports\nimport { ConnectionForm } from "src/routes/(generate-tests)/-components/step-one-upload-files/connection-form";\nimport { RepositoryHeader } from "src/routes/(generate-tests)/-components/step-one-upload-files/repository-header";\nimport { FileTreeDisplay } from "src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display";\nimport type { TreeNode } from "./tree-item";\n\n// # 7.2 Component Props Interface\ninterface StepOneUploadFilesProps {\n  repoConnectionData: UseRepoConnectionReturn;\n  repoUrl: string;\n  setRepoUrl: (repoUrl: string) => void;\n  accessToken: string;\n  setAccessToken: (accessToken: string) => void;\n  fileTree: TreeNode[];\n  expandedDirectories: Set<string>;\n  featureName: string;\n  setFeatureName: (featureName: string) => void;\n  toggleDirectoryExpansion: (path: string) => void;\n}\n\n// # 7.3 Main Component Implementation\n// Orchestrates the complete file upload and selection workflow\nexport function StepOneUploadFiles({\n  repoConnectionData,\n  repoUrl,\n  setRepoUrl,\n  accessToken,\n  setAccessToken,\n  fileTree,\n  expandedDirectories,\n  featureName,\n  setFeatureName,\n  toggleDirectoryExpansion,\n}: StepOneUploadFilesProps) {\n  // # 7.3.2 Repository Connection Data\n  const {\n    connection,\n    isConnected,\n    isConnecting,\n    connectionError,\n    repoFiles,\n    isLoadingFiles,\n    fileLoadError,\n    selectedFiles,\n    loadingFiles,\n    connectToRepo,\n    disconnect,\n    loadRepoFiles,\n    toggleFileSelection,\n    selectFileWithDependencies,\n  } = repoConnectionData;\n\n  // # 7.3.5 Event Handlers (Memoized to prevent unnecessary re-renders)\n\n  // # 7.3.5.1 Connection Handlers\n  const handleConnect = useCallback(async () => {\n    if (!repoUrl.trim() || !accessToken.trim()) {\n      return;\n    }\n    await connectToRepo(repoUrl.trim(), accessToken.trim());\n  }, [repoUrl, accessToken, connectToRepo]);\n\n  const handleDisconnect = useCallback(() => {\n    disconnect();\n    setRepoUrl("");\n    setAccessToken("");\n  }, [disconnect, setRepoUrl, setAccessToken]);\n\n  // # 7.3.5.2 File Management Handlers\n  const handleLoadFiles = useCallback(() => {\n    loadRepoFiles();\n  }, [loadRepoFiles]);\n\n  // # 7.3.5.3 Feature Name Handler\n  const handleFeatureNameChange = useCallback((value: string) => {\n    setFeatureName(value);\n  }, []);\n\n  // # 7.3.6 Conditional Rendering\n\n  // # 7.3.6.1 Connection Form State\n  if (!isConnected) {\n    return (\n      <ConnectionForm\n        repoUrl={repoUrl}\n        accessToken={accessToken}\n        isConnecting={isConnecting}\n        connectionError={connectionError}\n        onRepoUrlChange={setRepoUrl}\n        onAccessTokenChange={setAccessToken}\n        onConnect={handleConnect}\n      />\n    );\n  }\n\n  // # 7.3.6.2 Connected State\n  return (\n    <div className="gap-lg">\n      {/* # 7.3.6.2.1 Page Header */}\n      <div className="text-center">\n        <Title order={1} size="h2" className="mb-md">\n          Repository Connected\n        </Title>\n        <Text size="lg" className="text-gray-600">\n          Select the files you want to analyze from {connection?.owner}/\n          {connection?.repo}\n        </Text>\n      </div>\n\n      {/* # 7.3.6.2.2 Repository Management */}\n      <RepositoryHeader\n        connection={connection}\n        isLoadingFiles={isLoadingFiles}\n        onRefresh={handleLoadFiles}\n        onDisconnect={handleDisconnect}\n      />\n\n      {/* # 7.3.6.2.3 File Tree Display */}\n      <FileTreeDisplay\n        repoFiles={repoFiles}\n        selectedFiles={selectedFiles}\n        fileTree={fileTree}\n        isLoadingFiles={isLoadingFiles}\n        fileLoadError={fileLoadError}\n        loadingFiles={loadingFiles}\n        expandedDirectories={expandedDirectories}\n        featureName={featureName}\n        onLoadFiles={handleLoadFiles}\n        onToggleExpanded={toggleDirectoryExpansion}\n        onToggleSelection={toggleFileSelection}\n        onSelectWithDependencies={selectFileWithDependencies}\n        onFeatureNameChange={handleFeatureNameChange}\n      />\n    </div>\n  );\n}\n',
    size: 4321,
    dependents: [
      {
        name: "files.mock.ts",
        path: "ui/src/mocks/files.mock.ts",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/connection-form.tsx",
    name: "connection-form.tsx",
    content:
      '// # 4. Repository Connection Form Component\n// Handles GitHub repository authentication and connection\n\nimport {\n  Stack,\n  Box,\n  Title,\n  Text,\n  TextInput,\n  PasswordInput,\n  Button,\n  Alert,\n  Paper,\n  Group,\n} from "@mantine/core";\nimport { IconBrandGithub, IconAlertCircle } from "@tabler/icons-react";\n\n// # 4.1 Component Props Interface\ninterface ConnectionFormProps {\n  repoUrl: string;\n  accessToken: string;\n  isConnecting: boolean;\n  connectionError: string | null;\n  onRepoUrlChange: (url: string) => void;\n  onAccessTokenChange: (token: string) => void;\n  onConnect: () => void;\n}\n\n// # 4.2 Main Connection Form Component\n// Provides UI for GitHub repository connection with validation and error handling\nexport function ConnectionForm({\n  repoUrl,\n  accessToken,\n  isConnecting,\n  connectionError,\n  onRepoUrlChange,\n  onAccessTokenChange,\n  onConnect,\n}: ConnectionFormProps) {\n  // # 4.2.1 Form Validation\n  const isFormValid = repoUrl.trim() && accessToken.trim();\n\n  return (\n    <Stack className="gap-lg">\n      {/* # 4.2.2 Header Section */}\n      <Box className="text-center">\n        <Title order={1} size="h2" className="mb-md">\n          What\'s in my repo?\n        </Title>\n        <Text className="text-gray-600">\n          Connect your repository to generate natural language report on\n          selected files\n        </Text>\n      </Box>\n\n      {/* # 4.2.3 Connection Form */}\n      <Paper className="border-gray-200 rounded-md p-xl">\n        <Stack className="gap-md">\n          {/* # 4.2.3.1 Form Header */}\n          <Group className="gap-xs">\n            <IconBrandGithub size={24} />\n            <Title order={3} size="h4">\n              Connect Your Repository\n            </Title>\n          </Group>\n\n          {/* # 4.2.3.2 Form Description */}\n          <Text size="sm" className="text-gray-600">\n            Connect to your GitHub repository (including private repos) to\n            select and analyze your code files.\n          </Text>\n\n          {/* # 4.2.3.3 Repository URL Input */}\n          <TextInput\n            label="Repository URL"\n            placeholder="https://github.com/username/repository or git@github.com:username/repository.git"\n            value={repoUrl}\n            onChange={(e) => onRepoUrlChange(e.currentTarget.value)}\n            required\n          />\n\n          {/* # 4.2.3.4 Access Token Input */}\n          <PasswordInput\n            label="Personal Access Token"\n            placeholder="Your GitHub personal access token"\n            description="Create a token at https://github.com/settings/tokens with \'repo\' scope for private repositories"\n            value={accessToken}\n            onChange={(e) => onAccessTokenChange(e.currentTarget.value)}\n            required\n          />\n\n          {/* # 4.2.3.5 Error Display */}\n          {connectionError && (\n            <Alert\n              icon={<IconAlertCircle size="1rem" />}\n              title="Connection Error"\n              color="red"\n            >\n              {connectionError}\n            </Alert>\n          )}\n\n          {/* # 4.2.3.6 Connect Button */}\n          <Button\n            onClick={onConnect}\n            loading={isConnecting}\n            disabled={!isFormValid}\n            leftSection={<IconBrandGithub size="1rem" />}\n          >\n            {isConnecting ? "Connecting..." : "Connect Repository"}\n          </Button>\n        </Stack>\n      </Paper>\n    </Stack>\n  );\n}\n',
    size: 3400,
    dependents: [
      {
        name: "step-one-upload-files.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/repository-header.tsx",
    name: "repository-header.tsx",
    content:
      '// # 5. Repository Header Component\n// Displays connection status and provides repository management controls\n\nimport { Paper, Group, Text, Button, ActionIcon, Tooltip } from "@mantine/core";\nimport { IconCheck, IconX, IconRefresh } from "@tabler/icons-react";\nimport type { RepoConnection } from "src/types/repo";\n\n// # 5.1 Component Props Interface\ninterface RepositoryHeaderProps {\n  connection: RepoConnection | null;\n  isLoadingFiles: boolean;\n  onRefresh: () => void;\n  onDisconnect: () => void;\n}\n\n// # 5.2 Main Repository Header Component\n// Shows connected repository info and provides tree management controls\nexport function RepositoryHeader({\n  connection,\n  isLoadingFiles,\n  onRefresh,\n  onDisconnect,\n}: RepositoryHeaderProps) {\n  return (\n    <Paper className="border-gray-200 rounded-md p-md">\n      <Group className="justify-between">\n        {/* # 5.2.1 Connection Status */}\n        <Group className="gap-xs">\n          <IconCheck size="1rem" color="green" />\n          <Text size="sm" className="font-medium">\n            Connected to {connection?.owner}/{connection?.repo}\n          </Text>\n        </Group>\n\n        {/* # 5.2.2 Action Controls */}\n        <Group className="gap-xs">\n          {/* # 5.2.2.2 Refresh Control */}\n          <Tooltip label="Refresh file list">\n            <ActionIcon\n              variant="light"\n              onClick={onRefresh}\n              loading={isLoadingFiles}\n            >\n              <IconRefresh size="1rem" />\n            </ActionIcon>\n          </Tooltip>\n\n          {/* # 5.2.2.3 Disconnect Control */}\n          <Button\n            size="xs"\n            variant="subtle"\n            color="red"\n            onClick={onDisconnect}\n            leftSection={<IconX size="1rem" />}\n          >\n            Disconnect\n          </Button>\n        </Group>\n      </Group>\n    </Paper>\n  );\n}\n',
    size: 1857,
    dependents: [
      {
        name: "step-one-upload-files.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
      },
    ],
  },
  {
    path: "ui/src/types/repo.ts",
    name: "repo.ts",
    content:
      '// Repository connection types\nexport interface RepoConnection {\n  provider: "github" | "gitlab" | "bitbucket";\n  url: string;\n  token: string;\n  owner: string;\n  repo: string;\n}\n\nexport interface RepoFile {\n  path: string;\n  name: string;\n  type: "file" | "dir";\n  size?: number;\n  content?: string;\n  sha?: string;\n}\n\nexport interface RepoFileTree {\n  path: string;\n  mode: string;\n  type: "blob" | "tree";\n  sha: string;\n  size?: number;\n  url: string;\n}\n\nexport interface SelectedRepoFile {\n  path: string;\n  name: string;\n  content: string;\n  size: number;\n  dependents?: {\n    name: string;\n    path: string;\n  }[];\n}\n\n// API Response types\nexport interface GitHubContent {\n  name: string;\n  path: string;\n  sha: string;\n  size: number;\n  url: string;\n  html_url: string;\n  git_url: string;\n  download_url: string;\n  type: "file" | "dir";\n  content?: string;\n  encoding?: string;\n}\n\nexport interface GitHubTreeResponse {\n  sha: string;\n  url: string;\n  tree: RepoFileTree[];\n  truncated: boolean;\n}\n',
    size: 1005,
    dependents: [
      {
        name: "repository-header.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/repository-header.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display.tsx",
    name: "file-tree-display.tsx",
    content:
      '// # 6. File Tree Display Component\n// Handles the display of file tree structure with loading and error states\n\nimport React, { useMemo } from "react";\nimport { Box, Text, Loader, Alert, Button, TextInput } from "@mantine/core";\nimport { IconAlertCircle } from "@tabler/icons-react";\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\nimport { TreeItem, type TreeNode } from "./tree-item";\n\n// # 6.1 Component Props Interface\ninterface FileTreeDisplayProps {\n  repoFiles: RepoFile[];\n  selectedFiles: SelectedRepoFile[];\n  fileTree: TreeNode[];\n  isLoadingFiles: boolean;\n  fileLoadError: string | null;\n  loadingFiles: Set<string>;\n  expandedDirectories: Set<string>;\n  featureName: string;\n  onLoadFiles: () => void;\n  onToggleExpanded: (path: string) => void;\n  onToggleSelection: (file: RepoFile) => void;\n  onSelectWithDependencies: (file: RepoFile) => void;\n  onFeatureNameChange: (value: string) => void;\n}\n\n// # 6.2 Main File Tree Display Component\n// Manages different display states and renders the tree structure\nexport const FileTreeDisplay = React.memo(function FileTreeDisplay({\n  repoFiles,\n  selectedFiles,\n  fileTree,\n  isLoadingFiles,\n  fileLoadError,\n  loadingFiles,\n  expandedDirectories,\n  featureName,\n  onLoadFiles,\n  onToggleExpanded,\n  onToggleSelection,\n  onSelectWithDependencies,\n  onFeatureNameChange,\n}: FileTreeDisplayProps) {\n  // # 6.2.1 Render Tree Function\n  // Creates TreeItem components for each root node (memoized to prevent recreation)\n  const renderedTree = useMemo(() => {\n    return fileTree.map((node) => (\n      <TreeItem\n        key={node.path}\n        node={node}\n        expandedDirectories={expandedDirectories}\n        selectedFiles={selectedFiles}\n        loadingFiles={loadingFiles}\n        onToggleExpanded={onToggleExpanded}\n        onToggleSelection={onToggleSelection}\n        onSelectWithDependencies={onSelectWithDependencies}\n      />\n    ));\n  }, [\n    fileTree,\n    expandedDirectories,\n    selectedFiles,\n    loadingFiles,\n    onToggleExpanded,\n    onToggleSelection,\n    onSelectWithDependencies,\n  ]);\n\n  return (\n    <>\n      {/* # 6.2.2 Empty State - No Files Loaded */}\n      {!repoFiles.length && !isLoadingFiles && !fileLoadError && (\n        <Box className="my-xl text-center">\n          <Text className="text-gray-600 mb-md" size="sm">\n            Click "Load Files" to browse your repository files\n          </Text>\n          <Button onClick={onLoadFiles} variant="light">\n            Load Files\n          </Button>\n        </Box>\n      )}\n\n      {/* # 6.2.3 Loading State */}\n      {isLoadingFiles && (\n        <Box className="my-xl text-center">\n          <Loader size="sm" className="mb-md" />\n          <Text size="sm" className="text-gray-600">\n            Loading repository files...\n          </Text>\n        </Box>\n      )}\n\n      {/* # 6.2.4 Error State */}\n      {fileLoadError && (\n        <Alert\n          icon={<IconAlertCircle size="1rem" />}\n          title="Error Loading Files"\n          color="red"\n          className="mb-md"\n        >\n          {fileLoadError}\n        </Alert>\n      )}\n\n      {/* # 6.2.5 Files Display */}\n      {repoFiles.length > 0 && (\n        <div>\n          {/* # 6.2.5.0 Feature Name Input */}\n          <TextInput\n            label="Feature Name"\n            description="The feature you are doing the handoff for"\n            value={featureName}\n            onChange={(event) => onFeatureNameChange(event.currentTarget.value)}\n            placeholder="Enter feature name..."\n          />\n\n          {/* # 6.2.5.1 File Count Summary */}\n          <Text size="sm" className="text-gray-600 mt-md mb-xs text-xs">\n            {selectedFiles.length} of {repoFiles.length} files selected â€¢ Only\n            JavaScript/TypeScript files are shown\n          </Text>\n\n          {/* # 6.2.5.2 Scrollable Tree Container */}\n          <div className="h-[400px] overflow-y-auto flex flex-col gap-xs">\n            {renderedTree}\n          </div>\n        </div>\n      )}\n    </>\n  );\n});\n',
    size: 4013,
    dependents: [
      {
        name: "step-one-upload-files.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/tree-item.tsx",
    name: "tree-item.tsx",
    content:
      '// # 1. Tree Item Component\n// This component renders individual nodes in the file tree structure\n\nimport React, { useCallback, useMemo } from "react";\nimport { Checkbox, ActionIcon, Collapse, Loader } from "@mantine/core";\nimport clsx from "clsx";\nimport {\n  IconFile,\n  IconFolder,\n  IconFolderOpen,\n  IconChevronRight,\n  IconChevronDown,\n  IconNetworkOff,\n} from "@tabler/icons-react";\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\nimport styles from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-item.module.css";\n\n// # 1.1 TreeNode Interface\n// Represents a single node in the file tree structure\nexport interface TreeNode {\n  path: string;\n  name: string;\n  type: "file" | "directory";\n  file?: RepoFile;\n  children: TreeNode[];\n  depth: number;\n}\n\n// # 1.2 TreeItem Props Interface\ninterface TreeItemProps {\n  node: TreeNode;\n  expandedDirectories: Set<string>;\n  selectedFiles: SelectedRepoFile[];\n  loadingFiles: Set<string>;\n  onToggleExpanded: (path: string) => void;\n  onToggleSelection: (file: RepoFile) => void;\n  onSelectWithDependencies: (file: RepoFile) => void;\n}\n\n// # 1.3 Main TreeItem Component\n// Renders a single tree node with expand/collapse and selection functionality\nexport const TreeItem = React.memo(function TreeItem({\n  node,\n  expandedDirectories,\n  selectedFiles,\n  loadingFiles,\n  onToggleExpanded,\n  onToggleSelection,\n  onSelectWithDependencies,\n}: TreeItemProps) {\n  // # 1.3.1 Node State Calculations\n  const hasChildren = node.children.length > 0;\n  const isFile = node.type === "file";\n  const isExpanded = expandedDirectories.has(node.path);\n  const isSelected = node.file\n    ? selectedFiles.some((f) => f.path === node.file!.path)\n    : false;\n  const isLoading = node.file ? loadingFiles.has(node.file.path) : false;\n\n  // # 1.3.2 Click Handlers\n  // Handles clicks on files (selection) and directories (expand/collapse)\n  const handleClick = useCallback(() => {\n    if (isFile && node.file && !isLoading) {\n      onToggleSelection(node.file);\n    } else if (hasChildren) {\n      onToggleExpanded(node.path);\n    }\n  }, [\n    isFile,\n    node.file,\n    node.path,\n    isLoading,\n    hasChildren,\n    onToggleSelection,\n    onToggleExpanded,\n  ]);\n\n  // Handles "Select with Dependencies" button clicks\n  const handleSelectWithDependencies = useCallback(\n    (e: React.MouseEvent) => {\n      e.stopPropagation();\n      if (node.file && !isLoading) {\n        onSelectWithDependencies(node.file);\n      }\n    },\n    [node.file, isLoading, onSelectWithDependencies]\n  );\n\n  const paperStyle = useMemo(() => {\n    return {\n      "--node-depth-margin": `${node.depth * 20}px`,\n    } as React.CSSProperties;\n  }, [node.depth]);\n\n  return (\n    <div>\n      {/* # 1.3.3 Node Container */}\n      <div\n        className={`${styles.nodeContainer} ${\n          isFile && isSelected ? styles.selected : ""\n        } p-xs rounded-sm shadow-xs border border-gray-200`}\n        style={paperStyle}\n        onClick={handleClick}\n      >\n        <div className="flex gap-xs  justify-between">\n          {/* # 1.3.4 Left Content Group */}\n          <div\n            className={`${styles.contentGroup} items-center flex flex-1 gap-xs`}\n          >\n            {/* # 1.3.4.1 Expansion Controls */}\n            {!isFile && hasChildren && (\n              <ActionIcon\n                variant="transparent"\n                size="sm"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  onToggleExpanded(node.path);\n                }}\n              >\n                {isExpanded ? (\n                  <IconChevronDown size="0.8rem" />\n                ) : (\n                  <IconChevronRight size="0.8rem" />\n                )}\n              </ActionIcon>\n            )}\n            {!isFile && !hasChildren && (\n              <div className="w-5" /> // Spacer for alignment\n            )}\n\n            {/* # 1.3.4.2 File Selection Checkbox or Loading Spinner */}\n            {isFile ? (\n              <div className={`${styles.checkboxContainer} w-5 h-5`}>\n                {isLoading ? (\n                  <Loader size="xs" />\n                ) : (\n                  <Checkbox\n                    checked={isSelected}\n                    onChange={() => {}} // Controlled by parent click\n                    size="sm"\n                  />\n                )}\n              </div>\n            ) : null}\n\n            {/* # 1.3.4.3 Node Icon */}\n            {isFile ? (\n              <IconFile size="1rem" />\n            ) : (\n              <>\n                {isExpanded ? (\n                  <IconFolderOpen size="1rem" />\n                ) : (\n                  <IconFolder size="1rem" />\n                )}\n              </>\n            )}\n\n            {/* # 1.3.4.4 Node Name */}\n            <div className={styles.nodeNameContainer}>\n              <div\n                className={clsx(\n                  isFile ? "font-medium" : "text-gray-600",\n                  "text-sm select-none"\n                )}\n              >\n                {node.name}\n              </div>\n            </div>\n          </div>\n\n          {/* # 1.3.5 Right Content - File Actions */}\n          {isFile && (\n            <div className="flex items-center gap-xs">\n              {/* # 1.3.5.1 Select with Dependencies Button */}\n              <ActionIcon\n                variant="subtle"\n                size="sm"\n                color="blue"\n                onClick={handleSelectWithDependencies}\n                disabled={isLoading}\n                title="Select file with all its dependencies"\n              >\n                <IconNetworkOff size="0.8rem" />\n              </ActionIcon>\n\n              {/* # 1.3.5.2 File Size */}\n              {node.file?.size && (\n                <p className="text-gray-600 text-xs">\n                  {Math.round(node.file.size / 1024)}KB\n                </p>\n              )}\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* # 1.3.6 Children Container */}\n      {!isFile && hasChildren && (\n        <Collapse in={isExpanded} transitionDuration={0}>\n          <div className="mt-xs gap-xs flex flex-col">\n            {node.children.map((child) => (\n              <TreeItem\n                key={child.path}\n                node={child}\n                expandedDirectories={expandedDirectories}\n                selectedFiles={selectedFiles}\n                loadingFiles={loadingFiles}\n                onToggleExpanded={onToggleExpanded}\n                onToggleSelection={onToggleSelection}\n                onSelectWithDependencies={onSelectWithDependencies}\n              />\n            ))}\n          </div>\n        </Collapse>\n      )}\n    </div>\n  );\n});\n',
    size: 6699,
    dependents: [
      {
        name: "file-tree-display.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations.tsx",
    name: "step-two-describe-relations.tsx",
    content:
      'import { useState, useMemo } from "react";\nimport {\n  Stack,\n  Box,\n  Title,\n  Text,\n  Tabs,\n  Button,\n  Select,\n  Group,\n  Paper,\n  ActionIcon,\n  Space,\n} from "@mantine/core";\nimport { IconPlus, IconSparkles, IconTrash } from "@tabler/icons-react";\n// Use a more flexible file interface that works with both uploaded and repo files\ninterface FileWithPathLike {\n  path?: string;\n  name: string;\n  size?: number;\n  dependents?: {\n    name: string;\n    path: string;\n  }[];\n}\nimport { InteractiveCanvas } from "src/routes/(generate-tests)/-components/interactive-canvas/interactive-canvas";\nimport type { Dependency } from "src/hooks/use-dependencies";\nimport clsx from "clsx";\n\ninterface DependenciesData {\n  dependencies: Dependency[];\n  fileOptions: { value: string; label: string }[];\n  connectionOptions: { value: string; label: string }[];\n  edges: Array<{ id: string; from: string; to: string; description: string }>;\n  addDependency: () => void;\n  updateDependency: (\n    id: string,\n    field: keyof Dependency,\n    value: string\n  ) => void;\n  removeDependency: (id: string) => void;\n  generateDependencies: () => void;\n}\n\ninterface StepTwoDescribeRelationsProps {\n  files: FileWithPathLike[];\n  dependenciesData: DependenciesData;\n}\n\nexport function StepTwoDescribeRelations({\n  files,\n  dependenciesData,\n}: StepTwoDescribeRelationsProps) {\n  const [activeTab, setActiveTab] = useState<string>("describe");\n  const {\n    dependencies,\n    fileOptions,\n    connectionOptions,\n    edges,\n    addDependency,\n    updateDependency,\n    generateDependencies,\n    removeDependency,\n  } = dependenciesData;\n\n  // Calculate potential dependencies from file dependents\n  const potentialDependenciesCount = useMemo(() => {\n    let count = 0;\n    const existingPairs = new Set(\n      dependencies.map((dep) => `${dep.from}->${dep.to}`)\n    );\n\n    files.forEach((file) => {\n      const fileIdentifier = file.path || file.name;\n\n      if (file.dependents && file.dependents.length > 0) {\n        file.dependents.forEach((dependent) => {\n          const pairKey = `${dependent.path}->${fileIdentifier}`;\n          if (!existingPairs.has(pairKey)) {\n            count++;\n          }\n        });\n      }\n    });\n\n    return count;\n  }, [files, dependencies]);\n\n  return (\n    <Stack className="gap-lg">\n      <Box className="text-center">\n        <Title order={2} className="mb-md">\n          Configure File Relationships\n        </Title>\n        <Text size="lg" className="text-gray-600">\n          Describe file relationships or visualize them interactively\n        </Text>\n      </Box>\n\n      {files.length > 0 ? (\n        <Tabs\n          value={activeTab}\n          onChange={(value) => setActiveTab(value || "describe")}\n        >\n          <Tabs.List grow>\n            <Tabs.Tab value="describe">Describe</Tabs.Tab>\n            <Tabs.Tab value="visualize">Visualize</Tabs.Tab>\n          </Tabs.List>\n\n          <Space h="md" />\n\n          <Tabs.Panel value="describe">\n            <Stack className="gap-md">\n              <Group className="justify-between items-center">\n                <Text size="lg" className="font-medium">\n                  Dependencies\n                </Text>\n                <Group gap="xs">\n                  <Button\n                    leftSection={<IconSparkles size={16} />}\n                    onClick={generateDependencies}\n                    variant="light"\n                  >\n                    Generate{" "}\n                    {potentialDependenciesCount > 0 &&\n                      `(${potentialDependenciesCount})`}\n                  </Button>\n                  <Button\n                    leftSection={<IconPlus size={16} />}\n                    onClick={addDependency}\n                    variant="light"\n                  >\n                    Add\n                  </Button>\n                </Group>\n              </Group>\n\n              {dependencies.length === 0 ? (\n                <Paper className="border-gray-200 rounded-md p-lg">\n                  <Text className="text-center text-gray-600">\n                    No dependencies defined yet.\n                    {potentialDependenciesCount > 0\n                      ? ` Click "Generate" to auto-create ${potentialDependenciesCount} dependencies from file imports, or "Add" to create manually.`\n                      : \' Click "Add" to create dependencies manually, or use "Select with Dependencies" in step 1 to auto-detect relationships.\'}\n                  </Text>\n                </Paper>\n              ) : (\n                <Stack className="gap-sm max-h-[400px] overflow-y-auto">\n                  {dependencies.map((dependency) => (\n                    <Paper\n                      key={dependency.id}\n                      className="border-gray-200 rounded-md p-md"\n                    >\n                      <div className="flex justify-between flex-end items-center">\n                        <div className="flex flex-1 gap-xs flex-end wrap-nowrap">\n                          <Select\n                            label="From"\n                            labelProps={{\n                              className: "text-gray-600 text-xs",\n                            }}\n                            placeholder="Select file"\n                            data={fileOptions}\n                            value={dependency.from}\n                            comboboxProps={{\n                              width: "max-content",\n                              position: "bottom-start",\n                              middlewares: { flip: false, shift: false },\n                            }}\n                            onChange={(value) =>\n                              updateDependency(\n                                dependency.id,\n                                "from",\n                                value || ""\n                              )\n                            }\n                          />\n                          <Select\n                            label="Connection"\n                            data={connectionOptions}\n                            value={dependency.connection}\n                            labelProps={{\n                              className: "text-gray-600 text-xs",\n                            }}\n                            onChange={(value) =>\n                              updateDependency(\n                                dependency.id,\n                                "connection",\n                                value || "uses"\n                              )\n                            }\n                          />\n                          <Select\n                            label="To"\n                            placeholder="Select file"\n                            data={fileOptions}\n                            value={dependency.to}\n                            labelProps={{\n                              className: "text-gray-600 text-xs",\n                            }}\n                            comboboxProps={{\n                              width: "max-content",\n                              position: "bottom-end",\n                              middlewares: { flip: false, shift: false },\n                            }}\n                            onChange={(value) =>\n                              updateDependency(dependency.id, "to", value || "")\n                            }\n                          />\n                        </div>\n                        <div\n                          className={clsx(Select.classes.wrapper, "self-end")}\n                        >\n                          <Box className="flex items-center h-[var(--input-height)]">\n                            <ActionIcon\n                              variant="subtle"\n                              color="red"\n                              onClick={() => removeDependency(dependency.id)}\n                            >\n                              <IconTrash size={16} />\n                            </ActionIcon>\n                          </Box>\n                        </div>\n                      </div>\n                    </Paper>\n                  ))}\n                </Stack>\n              )}\n            </Stack>\n          </Tabs.Panel>\n\n          <Tabs.Panel value="visualize">\n            <Stack className="gap-md">\n              <Text size="sm" className="text-gray-600">\n                Drag nodes to organize them. Use mouse wheel to zoom, click and\n                drag empty space to pan.\n              </Text>\n              <InteractiveCanvas files={files} edges={edges} />\n            </Stack>\n          </Tabs.Panel>\n        </Tabs>\n      ) : (\n        <Text className="text-center text-orange-500">\n          No files available. Please go back to step 1 and upload some files.\n        </Text>\n      )}\n    </Stack>\n  );\n}\n',
    size: 8786,
    dependents: [
      {
        name: "files.mock.ts",
        path: "ui/src/mocks/files.mock.ts",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/interactive-canvas/interactive-canvas.tsx",
    name: "interactive-canvas.tsx",
    content:
      '/* eslint-disable react-refresh/only-export-components */\nimport { useRef, useState, useMemo, useEffect } from "react";\nimport { Box } from "@mantine/core";\n// Make the canvas work with any file-like object that has a name and optionally a path\ninterface FileWithName {\n  name: string;\n  path?: string;\n}\nimport * as d3 from "d3";\n\n// ## 1. Type Definitions and Interfaces\n// ### 1.1. Point interface for coordinates\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n// ### 1.2. Node position interface (SVG coordinate space)\nexport interface NodePosition {\n  x: number;\n  y: number;\n}\n\n// ### 1.3. File node data interface\ninterface FileNodeData {\n  id: string;\n  name: string;\n  displayText: string;\n  width: number;\n  position: NodePosition;\n}\n\n// ### 1.4. Edge interface for connections between nodes\nexport interface Edge {\n  id: string;\n  from: string;\n  to: string;\n  description: string;\n  analysis?: string; // Analysis text for dependency relationship\n}\n\n// ### 1.5. Tooltip state interface\nexport interface TooltipState {\n  visible: boolean;\n  type: "node" | "edge" | null;\n  nodeId: string | null;\n  edgeId: string | null;\n  position: Point;\n  annotations: string[];\n  analysis: string | null;\n}\n\n// ### 1.6. Canvas state interface\nexport interface CanvasState {\n  zoom: number;\n  pan: Point;\n  selectedNodeId: string | null;\n  isDragging: boolean;\n  dragType: "canvas" | "node" | null;\n  draggedNodeId: string | null;\n  dragStartPoint: Point | null;\n  tooltip: TooltipState;\n}\n\n// ### 1.7. Interactive canvas component props\ninterface InteractiveCanvasProps {\n  files: FileWithName[];\n  edges?: Edge[];\n  annotations?: Record<string, string[]>; // Map file paths to annotations\n}\n\n// ## 2. Constants and Configuration\nconst MIN_NODE_WIDTH = 120;\nconst NODE_HEIGHT = 60;\nconst NODE_PADDING = 20; // Padding inside the node for text\nconst GRID_SPACING = 200; // Increased for variable width nodes\nexport const MIN_ZOOM = 0.1;\nexport const MAX_ZOOM = 3;\n\n// ## 2.5. Helper Functions for Text Measurement\nfunction calculateTextWidth(text: string, fontSize: number = 12): number {\n  // Create a temporary canvas to measure text width\n  const canvas = document.createElement("canvas");\n  const context = canvas.getContext("2d");\n  if (!context) return MIN_NODE_WIDTH;\n\n  context.font = `${fontSize}px var(--mantine-font-family, \'Inter\', sans-serif)`;\n  const metrics = context.measureText(text);\n  canvas.remove();\n\n  // Return width plus padding, with minimum width\n  return Math.max(MIN_NODE_WIDTH, metrics.width + NODE_PADDING * 2);\n}\n\n// ## 3. Canvas Action Functions - Pure functions for testability\n\n// ### 3.1. dragCanvas - Pan the canvas view\nexport function dragCanvas(\n  state: CanvasState,\n  startPoint: Point,\n  currentPoint: Point\n): CanvasState {\n  // #### 3.1.1. Calculate movement delta\n  const deltaX = currentPoint.x - startPoint.x;\n  const deltaY = currentPoint.y - startPoint.y;\n\n  // #### 3.1.2. Return new state with updated pan position\n  return {\n    ...state,\n    pan: {\n      x: state.pan.x + deltaX,\n      y: state.pan.y + deltaY,\n    },\n  };\n}\n\n// ### 3.2. zoom - Zoom in/out at a specific point\nexport function zoom(\n  state: CanvasState,\n  zoomPoint: Point,\n  zoomDelta: number\n): CanvasState {\n  // #### 3.2.1. Calculate new zoom level within bounds\n  const newZoom = Math.max(\n    MIN_ZOOM,\n    Math.min(MAX_ZOOM, state.zoom * (1 + zoomDelta))\n  );\n\n  // #### 3.2.2. Early return if zoom didn\'t change\n  if (newZoom === state.zoom) {\n    return state;\n  }\n\n  // #### 3.2.3. Calculate zoom ratio and adjust pan to zoom at point\n  const zoomRatio = newZoom / state.zoom;\n\n  return {\n    ...state,\n    zoom: newZoom,\n    pan: {\n      x: zoomPoint.x - (zoomPoint.x - state.pan.x) * zoomRatio,\n      y: zoomPoint.y - (zoomPoint.y - state.pan.y) * zoomRatio,\n    },\n  };\n}\n\n// ### 3.3. dragNode - Move a specific node\nexport function dragNode(\n  nodePositions: Record<string, NodePosition>,\n  nodeId: string,\n  startPoint: Point,\n  currentPoint: Point,\n  canvasZoom: number,\n  initialNodePosition: NodePosition\n): Record<string, NodePosition> {\n  // #### 3.3.1. Calculate delta in screen space\n  const screenDeltaX = currentPoint.x - startPoint.x;\n  const screenDeltaY = currentPoint.y - startPoint.y;\n\n  // #### 3.3.2. Convert to SVG space (account for zoom)\n  const svgDeltaX = screenDeltaX / canvasZoom;\n  const svgDeltaY = screenDeltaY / canvasZoom;\n\n  // #### 3.3.3. Return new node positions with updated node\n  return {\n    ...nodePositions,\n    [nodeId]: {\n      x: initialNodePosition.x + svgDeltaX,\n      y: initialNodePosition.y + svgDeltaY,\n    },\n  };\n}\n\n// ### 3.4. clickNode - Handle node selection/interaction\nexport function clickNode(state: CanvasState, nodeId: string): CanvasState {\n  return {\n    ...state,\n    selectedNodeId: state.selectedNodeId === nodeId ? null : nodeId,\n  };\n}\n\n// ### 3.5. toggleNodeTooltip - Show/hide tooltip with annotations for nodes\nexport function toggleNodeTooltip(\n  state: CanvasState,\n  nodeId: string,\n  position: Point,\n  annotations: string[]\n): CanvasState {\n  const isCurrentlyVisible =\n    state.tooltip.visible &&\n    state.tooltip.type === "node" &&\n    state.tooltip.nodeId === nodeId;\n\n  return {\n    ...state,\n    tooltip: {\n      visible: !isCurrentlyVisible,\n      type: isCurrentlyVisible ? null : "node",\n      nodeId: isCurrentlyVisible ? null : nodeId,\n      edgeId: null,\n      position,\n      annotations: isCurrentlyVisible ? [] : annotations,\n      analysis: null,\n    },\n  };\n}\n\n// ### 3.6. showEdgeTooltip - Show tooltip with analysis for edges\nexport function showEdgeTooltip(\n  state: CanvasState,\n  edgeId: string,\n  position: Point,\n  analysis: string\n): CanvasState {\n  return {\n    ...state,\n    tooltip: {\n      visible: true,\n      type: "edge",\n      nodeId: null,\n      edgeId,\n      position,\n      annotations: [],\n      analysis,\n    },\n  };\n}\n\n// ### 3.7. hideTooltip - Hide tooltip\nexport function hideTooltip(state: CanvasState): CanvasState {\n  return {\n    ...state,\n    tooltip: {\n      visible: false,\n      type: null,\n      nodeId: null,\n      edgeId: null,\n      position: { x: 0, y: 0 },\n      annotations: [],\n      analysis: null,\n    },\n  };\n}\n\n// ## 4. InteractiveCanvas Component\nexport function InteractiveCanvas({\n  files,\n  edges = [],\n  annotations = {},\n}: InteractiveCanvasProps) {\n  // ### 4.1. State Management\n  // #### 4.1.1. Canvas state (zoom, pan, selection, dragging, tooltip)\n  const [canvasState, setCanvasState] = useState<CanvasState>({\n    zoom: 1,\n    pan: { x: 0, y: 0 },\n    selectedNodeId: null,\n    isDragging: false,\n    dragType: null,\n    draggedNodeId: null,\n    dragStartPoint: null,\n    tooltip: {\n      visible: false,\n      type: null,\n      nodeId: null,\n      edgeId: null,\n      position: { x: 0, y: 0 },\n      annotations: [],\n      analysis: null,\n    },\n  });\n\n  // #### 4.1.2. Node positions state\n  const [nodePositions, setNodePositions] = useState<\n    Record<string, NodePosition>\n  >({});\n\n  // ### 4.2. References for D3 Operations\n  const containerRef = useRef<HTMLDivElement>(null);\n  const svgRef = useRef<SVGSVGElement>(null);\n  const gRef = useRef<SVGGElement>(null);\n  const zoomBehaviorRef = useRef<d3.ZoomBehavior<\n    SVGSVGElement,\n    unknown\n  > | null>(null);\n  const initialNodePositionRef = useRef<NodePosition>({ x: 0, y: 0 });\n\n  // #### 4.2.1. State refs for drag callbacks (to avoid stale closures)\n  const canvasStateRef = useRef(canvasState);\n  const nodePositionsRef = useRef(nodePositions);\n\n  // ### 4.3. Sync Effects - Keep refs in sync with state\n  useEffect(() => {\n    canvasStateRef.current = canvasState;\n  }, [canvasState]);\n\n  useEffect(() => {\n    nodePositionsRef.current = nodePositions;\n  }, [nodePositions]);\n\n  // ### 4.4. Computed Data\n  // #### 4.4.1. Generate file nodes data with positions\n  const fileNodes = useMemo((): FileNodeData[] => {\n    return files.map((file, index) => {\n      const displayText = file.path || file.name;\n      const width = calculateTextWidth(displayText);\n      return {\n        id: `file-${index}`,\n        name: file.name,\n        displayText,\n        width,\n        position:\n          nodePositions[`file-${index}`] ||\n          calculateInitialPosition(index, files.length),\n      };\n    });\n  }, [files, nodePositions]);\n\n  // ### 4.5. Helper Functions\n  // #### 4.5.1. Calculate initial grid position for nodes\n  function calculateInitialPosition(\n    index: number,\n    totalFiles: number\n  ): NodePosition {\n    const nodesPerRow = Math.ceil(Math.sqrt(totalFiles));\n    const row = Math.floor(index / nodesPerRow);\n    const col = index % nodesPerRow;\n\n    return {\n      x: col * GRID_SPACING + MIN_NODE_WIDTH / 2,\n      y: row * GRID_SPACING + NODE_HEIGHT / 2,\n    };\n  }\n\n  // ### 4.6. Initialization Effects\n  // #### 4.6.1. Initialize node positions when files change\n  useEffect(() => {\n    const initialPositions: Record<string, NodePosition> = {};\n    files.forEach((_, index) => {\n      const nodeId = `file-${index}`;\n      if (!nodePositions[nodeId]) {\n        initialPositions[nodeId] = calculateInitialPosition(\n          index,\n          files.length\n        );\n      }\n    });\n\n    if (Object.keys(initialPositions).length > 0) {\n      setNodePositions((prev) => ({ ...prev, ...initialPositions }));\n    }\n  }, [files, nodePositions]);\n\n  // ### 4.7. D3 Setup Effects\n  // #### 4.7.1. Initialize SVG and setup D3 behaviors (only once)\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const container = d3.select(containerRef.current);\n\n    // ##### 4.7.1.1. Clear any existing content\n    container.selectAll("*").remove();\n\n    // ##### 4.7.1.2. Create SVG element\n    const svg = container\n      .append("svg")\n      .attr("width", "100%")\n      .attr("height", "100%")\n      .style("user-select", "none");\n\n    svgRef.current = svg.node();\n\n    // ##### 4.7.1.3. Create main group for zoom/pan transforms\n    const g = svg.append("g");\n    gRef.current = g.node();\n\n    // ##### 4.7.1.4. Setup grid pattern for visual grid background\n    const defs = svg.append("defs");\n    const pattern = defs\n      .append("pattern")\n      .attr("id", "grid")\n      .attr("width", 20)\n      .attr("height", 20)\n      .attr("patternUnits", "userSpaceOnUse");\n\n    pattern\n      .append("path")\n      .attr("d", "M 20 0 L 0 0 0 20")\n      .attr("fill", "none")\n      .attr("stroke", "var(--mantine-color-gray-2)")\n      .attr("stroke-width", 0.5)\n      .attr("opacity", 0.5);\n\n    // ##### 4.7.1.5. Add grid background rectangle\n    g.append("rect")\n      .attr("x", -2000)\n      .attr("y", -2000)\n      .attr("width", 4000)\n      .attr("height", 4000)\n      .attr("fill", "url(#grid)");\n\n    // ##### 4.7.1.6. Add arrow marker definition for edges\n    const arrowMarker = defs\n      .append("marker")\n      .attr("id", "arrow")\n      .attr("viewBox", "0 -5 10 10")\n      .attr("refX", 8)\n      .attr("refY", 0)\n      .attr("markerWidth", 6)\n      .attr("markerHeight", 6)\n      .attr("orient", "auto");\n\n    arrowMarker\n      .append("path")\n      .attr("d", "M0,-5L10,0L0,5")\n      .attr("fill", "var(--mantine-color-gray-6)");\n\n    // ##### 4.7.1.7. Setup zoom behavior - apply to SVG, not container\n    const zoomBehavior = d3\n      .zoom<SVGSVGElement, unknown>()\n      .scaleExtent([MIN_ZOOM, MAX_ZOOM])\n      .on("start", (event) => {\n        // Hide tooltip when starting canvas interaction\n        if (event.sourceEvent?.type === "mousedown") {\n          setCanvasState((prev) => hideTooltip(prev));\n        }\n      })\n      .on("zoom", (event) => {\n        const transform = event.transform;\n\n        // Update canvas state with new zoom/pan values\n        setCanvasState((prev) => ({\n          ...prev,\n          zoom: transform.k,\n          pan: { x: transform.x, y: transform.y },\n        }));\n\n        // Apply transform to the main group\n        g.attr("transform", transform.toString());\n      });\n\n    zoomBehaviorRef.current = zoomBehavior;\n\n    // ##### 4.7.1.8. Apply zoom behavior to SVG element for proper event handling\n    svg.call(zoomBehaviorRef.current);\n\n    // ##### 4.7.1.9. Sync initial state with D3 zoom\n    const initialTransform = d3.zoomIdentity\n      .translate(canvasState.pan.x, canvasState.pan.y)\n      .scale(canvasState.zoom);\n\n    svg.call(zoomBehavior.transform, initialTransform);\n\n    // ##### 4.7.1.10. Cleanup function to remove event listeners\n    return () => {\n      if (zoomBehaviorRef.current) {\n        svg.on(".zoom", null);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Remove dependencies to prevent recreation\n\n  // #### 4.5.2. Calculate edge connection points between nodes\n  const calculateEdgePoints = (\n    fromNode: FileNodeData,\n    toNode: FileNodeData\n  ) => {\n    const fromPos = fromNode.position;\n    const toPos = toNode.position;\n\n    // ##### 4.5.2.1. Calculate direction vector between nodes\n    const dx = toPos.x - fromPos.x;\n    const dy = toPos.y - fromPos.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // ##### 4.5.2.2. Handle case where nodes are at same position\n    if (distance === 0) {\n      return { x1: fromPos.x, y1: fromPos.y, x2: toPos.x, y2: toPos.y };\n    }\n\n    // ##### 4.5.2.3. Normalize direction vector to unit vector\n    const unitX = dx / distance;\n    const unitY = dy / distance;\n\n    // ##### 4.5.2.4. Calculate connection points at node edges using actual node dimensions\n    // From node: start from edge in direction of target\n    const fromRadius = Math.max(fromNode.width, NODE_HEIGHT) / 2;\n    const x1 = fromPos.x + unitX * fromRadius;\n    const y1 = fromPos.y + unitY * fromRadius;\n\n    // To node: end at edge from direction of source\n    const toRadius = Math.max(toNode.width, NODE_HEIGHT) / 2;\n    const x2 = toPos.x - unitX * toRadius;\n    const y2 = toPos.y - unitY * toRadius;\n\n    return { x1, y1, x2, y2 };\n  };\n\n  // ### 4.8. Rendering Effects\n  // #### 4.8.1. Render edges with D3\n  useEffect(() => {\n    if (!gRef.current) return;\n\n    const g = d3.select(gRef.current);\n\n    // ##### 4.8.1.1. Helper function to get node by ID\n    const getNodeById = (nodeId: string): FileNodeData | null => {\n      return fileNodes.find((n) => n.id === nodeId) || null;\n    };\n\n    // ##### 4.8.1.2. Filter valid edges (both from and to nodes exist)\n    const validEdges = edges.filter((edge) => {\n      const fromNode = getNodeById(edge.from);\n      const toNode = getNodeById(edge.to);\n      return fromNode && toNode;\n    });\n\n    // ##### 4.8.1.3. Data join for edges using D3 pattern\n    const edgeLines = g\n      .selectAll<SVGLineElement, Edge>("line.edge")\n      .data(validEdges, (d) => d.id);\n\n    // ##### 4.8.1.4. Enter selection for new edges\n    const enterEdges = edgeLines\n      .enter()\n      .append("line")\n      .attr("class", "edge")\n      .attr("stroke", "var(--mantine-color-gray-6)")\n      .attr("stroke-width", 2)\n      .attr("marker-end", "url(#arrow)")\n      .attr("opacity", 0.7);\n\n    // ##### 4.8.1.5. Merge enter and update selections\n    const allEdges = enterEdges.merge(edgeLines);\n\n    // ##### 4.8.1.5b. Apply click handlers and visual feedback to all edges\n    allEdges\n      .style("cursor", (d) => (d.analysis ? "pointer" : "default"))\n      .attr("stroke-width", (d) => (d.analysis ? 3 : 2))\n      .attr("opacity", (d) => (d.analysis ? 0.8 : 0.7))\n      .on("click", function (event, d) {\n        event.stopPropagation();\n\n        if (!d.analysis) return; // Only show tooltip if analysis exists\n\n        // Get click position for tooltip\n        const clickPosition: Point = {\n          x: event.clientX,\n          y: event.clientY,\n        };\n\n        setCanvasState((prev) =>\n          showEdgeTooltip(prev, d.id, clickPosition, d.analysis!)\n        );\n      })\n      .on("mouseenter", function (_event, d) {\n        if (d.analysis) {\n          d3.select(this).attr("stroke", "var(--mantine-color-green-5)");\n        }\n      })\n      .on("mouseleave", function (_event, d) {\n        if (d.analysis) {\n          d3.select(this).attr("stroke", "var(--mantine-color-gray-6)");\n        }\n      });\n\n    // ##### 4.8.1.6. Update edge positions with proper node-to-node connections\n    allEdges.each(function (d) {\n      const fromNode = getNodeById(d.from);\n      const toNode = getNodeById(d.to);\n\n      if (fromNode && toNode) {\n        const { x1, y1, x2, y2 } = calculateEdgePoints(fromNode, toNode);\n\n        d3.select(this)\n          .attr("x1", x1)\n          .attr("y1", y1)\n          .attr("x2", x2)\n          .attr("y2", y2);\n      }\n    });\n\n    // ##### 4.8.1.7. Remove edges that are no longer needed\n    edgeLines.exit().remove();\n\n    // ##### 4.8.1.8. Data join for edge labels\n    const edgeLabels = g\n      .selectAll<SVGTextElement, Edge>("text.edge-label")\n      .data(validEdges, (d) => d.id);\n\n    // ##### 4.8.1.9. Enter selection for new edge labels\n    const enterLabels = edgeLabels\n      .enter()\n      .append("text")\n      .attr("class", "edge-label")\n      .attr("text-anchor", "middle")\n      .attr("dominant-baseline", "middle")\n      .style("font-size", "10px")\n      .style("font-family", "var(--mantine-font-family)")\n      .style("fill", "var(--mantine-color-gray-7)")\n      .style("background", "white")\n      .style("pointer-events", "none");\n\n    // ##### 4.8.1.10. Merge enter and update selections for labels\n    const allLabels = enterLabels.merge(edgeLabels);\n\n    // ##### 4.8.1.11. Update edge label positions and text - position above the line\n    allLabels.each(function (d) {\n      const fromNode = getNodeById(d.from);\n      const toNode = getNodeById(d.to);\n\n      if (fromNode && toNode) {\n        const { x1, y1, x2, y2 } = calculateEdgePoints(fromNode, toNode);\n\n        // Calculate midpoint of the actual edge line\n        const midX = (x1 + x2) / 2;\n        const midY = (y1 + y2) / 2;\n\n        // Calculate perpendicular offset to position text above the line\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n          // Perpendicular vector (rotated 90 degrees)\n          const perpX = -dy / distance;\n          const perpY = dx / distance;\n\n          // Offset text above the line\n          const offsetDistance = 12; // pixels above the line\n          const textX = midX + perpX * offsetDistance;\n          const textY = midY + perpY * offsetDistance;\n\n          d3.select(this).attr("x", textX).attr("y", textY).text(d.description);\n        }\n      }\n    });\n\n    // ##### 4.8.1.12. Remove labels that are no longer needed\n    edgeLabels.exit().remove();\n  }, [edges, fileNodes, nodePositions]);\n\n  // #### 4.8.2. Render nodes with D3\n  useEffect(() => {\n    if (!gRef.current) return;\n\n    const g = d3.select(gRef.current);\n\n    // ##### 4.8.2.1. Setup drag behavior for nodes\n    const dragBehavior = d3\n      .drag<SVGGElement, FileNodeData>()\n      .on("start", (event, d) => {\n        // Prevent canvas zoom/pan while dragging nodes\n        event.sourceEvent.stopPropagation();\n\n        // Store initial position for the pure function\n        initialNodePositionRef.current = d.position;\n\n        // Store drag start point in screen coordinates\n        const startPoint = {\n          x: event.sourceEvent.clientX,\n          y: event.sourceEvent.clientY,\n        };\n\n        setCanvasState((prev) => ({\n          ...prev,\n          isDragging: true,\n          dragType: "node",\n          draggedNodeId: d.id,\n          dragStartPoint: startPoint,\n        }));\n      })\n      .on("drag", (event, d) => {\n        event.sourceEvent.stopPropagation();\n\n        // Get current state from refs to avoid stale closures\n        const currentCanvasState = canvasStateRef.current;\n        const currentNodePositions = nodePositionsRef.current;\n\n        if (!currentCanvasState.dragStartPoint) return;\n\n        // Get current mouse position in screen coordinates\n        const currentPoint: Point = {\n          x: event.sourceEvent.clientX,\n          y: event.sourceEvent.clientY,\n        };\n\n        // Use pure function to calculate new node positions\n        const newNodePositions = dragNode(\n          currentNodePositions,\n          d.id,\n          currentCanvasState.dragStartPoint,\n          currentPoint,\n          currentCanvasState.zoom,\n          initialNodePositionRef.current\n        );\n\n        setNodePositions(newNodePositions);\n      })\n      .on("end", (event, d) => {\n        event.sourceEvent.stopPropagation();\n\n        const currentCanvasState = canvasStateRef.current;\n\n        if (!currentCanvasState.dragStartPoint) {\n          // Reset state if no drag start point (error case)\n          setCanvasState((prev) => ({\n            ...prev,\n            isDragging: false,\n            dragType: null,\n            draggedNodeId: null,\n            dragStartPoint: null,\n          }));\n          return;\n        }\n\n        // Get end position in screen coordinates\n        const endPoint: Point = {\n          x: event.sourceEvent.clientX,\n          y: event.sourceEvent.clientY,\n        };\n\n        // Check if this was a click vs drag (movement threshold)\n        const isClick =\n          Math.abs(endPoint.x - currentCanvasState.dragStartPoint.x) < 5 &&\n          Math.abs(endPoint.y - currentCanvasState.dragStartPoint.y) < 5;\n\n        if (isClick) {\n          // Handle click - toggle node selection and show tooltip with annotations\n          const clickedFile = files.find(\n            (_, index) => `file-${index}` === d.id\n          );\n          const filePath = clickedFile?.path || clickedFile?.name || "";\n          const fileAnnotations = annotations[filePath] || [];\n\n          // Get click position in screen coordinates for tooltip positioning\n          const clickPosition: Point = {\n            x: endPoint.x,\n            y: endPoint.y,\n          };\n\n          const newCanvasState = clickNode(currentCanvasState, d.id);\n          const tooltipState = toggleNodeTooltip(\n            newCanvasState,\n            d.id,\n            clickPosition,\n            fileAnnotations\n          );\n\n          setCanvasState({\n            ...tooltipState,\n            isDragging: false,\n            dragType: null,\n            draggedNodeId: null,\n            dragStartPoint: null,\n          });\n        } else {\n          // Handle drag end - just reset drag state\n          setCanvasState((prev) => ({\n            ...prev,\n            isDragging: false,\n            dragType: null,\n            draggedNodeId: null,\n            dragStartPoint: null,\n          }));\n        }\n      });\n\n    // ##### 4.8.2.2. Data join for nodes using D3 pattern\n    const nodeGroups = g\n      .selectAll<SVGGElement, FileNodeData>("g.file-node")\n      .data(fileNodes, (d) => d.id);\n\n    // ##### 4.8.2.3. Enter selection for new nodes\n    const enterGroups = nodeGroups\n      .enter()\n      .append("g")\n      .attr("class", "file-node")\n      .style("cursor", "move")\n      .call(dragBehavior);\n\n    // ##### 4.8.2.4. Add rectangle shape to new node groups\n    enterGroups\n      .append("rect")\n      .attr("width", (d) => d.width)\n      .attr("height", NODE_HEIGHT)\n      .attr("rx", 8)\n      .attr("x", (d) => -d.width / 2)\n      .attr("y", -NODE_HEIGHT / 2);\n\n    // ##### 4.8.2.5. Add text labels to new node groups\n    enterGroups\n      .append("text")\n      .attr("text-anchor", "middle")\n      .attr("dominant-baseline", "middle")\n      .style("font-size", "12px")\n      .style("font-family", "var(--mantine-font-family)")\n      .style("font-weight", "500")\n      .style("pointer-events", "none")\n      .text((d) => d.displayText);\n\n    // ##### 4.8.2.6. Merge enter and update selections\n    const allGroups = enterGroups.merge(nodeGroups);\n\n    // ##### 4.8.2.7. Update node positions and dimensions\n    allGroups.attr(\n      "transform",\n      (d) => `translate(${d.position.x}, ${d.position.y})`\n    );\n\n    // Update rectangle dimensions for all nodes (including existing ones)\n    allGroups\n      .select("rect")\n      .attr("width", (d) => d.width)\n      .attr("x", (d) => -d.width / 2);\n\n    // Update text content for all nodes\n    allGroups.select("text").text((d) => d.displayText);\n\n    // ##### 4.8.2.8. Update visual states based on selection and drag\n    allGroups\n      .select("rect")\n      .attr("fill", (d) => {\n        if (canvasState.selectedNodeId === d.id)\n          return "var(--mantine-color-blue-2)";\n        return "var(--mantine-color-blue-1)";\n      })\n      .attr("stroke", (d) => {\n        if (canvasState.selectedNodeId === d.id)\n          return "var(--mantine-color-blue-6)";\n        return "var(--mantine-color-blue-3)";\n      })\n      .attr("stroke-width", (d) => {\n        if (canvasState.selectedNodeId === d.id) return 3;\n        return 1;\n      })\n      .style("opacity", (d) => {\n        if (canvasState.draggedNodeId === d.id) return 0.8;\n        return 1;\n      });\n\n    // ##### 4.8.2.9. Update text color\n    allGroups.select("text").attr("fill", "var(--mantine-color-blue-9)");\n\n    // ##### 4.8.2.10. Setup hover effects for interactive feedback\n    allGroups\n      .on("mouseenter", function (_event, d) {\n        if (canvasState.draggedNodeId !== d.id) {\n          d3.select(this)\n            .select("rect")\n            .attr("stroke", "var(--mantine-color-blue-4)")\n            .attr("stroke-width", 2);\n        }\n      })\n      .on("mouseleave", function (_event, d) {\n        if (canvasState.draggedNodeId !== d.id) {\n          const isSelected = canvasState.selectedNodeId === d.id;\n          d3.select(this)\n            .select("rect")\n            .attr(\n              "stroke",\n              isSelected\n                ? "var(--mantine-color-blue-6)"\n                : "var(--mantine-color-blue-3)"\n            )\n            .attr("stroke-width", isSelected ? 3 : 1);\n        }\n      });\n\n    // ##### 4.8.2.11. Remove nodes that are no longer needed\n    nodeGroups.exit().remove();\n  }, [fileNodes, canvasState, nodePositions]);\n\n  // ### 4.9. Tooltip Component\n  const TooltipComponent = () => {\n    if (!canvasState.tooltip.visible || !containerRef.current) return null;\n\n    const containerRect = containerRef.current.getBoundingClientRect();\n\n    // Position tooltip relative to the container, accounting for scroll\n    const tooltipStyle = {\n      position: "absolute" as const,\n      left: `${canvasState.tooltip.position.x - containerRect.left + 10}px`,\n      top: `${canvasState.tooltip.position.y - containerRect.top - 10}px`,\n      background: "var(--mantine-color-white)",\n      border: "1px solid var(--mantine-color-gray-3)",\n      borderRadius: "var(--mantine-radius-md)",\n      padding: "12px",\n      maxWidth: "350px",\n      boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",\n      zIndex: 1000,\n      fontSize: "12px",\n      lineHeight: "1.4",\n    };\n\n    const isNodeTooltip = canvasState.tooltip.type === "node";\n    const isEdgeTooltip = canvasState.tooltip.type === "edge";\n\n    return (\n      <div style={tooltipStyle}>\n        {isNodeTooltip && (\n          <>\n            <div\n              style={{\n                fontWeight: 600,\n                marginBottom: "8px",\n                color: "var(--mantine-color-blue-7)",\n              }}\n            >\n              File Annotations\n            </div>\n            {canvasState.tooltip.annotations.length > 0 ? (\n              <ul\n                style={{\n                  margin: 0,\n                  paddingLeft: "16px",\n                  color: "var(--mantine-color-gray-7)",\n                }}\n              >\n                {canvasState.tooltip.annotations.map((annotation, index) => (\n                  <li key={index} style={{ marginBottom: "4px" }}>\n                    {annotation}\n                  </li>\n                ))}\n              </ul>\n            ) : (\n              <div\n                style={{\n                  color: "var(--mantine-color-gray-5)",\n                  fontStyle: "italic",\n                }}\n              >\n                No annotations available for this file\n              </div>\n            )}\n          </>\n        )}\n\n        {isEdgeTooltip && (\n          <>\n            <div\n              style={{\n                fontWeight: 600,\n                marginBottom: "8px",\n                color: "var(--mantine-color-green-7)",\n              }}\n            >\n              Dependency Analysis\n            </div>\n            <div\n              style={{\n                color: "var(--mantine-color-gray-7)",\n                lineHeight: "1.5",\n              }}\n            >\n              {canvasState.tooltip.analysis}\n            </div>\n          </>\n        )}\n      </div>\n    );\n  };\n\n  // ### 4.10. Component Render - Container for D3 SVG canvas with tooltip\n  return (\n    <Box\n      style={{\n        position: "relative",\n        width: "100%",\n        height: 400,\n      }}\n    >\n      <Box\n        ref={containerRef}\n        style={{\n          width: "100%",\n          height: "100%",\n          border: "1px solid var(--mantine-color-gray-3)",\n          borderRadius: "var(--mantine-radius-md)",\n          overflow: "hidden",\n          // Dynamic cursor based on interaction state\n          cursor: canvasState.isDragging\n            ? canvasState.dragType === "canvas"\n              ? "grabbing"\n              : "move"\n            : "grab",\n        }}\n      />\n      <TooltipComponent />\n    </Box>\n  );\n}\n',
    size: 29332,
    dependents: [
      {
        name: "step-two-describe-relations.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-three-view-results/step-three-view-results.tsx",
    name: "step-three-view-results.tsx",
    content:
      'import { useState, useMemo } from "react";\nimport { Stack, Box, Title, Text, Tabs, Space } from "@mantine/core";\nimport type { GenerateReportResponse } from "handoff-server/schemas";\nimport { MarkdownRenderer } from "../../../../components/markdown-renderer";\nimport { TableOfContents } from "../../../../components/table-of-contents";\nimport {\n  InteractiveCanvas,\n  type Edge,\n} from "../interactive-canvas/interactive-canvas";\n\ntype StepThreeViewResultsProps = {\n  report?: GenerateReportResponse;\n};\n\nexport function StepThreeViewResults({ report }: StepThreeViewResultsProps) {\n  const [activeTab, setActiveTab] = useState<string>("report");\n\n  // Process report data for the graph visualization\n  const graphData = useMemo(() => {\n    if (!report?.files) {\n      return { files: [], edges: [], annotations: {} };\n    }\n\n    // Create files array for the canvas - use path as unique identifier\n    const files = report.files.map((file, index) => ({\n      name: file.name,\n      path: file.path,\n      id: `file-${index}`,\n    }));\n\n    // Create edges from dependents relationships\n    const edges: Edge[] = [];\n\n    report.files.forEach((file, fileIndex) => {\n      const fileId = `file-${fileIndex}`;\n\n      if (file.dependents && file.dependents.length > 0) {\n        file.dependents.forEach((dependent, depIndex) => {\n          // Find the dependent file\'s index to get its ID\n          const dependentFileIndex = report.files.findIndex(\n            (f) => f.path === dependent.path\n          );\n\n          if (dependentFileIndex !== -1) {\n            const dependentId = `file-${dependentFileIndex}`;\n            edges.push({\n              id: `edge-${fileIndex}-${dependentFileIndex}-${depIndex}`,\n              from: dependentId, // The dependent file points to this file\n              to: fileId,\n              description: "uses",\n              analysis: dependent.analysis, // Include analysis for edge tooltips\n            });\n          }\n        });\n      }\n    });\n\n    // Create annotations map from file path to annotations array\n    const annotations: Record<string, string[]> = {};\n    report.files.forEach((file) => {\n      if (file.annotations && file.annotations.length > 0) {\n        annotations[file.path] = file.annotations;\n      }\n    });\n\n    return { files, edges, annotations };\n  }, [report]);\n\n  return (\n    <Stack gap="lg">\n      <Box ta="center">\n        <Title order={2} mb="md">\n          Review Results\n        </Title>\n        <Text c="dimmed" size="lg">\n          Review and download your generated test cases\n        </Text>\n      </Box>\n\n      <Tabs\n        value={activeTab}\n        onChange={(value) => setActiveTab(value || "report")}\n      >\n        <Tabs.List grow>\n          <Tabs.Tab value="report">Report</Tabs.Tab>\n          <Tabs.Tab value="graph">Graph</Tabs.Tab>\n        </Tabs.List>\n\n        <Space h="md" />\n\n        <Tabs.Panel value="report">\n          <Stack gap="md">\n            {report?.report ? (\n              <>\n                {/* Table of Contents - only show when report tab is active */}\n                {activeTab === "report" && (\n                  <TableOfContents content={report.report} />\n                )}\n                <MarkdownRenderer\n                  content={report.report}\n                  p="lg"\n                  bg="var(--mantine-color-gray-0)"\n                  style={{\n                    borderRadius: "var(--mantine-radius-md)",\n                    minHeight: "60vh",\n                    maxHeight: "60vh",\n                    overflowY: "auto",\n                  }}\n                />\n              </>\n            ) : (\n              <Text ta="center" c="dimmed" size="lg" py="xl">\n                No report available yet. Generate tests to see results here.\n              </Text>\n            )}\n          </Stack>\n        </Tabs.Panel>\n\n        <Tabs.Panel value="graph">\n          <Stack gap="md">\n            {report?.files && report.files.length > 0 ? (\n              <>\n                <Text size="sm" c="dimmed">\n                  Interactive visualization of file dependencies. Drag nodes to\n                  organize them, use mouse wheel to zoom, click and drag empty\n                  space to pan. Click on a node to view file annotations, or\n                  click on an arrow to see dependency analysis.\n                </Text>\n                <InteractiveCanvas\n                  files={graphData.files}\n                  edges={graphData.edges}\n                  annotations={graphData.annotations}\n                />\n              </>\n            ) : (\n              <Text ta="center" c="dimmed" size="lg" py="xl">\n                No files available. Generate tests to see the dependency graph\n                here.\n              </Text>\n            )}\n          </Stack>\n        </Tabs.Panel>\n      </Tabs>\n    </Stack>\n  );\n}\n',
    size: 4846,
    dependents: [
      {
        name: "files.mock.ts",
        path: "ui/src/mocks/files.mock.ts",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/tree-utils.ts",
    name: "tree-utils.ts",
    content:
      '// # 2. Tree Utility Functions\n// Contains helper functions for building and managing file tree structures\n\nimport type { RepoFile } from "src/types/repo";\nimport type { TreeNode } from "./tree-item";\n\n// # 2.1 Build File Tree Function\n// Converts a flat list of RepoFile objects into a hierarchical tree structure\nexport function buildFileTree(files: RepoFile[]): TreeNode[] {\n  // # 2.1.1 Initialize Tree Structure\n  const tree: TreeNode[] = [];\n  const pathToNode: Map<string, TreeNode> = new Map();\n\n  // # 2.1.2 Sort Files for Proper Tree Building\n  // Sort files by path to ensure proper hierarchical construction\n  const sortedFiles = [...files].sort((a, b) => a.path.localeCompare(b.path));\n\n  // # 2.1.3 Process Each File\n  for (const file of sortedFiles) {\n    const pathParts = file.path.split("/");\n    let currentPath = "";\n\n    // # 2.1.4 Build Path Hierarchy\n    // Create directory nodes for each part of the file path\n    for (let i = 0; i < pathParts.length; i++) {\n      const part = pathParts[i];\n      const parentPath = currentPath;\n      currentPath = currentPath ? `${currentPath}/${part}` : part;\n\n      // # 2.1.5 Create Node if Not Exists\n      if (!pathToNode.has(currentPath)) {\n        const isFile = i === pathParts.length - 1;\n        const node: TreeNode = {\n          path: currentPath,\n          name: part,\n          type: isFile ? "file" : "directory",\n          file: isFile ? file : undefined,\n          children: [],\n          depth: i,\n        };\n\n        pathToNode.set(currentPath, node);\n\n        // # 2.1.6 Link to Parent or Root\n        if (parentPath && pathToNode.has(parentPath)) {\n          pathToNode.get(parentPath)!.children.push(node);\n        } else if (i === 0) {\n          tree.push(node);\n        }\n      }\n    }\n  }\n\n  return tree;\n}\n\n// # 2.2 Collect Directory Paths Function\n// Recursively collects all directory paths from a tree structure\nexport function collectDirectoryPaths(nodes: TreeNode[]): Set<string> {\n  const allDirectoryPaths = new Set<string>();\n\n  const traverse = (nodeList: TreeNode[]) => {\n    nodeList.forEach((node) => {\n      if (node.type === "directory") {\n        allDirectoryPaths.add(node.path);\n        if (node.children.length > 0) {\n          traverse(node.children);\n        }\n      }\n    });\n  };\n\n  traverse(nodes);\n  return allDirectoryPaths;\n}\n\n// # 2.3 Get First Level Directories Function\n// Extracts only the top-level directory paths from a tree\nexport function getFirstLevelDirectories(tree: TreeNode[]): string[] {\n  return tree\n    .filter((node) => node.type === "directory" && node.depth === 0)\n    .map((node) => node.path);\n}\n',
    size: 2632,
    dependents: [
      {
        name: "files.mock.ts",
        path: "ui/src/mocks/files.mock.ts",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/use-file-tree.ts",
    name: "use-file-tree.ts",
    content:
      '// # 3. File Tree State Management Hook\n// Custom hook for managing file tree state and operations\n\nimport { useState, useEffect, useMemo, useCallback } from "react";\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\nimport { type TreeNode } from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-item";\nimport {\n  buildFileTree,\n  getFirstLevelDirectories,\n} from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-utils";\n\n// # 3.1 Hook Interface\ninterface UseFileTreeProps {\n  repoFiles: RepoFile[];\n  selectedFiles: SelectedRepoFile[];\n}\n\n// # 3.2 Hook Return Type\ninterface UseFileTreeReturn {\n  fileTree: TreeNode[];\n  expandedDirectories: Set<string>;\n  toggleDirectoryExpansion: (path: string) => void;\n}\n\n// # 3.3 Main Hook Implementation\n// Manages tree state, expansion, and provides utility functions\nexport function useFileTree({\n  repoFiles,\n}: UseFileTreeProps): UseFileTreeReturn {\n  // # 3.3.1 State Management\n  const [expandedDirectories, setExpandedDirectories] = useState<Set<string>>(\n    new Set()\n  );\n\n  // # 3.3.2 Build Tree Structure\n  // Build tree structure from files (memoized to prevent unnecessary re-renders)\n  const fileTree = useMemo(() => {\n    return repoFiles.length > 0 ? buildFileTree(repoFiles) : [];\n  }, [repoFiles]);\n\n  // # 3.3.3 Directory Expansion Functions\n\n  // # 3.3.3.1 Toggle Single Directory\n  const toggleDirectoryExpansion = useCallback((path: string) => {\n    setExpandedDirectories((prev) => {\n      const newSet = new Set(prev);\n      if (newSet.has(path)) {\n        newSet.delete(path);\n      } else {\n        newSet.add(path);\n      }\n      return newSet;\n    });\n  }, []);\n\n  // # 3.3.4 Auto-expand Effect\n  // Auto-expand first level directories when files are first loaded\n  useEffect(() => {\n    if (repoFiles.length > 0 && expandedDirectories.size === 0) {\n      const firstLevelDirs = getFirstLevelDirectories(fileTree);\n      setExpandedDirectories(new Set(firstLevelDirs));\n    }\n  }, [repoFiles.length, fileTree, expandedDirectories.size]);\n\n  // # 3.3.5 Return Hook Interface\n  return {\n    fileTree,\n    expandedDirectories,\n    toggleDirectoryExpansion,\n  };\n}\n',
    size: 2190,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/hooks/use-annotate.ts",
    name: "use-annotate.ts",
    content:
      'import { useMutation } from "@tanstack/react-query";\nimport { apiPost } from "../utils/api";\nimport type {\n  AnnotateRequest,\n  GenerateReportResponse,\n} from "handoff-server/schemas";\n// import { MOCK_REPORT } from "src/mocks/report.mock";\n\ninterface UseAnnotateOptions {\n  onSuccess?: (data: GenerateReportResponse) => void;\n  onError?: (error: Error) => void;\n}\n\nexport const useAnnotate = (options?: UseAnnotateOptions) => {\n  return useMutation<GenerateReportResponse, Error, AnnotateRequest>({\n    mutationFn: async (request: AnnotateRequest) => {\n      // return Promise.resolve(MOCK_REPORT);\n      return apiPost<AnnotateRequest, GenerateReportResponse>({\n        endpoint: "/generate-report",\n        body: request,\n      });\n    },\n    onSuccess: options?.onSuccess,\n    onError: options?.onError,\n  });\n};\n',
    size: 823,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/mocks/report.mock.ts",
    name: "report.mock.ts",
    content:
      'export const MOCK_REPORT = {\n  report:\n    "## Feature/Product Report\\n\\nThis report details the structure and functionality of the UI feature/product based on the provided files: `ui/src/main.tsx`, `ui/src/setup.tsx`, and `ui/src/routeTree.gen.ts`.\\n\\n### 1. `ui/src/main.tsx` - Application Entry Point\\n\\n**Purpose:** This file serves as the primary entry point for the React application. It is responsible for initializing the routing system and rendering the root component of the application.\\n\\n**Key Functionalities:**\\n\\n*   **Essential Module Imports:** Imports core React modules (`StrictMode`, `ReactDOM`), TanStack Router components (`RouterProvider`, `createRouter`), and the application wrapper function (`createAppWrapper`) from `src/setup.tsx`.\\n*   **Import Generated Route Tree:** Imports the `routeTree` object from `src/routeTree.gen.ts`, which defines the application\'s routing structure.\\n*   **Create TanStack Router Instance:** Initializes a new TanStack Router instance using the imported `routeTree`.\\n*   **Register Router for Type Safety:** Augments the `@tanstack/react-router` module to register the created router instance, enabling type safety for routing operations throughout the application.\\n*   **Render React Application:** Locates the root HTML element (`#root`) and renders the main React application. It wraps the `RouterProvider` (which manages the application\'s routes) with the `createAppWrapper` function, ensuring that global providers (like theming and query client) are applied.\\n\\n**Dependencies:**\\n*   `ui/src/setup.tsx`: Provides the `createAppWrapper` function, which wraps the main application with necessary providers.\\n*   `ui/src/routeTree.gen.ts`: Provides the `routeTree` object, which defines the application\'s routing configuration.\\n\\n### 2. `ui/src/setup.tsx` - Application Setup and Providers\\n\\n**Purpose:** This file centralizes the setup of application-wide providers, such as the TanStack Query client for data fetching and Mantine for UI theming. It provides wrapper components to ensure these contexts are available to the application.\\n\\n**Key Functionalities:**\\n\\n*   **Import Dependencies:** Imports React, Mantine components (`MantineProvider`), and TanStack Query components (`QueryClient`, `QueryClientProvider`). It also imports `main.css` for global styles.\\n*   **Initialize TanStack Query Client:** Creates and configures a `QueryClient` instance with default options for `staleTime` (5 minutes) and `gcTime` (10 minutes), optimizing data caching behavior.\\n*   **Test Wrapper Component (`TestWrapper`):** Exports a component specifically designed for wrapping components during testing. It provides the `QueryClientProvider` and `MantineProvider` contexts.\\n*   **Application Wrapper Component (`createAppWrapper`):** Exports a function that takes React children and wraps them with the `QueryClientProvider` and `MantineProvider`. This ensures that all parts of the main application rendered via `main.tsx` have access to data fetching and theming contexts.\\n\\n**Dependencies:**\\n*   `./main.css`: For global styling.\\n*   `ui/src/main.tsx`: Consumes the `createAppWrapper` function to wrap the entire application.\\n\\n### 3. `ui/src/routeTree.gen.ts` - Generated Route Configuration\\n\\n**Purpose:** This file is automatically generated by TanStack Router and defines the complete routing structure of the application. It consolidates all individual route definitions into a single, type-safe route tree.\\n\\n**Key Functionalities:**\\n\\n*   **ESLint and TypeScript Directives:** Contains directives to manage linting and TypeScript behavior for the generated file.\\n*   **TanStack Router Generated File Disclaimer:** A standard disclaimer indicating that the file is auto-generated and should not be manually edited.\\n*   **Route Imports:** Imports individual route definitions (e.g., Root Route, Index Route, Generate Tests Route). While the specific files for these routes are not provided, their imports are crucial for building the tree.\\n*   **Route Definitions:** Defines the structure and properties of each route within the application.\\n*   **Interface Augmentations:** Augments various TanStack Router interfaces (`FileRoutesByFullPath`, `FileRoutesByToPath`, `FileRoutesByID`, `AggregateFileRouteTypes`, `RootRouteChildren`, `TanStackReactRouterModule`, `FileRoutesByPath`) to provide strong type safety for the defined routes.\\n*   **Root Route Children Object:** Organizes the child routes under the root route.\\n*   **Exported Route Tree:** Exports the `routeTree` object, which is then consumed by `ui/src/main.tsx` to initialize the router.\\n\\n**Dependencies:**\\n*   Individual route files (e.g., `__root.tsx`, `index.tsx`, `generate-tests.tsx` - implied by the annotations, though not provided in the directory list).\\n*   `ui/src/main.tsx`: Imports and uses the `routeTree` to configure the application\'s router.\\n\\n### Conclusion\\n\\nThe UI feature/product is structured around a modern React ecosystem, leveraging **TanStack Router** for robust, type-safe routing and **TanStack Query** for efficient data fetching and caching. **Mantine** provides a consistent and customizable UI framework.\\n\\n*   `ui/src/main.tsx` acts as the orchestrator, bringing together the routing logic and the application\'s global providers.\\n*   `ui/src/setup.tsx` centralizes the configuration of essential services like data management and UI theming, making them easily accessible throughout the application.\\n*   `ui/src/routeTree.gen.ts` is a critical, auto-generated component that ensures the routing structure is well-defined and type-safe, simplifying navigation and development.\\n\\nThis modular approach promotes maintainability, scalability, and a clear separation of concerns within the application\'s UI layer.",\n  files: [\n    {\n      name: "main.tsx",\n      text: \'import { StrictMode } from "react";\\nimport ReactDOM from "react-dom/client";\\nimport { RouterProvider, createRouter } from "@tanstack/react-router";\\nimport { createAppWrapper } from "src/setup.tsx";\\n\\n// Import the generated route tree\\nimport { routeTree } from "src/routeTree.gen";\\n\\n// Create a new router instance\\nconst router = createRouter({ routeTree });\\n\\n// Register the router instance for type safety\\ndeclare module "@tanstack/react-router" {\\n  interface Register {\\n    router: typeof router;\\n  }\\n}\\n\\n// Render the app\\nconst rootElement = document.getElementById("root")!;\\nif (!rootElement.innerHTML) {\\n  const root = ReactDOM.createRoot(rootElement);\\n  root.render(\\n    <StrictMode>\\n      {createAppWrapper(<RouterProvider router={router} />)}\\n    </StrictMode>\\n  );\\n}\\n\',\n      path: "ui/src/main.tsx",\n      dependents: [],\n      annotations: [\n        "## 1. Essential Module Imports",\n        "## 2. Import Generated Route Tree",\n        "## 3. Create TanStack Router Instance",\n        "## 4. Register Router for Type Safety",\n        "## 5. Render React Application",\n      ],\n      annotatedText:\n        \'```\\nimport { StrictMode } from "react";\\nimport ReactDOM from "react-dom/client";\\nimport { RouterProvider, createRouter } from "@tanstack/react-router";\\nimport { createAppWrapper } from "src/setup.tsx";\\n\\n## 1. Essential Module Imports\\n\\n// Import the generated route tree\\nimport { routeTree } from "src/routeTree.gen";\\n\\n## 2. Import Generated Route Tree\\n\\n// Create a new router instance\\nconst router = createRouter({ routeTree });\\n\\n## 3. Create TanStack Router Instance\\n\\n// Register the router instance for type safety\\ndeclare module "@tanstack/react-router" {\\n  interface Register {\\n    router: typeof router;\\n  }\\n}\\n\\n## 4. Register Router for Type Safety\\n\\n## 5. Render React Application\\n\\n// Render the app\\nconst rootElement = document.getElementById("root")!;\\nif (!rootElement.innerHTML) {\\n  const root = ReactDOM.createRoot(rootElement);\\n  root.render(\\n    <StrictMode>\\n      {createAppWrapper(<RouterProvider router={router} />)}\\n    </StrictMode>\\n  );\\n}\\n```\',\n    },\n    {\n      name: "setup.tsx",\n      text: \'import React from "react";\\nimport { MantineProvider } from "@mantine/core";\\nimport { QueryClient, QueryClientProvider } from "@tanstack/react-query";\\nimport "./main.css";\\n\\n// Create a global query client instance\\nconst queryClient = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n      staleTime: 1000 * 60 * 5, // 5 minutes\\n      gcTime: 1000 * 60 * 10, // 10 minutes\\n    },\\n  },\\n});\\n\\n// Create a reusable wrapper that provides the same context as production\\nexport const TestWrapper = ({ children }: { children: React.ReactNode }) => (\\n  <QueryClientProvider client={queryClient}>\\n    <MantineProvider defaultColorScheme="light">{children}</MantineProvider>\\n  </QueryClientProvider>\\n);\\n\\n// For use in main.js/main.tsx\\n// eslint-disable-next-line react-refresh/only-export-components\\nexport const createAppWrapper = (children: React.ReactNode) => (\\n  <QueryClientProvider client={queryClient}>\\n    <MantineProvider defaultColorScheme="light">{children}</MantineProvider>\\n  </QueryClientProvider>\\n);\\n\',\n      path: "ui/src/setup.tsx",\n      dependents: [\n        {\n          name: "main.tsx",\n          path: "ui/src/main.tsx",\n          analysis:\n            "`setup.tsx` imports the core application component or the TanStack Router instance from `main.tsx`. It uses these imports within its `Test Wrapper Component` and `Application Wrapper Component` to provide a consistent testing environment. This dependency ensures that application components are tested within the same context (e.g., routing, query client) they would operate in during actual application execution.",\n        },\n      ],\n      annotations: [\n        "## 1. Import Dependencies",\n        "## 2. Initialize TanStack Query Client",\n        "## 3. Test Wrapper Component",\n        "## 4. Application Wrapper Component",\n      ],\n      annotatedText:\n        \'```\\n## 1. Import Dependencies\\nimport React from "react";\\nimport { MantineProvider } from "@mantine/core";\\nimport { QueryClient, QueryClientProvider } from "@tanstack/react-query";\\nimport "./main.css";\\n\\n## 2. Initialize TanStack Query Client\\nconst queryClient = new QueryClient({\\n  defaultOptions: {\\n    queries: {\\n      staleTime: 1000 * 60 * 5, // 5 minutes\\n      gcTime: 1000 * 60 * 10, // 10 minutes\\n    },\\n  },\\n});\\n\\n## 3. Test Wrapper Component\\nexport const TestWrapper = ({ children }: { children: React.ReactNode }) => (\\n  <QueryClientProvider client={queryClient}>\\n    <MantineProvider defaultColorScheme="light">{children}</MantineProvider>\\n  </QueryClientProvider>\\n);\\n\\n## 4. Application Wrapper Component\\nexport const createAppWrapper = (children: React.ReactNode) => (\\n  <QueryClientProvider client={queryClient}>\\n    <MantineProvider defaultColorScheme="light">{children}</MantineProvider>\\n  </QueryClientProvider>\\n);\\n```\',\n    },\n    {\n      name: "routeTree.gen.ts",\n      text: "/* eslint-disable */\\n\\n// @ts-nocheck\\n\\n// noinspection JSUnusedGlobalSymbols\\n\\n// This file was automatically generated by TanStack Router.\\n// You should NOT make any changes in this file as it will be overwritten.\\n// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.\\n\\nimport { Route as rootRouteImport } from \'./routes/__root\'\\nimport { Route as IndexRouteImport } from \'./routes/index\'\\nimport { Route as generateTestsGenerateTestsRouteImport } from \'./routes/(generate-tests)/generate-tests\'\\n\\nconst IndexRoute = IndexRouteImport.update({\\n  id: \'/\',\\n  path: \'/\',\\n  getParentRoute: () => rootRouteImport,\\n} as any)\\nconst generateTestsGenerateTestsRoute =\\n  generateTestsGenerateTestsRouteImport.update({\\n    id: \'/(generate-tests)/generate-tests\',\\n    path: \'/generate-tests\',\\n    getParentRoute: () => rootRouteImport,\\n  } as any)\\n\\nexport interface FileRoutesByFullPath {\\n  \'/\': typeof IndexRoute\\n  \'/generate-tests\': typeof generateTestsGenerateTestsRoute\\n}\\nexport interface FileRoutesByTo {\\n  \'/\': typeof IndexRoute\\n  \'/generate-tests\': typeof generateTestsGenerateTestsRoute\\n}\\nexport interface FileRoutesById {\\n  __root__: typeof rootRouteImport\\n  \'/\': typeof IndexRoute\\n  \'/(generate-tests)/generate-tests\': typeof generateTestsGenerateTestsRoute\\n}\\nexport interface FileRouteTypes {\\n  fileRoutesByFullPath: FileRoutesByFullPath\\n  fullPaths: \'/\' | \'/generate-tests\'\\n  fileRoutesByTo: FileRoutesByTo\\n  to: \'/\' | \'/generate-tests\'\\n  id: \'__root__\' | \'/\' | \'/(generate-tests)/generate-tests\'\\n  fileRoutesById: FileRoutesById\\n}\\nexport interface RootRouteChildren {\\n  IndexRoute: typeof IndexRoute\\n  generateTestsGenerateTestsRoute: typeof generateTestsGenerateTestsRoute\\n}\\n\\ndeclare module \'@tanstack/react-router\' {\\n  interface FileRoutesByPath {\\n    \'/\': {\\n      id: \'/\'\\n      path: \'/\'\\n      fullPath: \'/\'\\n      preLoaderRoute: typeof IndexRouteImport\\n      parentRoute: typeof rootRouteImport\\n    }\\n    \'/(generate-tests)/generate-tests\': {\\n      id: \'/(generate-tests)/generate-tests\'\\n      path: \'/generate-tests\'\\n      fullPath: \'/generate-tests\'\\n      preLoaderRoute: typeof generateTestsGenerateTestsRouteImport\\n      parentRoute: typeof rootRouteImport\\n    }\\n  }\\n}\\n\\nconst rootRouteChildren: RootRouteChildren = {\\n  IndexRoute: IndexRoute,\\n  generateTestsGenerateTestsRoute: generateTestsGenerateTestsRoute,\\n}\\nexport const routeTree = rootRouteImport\\n  ._addFileChildren(rootRouteChildren)\\n  ._addFileTypes<FileRouteTypes>()\\n",\n      path: "ui/src/routeTree.gen.ts",\n      dependents: [\n        {\n          name: "main.tsx",\n          path: "ui/src/main.tsx",\n          analysis:\n            "File A (`routeTree.gen.ts`) does not import anything from File B (`main.tsx`). Instead, File B imports the `routeTree` object generated by File A, which encapsulates the application\'s entire route structure. This allows `main.tsx` to initialize the TanStack Router with the complete, type-safe route configuration, establishing File A as the central source of truth for the application\'s routing logic.",\n        },\n      ],\n      annotations: [\n        "## 1. ESLint and TypeScript Directives",\n        "## 2. TanStack Router Generated File Disclaimer",\n        "## 3. Root Route Import",\n        "## 4. Index Route Import",\n        "## 5. Generate Tests Route Import",\n        "## 6. Index Route Definition",\n        "## 7. Generate Tests Route Definition",\n        "## 8. File Routes by Full Path Interface",\n        "## 9. File Routes by To Path Interface",\n        "## 10. File Routes by ID Interface",\n        "## 11. Aggregate File Route Types Interface",\n        "## 12. Root Route Children Interface",\n        "## 13. TanStack React Router Module Augmentation",\n        "## 14. File Routes by Path Interface Augmentation for Index Route",\n        "## 15. File Routes by Path Interface Augmentation for Generate Tests Route",\n        "## 16. Root Route Children Object",\n        "## 17. Exported Route Tree",\n      ],\n      annotatedText:\n        "```\\n## 1. ESLint and TypeScript Directives\\n\\n## 2. TanStack Router Generated File Disclaimer\\n\\n## 3. Root Route Import\\n\\n## 4. Index Route Import\\n\\n## 5. Generate Tests Route Import\\n\\n## 6. Index Route Definition\\n\\n## 7. Generate Tests Route Definition\\n\\n## 8. File Routes by Full Path Interface\\n\\n## 9. File Routes by To Path Interface\\n\\n## 10. File Routes by ID Interface\\n\\n## 11. Aggregate File Route Types Interface\\n\\n## 12. Root Route Children Interface\\n\\n## 13. TanStack React Router Module Augmentation\\n\\n## 14. File Routes by Path Interface Augmentation for Index Route\\n\\n## 15. File Routes by Path Interface Augmentation for Generate Tests Route\\n\\n## 16. Root Route Children Object\\n\\n## 17. Exported Route Tree\\n```",\n    },\n  ],\n};\n',
    size: 15815,
    dependents: [
      {
        name: "use-annotate.ts",
        path: "ui/src/hooks/use-annotate.ts",
      },
    ],
  },
  {
    path: "ui/src/setup.tsx",
    name: "setup.tsx",
    content:
      'import React from "react";\nimport { MantineProvider } from "@mantine/core";\nimport { QueryClient, QueryClientProvider } from "@tanstack/react-query";\nimport "./main.css";\n\n// Create a global query client instance\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 1000 * 60 * 5, // 5 minutes\n      gcTime: 1000 * 60 * 10, // 10 minutes\n    },\n  },\n});\n\n// Create a reusable wrapper that provides the same context as production\nexport const TestWrapper = ({ children }: { children: React.ReactNode }) => (\n  <QueryClientProvider client={queryClient}>\n    <MantineProvider defaultColorScheme="light">{children}</MantineProvider>\n  </QueryClientProvider>\n);\n\n// For use in main.js/main.tsx\n// eslint-disable-next-line react-refresh/only-export-components\nexport const createAppWrapper = (children: React.ReactNode) => (\n  <QueryClientProvider client={queryClient}>\n    <MantineProvider defaultColorScheme="light">{children}</MantineProvider>\n  </QueryClientProvider>\n);\n',
    size: 1006,
    dependents: [
      {
        name: "report.mock.ts",
        path: "ui/src/mocks/report.mock.ts",
      },
    ],
  },
  {
    path: "ui/src/routeTree.gen.ts",
    name: "routeTree.gen.ts",
    content:
      "/* eslint-disable */\n\n// @ts-nocheck\n\n// noinspection JSUnusedGlobalSymbols\n\n// This file was automatically generated by TanStack Router.\n// You should NOT make any changes in this file as it will be overwritten.\n// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.\n\nimport { Route as rootRouteImport } from './routes/__root'\nimport { Route as IndexRouteImport } from './routes/index'\nimport { Route as generateTestsGenerateTestsRouteImport } from './routes/(generate-tests)/generate-tests'\n\nconst IndexRoute = IndexRouteImport.update({\n  id: '/',\n  path: '/',\n  getParentRoute: () => rootRouteImport,\n} as any)\nconst generateTestsGenerateTestsRoute =\n  generateTestsGenerateTestsRouteImport.update({\n    id: '/(generate-tests)/generate-tests',\n    path: '/generate-tests',\n    getParentRoute: () => rootRouteImport,\n  } as any)\n\nexport interface FileRoutesByFullPath {\n  '/': typeof IndexRoute\n  '/generate-tests': typeof generateTestsGenerateTestsRoute\n}\nexport interface FileRoutesByTo {\n  '/': typeof IndexRoute\n  '/generate-tests': typeof generateTestsGenerateTestsRoute\n}\nexport interface FileRoutesById {\n  __root__: typeof rootRouteImport\n  '/': typeof IndexRoute\n  '/(generate-tests)/generate-tests': typeof generateTestsGenerateTestsRoute\n}\nexport interface FileRouteTypes {\n  fileRoutesByFullPath: FileRoutesByFullPath\n  fullPaths: '/' | '/generate-tests'\n  fileRoutesByTo: FileRoutesByTo\n  to: '/' | '/generate-tests'\n  id: '__root__' | '/' | '/(generate-tests)/generate-tests'\n  fileRoutesById: FileRoutesById\n}\nexport interface RootRouteChildren {\n  IndexRoute: typeof IndexRoute\n  generateTestsGenerateTestsRoute: typeof generateTestsGenerateTestsRoute\n}\n\ndeclare module '@tanstack/react-router' {\n  interface FileRoutesByPath {\n    '/': {\n      id: '/'\n      path: '/'\n      fullPath: '/'\n      preLoaderRoute: typeof IndexRouteImport\n      parentRoute: typeof rootRouteImport\n    }\n    '/(generate-tests)/generate-tests': {\n      id: '/(generate-tests)/generate-tests'\n      path: '/generate-tests'\n      fullPath: '/generate-tests'\n      preLoaderRoute: typeof generateTestsGenerateTestsRouteImport\n      parentRoute: typeof rootRouteImport\n    }\n  }\n}\n\nconst rootRouteChildren: RootRouteChildren = {\n  IndexRoute: IndexRoute,\n  generateTestsGenerateTestsRoute: generateTestsGenerateTestsRoute,\n}\nexport const routeTree = rootRouteImport\n  ._addFileChildren(rootRouteChildren)\n  ._addFileTypes<FileRouteTypes>()\n",
    size: 2508,
    dependents: [
      {
        name: "report.mock.ts",
        path: "ui/src/mocks/report.mock.ts",
      },
    ],
  },
  {
    path: "ui/src/routes/__root.tsx",
    name: "__root.tsx",
    content:
      'import { createRootRoute, Outlet } from "@tanstack/react-router";\n// import { TanStackRouterDevtools } from "@tanstack/react-router-devtools";\n\nexport const Route = createRootRoute({\n  component: () => (\n    <>\n      <Outlet />\n      {/* <TanStackRouterDevtools /> */}\n    </>\n  ),\n});\n',
    size: 286,
    dependents: [
      {
        name: "routeTree.gen.ts",
        path: "ui/src/routeTree.gen.ts",
      },
    ],
  },
];
