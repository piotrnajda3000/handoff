export const FILES_TO_TEXT = [
  {
    name: "index.tsx",
    text: 'import { createFileRoute } from "@tanstack/react-router";\nimport { useEffect, useMemo, useState } from "react";\nimport {\n  Container,\n  Paper,\n  Stack,\n  Center,\n  Title,\n  Text,\n  Box,\n  Button,\n  Group,\n  Stepper,\n  Tooltip,\n} from "@mantine/core";\nimport {\n  IconChevronLeft,\n  IconChevronRight,\n  IconCheck,\n} from "@tabler/icons-react";\nimport { FileDropzone } from "../../components/dropzone/dropzone";\nimport { useDropzone } from "../../components/dropzone/use-dropzone";\n\nexport const Route = createFileRoute("/generate-tests/")({\n  component: Index,\n});\n\nfunction Index() {\n  const [currentStep, setCurrentStep] = useState(0);\n  const {\n    files,\n    rejectedFiles,\n    handleDrop,\n    handleReject,\n    handleDelete,\n    handleDeleteRejected,\n  } = useDropzone();\n\n  const [fileBytes, setFileBytes] = useState<Record<string, Uint8Array>>({});\n\n  useEffect(() => {\n    async function getFileBytes() {\n      if (files.length > 0) {\n        const fileBytes = await Promise.all(\n          files.map(async (file) => {\n            return file.arrayBuffer().then((buffer) => new Uint8Array(buffer));\n          })\n        );\n        setFileBytes(\n          fileBytes.reduce(\n            (acc, fileByte, index) => {\n              acc[files[index].name] = fileByte;\n              return acc;\n            },\n            {} as Record<string, Uint8Array>\n          )\n        );\n      }\n    }\n    getFileBytes();\n  }, [files]);\n\n  const fileBytesToText = useMemo(() => {\n    return Object.entries(fileBytes).map(([name, fileByte]) => {\n      return {\n        name,\n        text: new TextDecoder().decode(fileByte),\n      };\n    });\n  }, [fileBytes]);\n\n  console.log({ fileBytesToText });\n\n  const stepTitles = ["Upload Files", "Generate Tests", "Review Results"];\n  const totalSteps = stepTitles.length;\n\n  const canProceedToNext =\n    currentStep === 0 ? files.length > 0 && rejectedFiles.length === 0 : true;\n\n  const getNextButtonTooltip = () => {\n    if (currentStep === 0) {\n      if (files.length === 0) {\n        return "Please upload files to continue";\n      }\n      if (rejectedFiles.length > 0) {\n        return "Please remove rejected files to continue";\n      }\n    }\n    if (currentStep === totalSteps - 1) {\n      return "Complete the process";\n    }\n    return "";\n  };\n\n  const handleNext = () => {\n    if (currentStep < totalSteps - 1) {\n      setCurrentStep(currentStep + 1);\n    }\n  };\n\n  const handlePrevious = () => {\n    if (currentStep > 0) {\n      setCurrentStep(currentStep - 1);\n    }\n  };\n\n  const renderStepContent = () => {\n    switch (currentStep) {\n      case 0:\n        return (\n          <Stack gap="lg">\n            <Box ta="center">\n              <Title order={1} size="h2" mb="md">\n                Welcome to Handoff\n              </Title>\n              <Text c="dimmed" size="lg">\n                Upload your code files to generate natural language test cases\n              </Text>\n            </Box>\n\n            <FileDropzone\n              files={files}\n              rejectedFiles={rejectedFiles}\n              onDrop={handleDrop}\n              onReject={handleReject}\n              onDelete={handleDelete}\n              onDeleteRejected={handleDeleteRejected}\n            />\n          </Stack>\n        );\n      case 1:\n        return (\n          <Stack gap="lg">\n            <Box ta="center">\n              <Title order={2} mb="md">\n                Generate Tests\n              </Title>\n              <Text c="dimmed" size="lg">\n                Processing your files to generate test cases...\n              </Text>\n            </Box>\n            {/* This will be implemented later */}\n            <Text ta="center" c="blue">\n              Coming soon: Test generation in progress\n            </Text>\n          </Stack>\n        );\n      case 2:\n        return (\n          <Stack gap="lg">\n            <Box ta="center">\n              <Title order={2} mb="md">\n                Review Results\n              </Title>\n              <Text c="dimmed" size="lg">\n                Review and download your generated test cases\n              </Text>\n            </Box>\n            {/* This will be implemented later */}\n            <Text ta="center" c="green">\n              Coming soon: Generated test results\n            </Text>\n          </Stack>\n        );\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <Container size="md" style={{ height: "100vh" }}>\n      <Center style={{ height: "100%" }}>\n        <Paper\n          shadow="lg"\n          radius="md"\n          p="xl"\n          style={{ width: "100%", maxWidth: 700 }}\n        >\n          <Stack gap="xl">\n            {/* Step Progress Indicator */}\n            <Box>\n              <Stepper active={currentStep} size="sm">\n                {stepTitles.map((title, index) => (\n                  <Stepper.Step key={index} label={title} />\n                ))}\n              </Stepper>\n            </Box>\n\n            {/* Step Content */}\n            <Box>{renderStepContent()}</Box>\n\n            {/* Navigation */}\n            <Group justify="space-between">\n              <Button\n                variant="outline"\n                onClick={handlePrevious}\n                disabled={currentStep === 0}\n                data-qa="previous-button"\n                leftSection={<IconChevronLeft size={16} />}\n              >\n                Previous\n              </Button>\n\n              <Tooltip\n                label={getNextButtonTooltip()}\n                disabled={canProceedToNext && currentStep !== totalSteps - 1}\n                position="top"\n                data-qa="next-button-tooltip"\n              >\n                <Button\n                  onClick={handleNext}\n                  data-qa="next-button"\n                  disabled={!canProceedToNext || currentStep === totalSteps - 1}\n                  rightSection={\n                    currentStep === totalSteps - 1 ? (\n                      <IconCheck size={16} />\n                    ) : (\n                      <IconChevronRight size={16} />\n                    )\n                  }\n                >\n                  {currentStep === totalSteps - 1 ? "Finish" : "Next"}\n                </Button>\n              </Tooltip>\n            </Group>\n          </Stack>\n        </Paper>\n      </Center>\n    </Container>\n  );\n}\n',
  },
  {
    name: "dropzone.tsx",
    text: 'import {\n  Dropzone,\n  type FileWithPath,\n  type FileRejection,\n} from "@mantine/dropzone";\nimport { Box, Text, Group, rem, ActionIcon, Tooltip } from "@mantine/core";\nimport {\n  IconUpload,\n  IconFile,\n  IconX,\n  IconBrandJavascript,\n  IconBrandTypescript,\n  IconBrandReact,\n  IconAlertCircle,\n} from "@tabler/icons-react";\nimport classes from "./dropzone.module.css";\n\ninterface FileDropzoneProps {\n  files: FileWithPath[];\n  rejectedFiles?: FileRejection[];\n  onDrop: (files: FileWithPath[]) => void;\n  onReject: (files: FileRejection[]) => void;\n  onDelete?: (index: number) => void;\n  onDeleteRejected?: (index: number) => void;\n}\n\nconst ALLOWED_EXTENSIONS = [".js", ".jsx", ".ts", ".tsx"];\n\nfunction validateFileType(file: FileWithPath): boolean {\n  const extension = "." + file.name.toLowerCase().split(".").pop();\n  return ALLOWED_EXTENSIONS.includes(extension);\n}\n\nfunction validateFiles(files: FileWithPath[]): {\n  acceptedFiles: FileWithPath[];\n  rejectedFiles: FileRejection[];\n} {\n  const acceptedFiles: FileWithPath[] = [];\n  const rejectedFiles: FileRejection[] = [];\n\n  files.forEach((file) => {\n    if (validateFileType(file)) {\n      acceptedFiles.push(file);\n    } else {\n      rejectedFiles.push({\n        file,\n        errors: [\n          {\n            code: "file-invalid-type",\n            message: `File type not allowed. Only .js, .jsx, .ts, .tsx files are accepted.`,\n          },\n        ],\n      });\n    }\n  });\n\n  return { acceptedFiles, rejectedFiles };\n}\n\nfunction getFileIcon(name: string) {\n  const extension = name.toLowerCase().split(".").pop();\n\n  switch (extension) {\n    case "ts":\n      return <IconBrandTypescript size={24} style={{ color: "#3178c6" }} />;\n    case "tsx":\n      return <IconBrandReact size={24} style={{ color: "#61dafb" }} />;\n    case "js":\n      return <IconBrandJavascript size={24} style={{ color: "#f7df1e" }} />;\n    case "jsx":\n      return <IconBrandReact size={24} style={{ color: "#61dafb" }} />;\n    default:\n      return <IconFile size={24} />;\n  }\n}\n\nexport function FileDropzone({\n  files,\n  rejectedFiles = [],\n  onDrop,\n  onReject,\n  onDelete,\n  onDeleteRejected,\n}: FileDropzoneProps) {\n  const handleDrop = (droppedFiles: FileWithPath[]) => {\n    const { acceptedFiles, rejectedFiles } = validateFiles(droppedFiles);\n\n    if (acceptedFiles.length > 0) {\n      onDrop(acceptedFiles);\n    }\n\n    if (rejectedFiles.length > 0) {\n      onReject(rejectedFiles);\n    }\n  };\n\n  const handleReject = (rejectedFiles: FileRejection[]) => {\n    onReject(rejectedFiles);\n  };\n\n  return (\n    <>\n      <Dropzone\n        onDrop={handleDrop}\n        onReject={handleReject}\n        maxSize={5 * 1024 ** 2}\n        accept={{\n          "application/javascript": [".js", ".jsx"],\n          "application/typescript": [".ts", ".tsx"],\n          "text/*": [".js", ".jsx", ".ts", ".tsx"],\n        }}\n        multiple\n        data-qa="dropzone-container"\n        className={classes.root}\n      >\n        <Group\n          justify="center"\n          gap="xl"\n          style={{ minHeight: rem(220), pointerEvents: "none" }}\n          data-qa="dropzone-content"\n        >\n          <Dropzone.Accept>\n            <IconUpload\n              data-qa="dropzone-accept-icon"\n              style={{\n                width: rem(52),\n                height: rem(52),\n                color: "var(--mantine-color-blue-6)",\n              }}\n              stroke={1.5}\n            />\n          </Dropzone.Accept>\n          <Dropzone.Reject>\n            <IconX\n              data-qa="dropzone-reject-icon"\n              style={{\n                width: rem(52),\n                height: rem(52),\n                color: "var(--mantine-color-red-6)",\n              }}\n              stroke={1.5}\n            />\n          </Dropzone.Reject>\n          <Dropzone.Idle>\n            <IconFile\n              data-qa="dropzone-idle-icon"\n              style={{\n                width: rem(52),\n                height: rem(52),\n                color: "var(--mantine-color-dimmed)",\n              }}\n              stroke={1.5}\n            />\n          </Dropzone.Idle>\n\n          <div data-qa="dropzone-text-content">\n            <Text size="xl" inline data-qa="dropzone-title">\n              Drag files here or click to select\n            </Text>\n            <Text\n              size="sm"\n              c="dimmed"\n              inline\n              mt={7}\n              data-qa="dropzone-file-types"\n            >\n              Upload TypeScript (.ts, .tsx) or JavaScript (.js, .jsx) files\n            </Text>\n            <Text\n              size="sm"\n              c="dimmed"\n              inline\n              mt={7}\n              data-qa="dropzone-size-limit"\n            >\n              Files should not exceed 5MB\n            </Text>\n          </div>\n        </Group>\n      </Dropzone>\n\n      {(files.length > 0 || rejectedFiles.length > 0) && (\n        <Box data-qa="selected-files-section" className="flex flex-col gap-xs">\n          {files.map((file, index) => (\n            <Group\n              key={`accepted-${index}`}\n              justify="space-between"\n              align="center"\n              data-qa={`selected-file-${index}`}\n            >\n              <Group gap="xs" align="center">\n                {getFileIcon(file.name)}\n                <Text size="sm" c="dimmed">\n                  {file.name} ({(file.size / 1024).toFixed(1)} KB)\n                </Text>\n              </Group>\n              {onDelete && (\n                <ActionIcon\n                  size="sm"\n                  variant="subtle"\n                  color="red"\n                  onClick={() => onDelete(index)}\n                  data-qa={`delete-file-${index}`}\n                  aria-label={`Delete ${file.name}`}\n                >\n                  <IconX size={16} />\n                </ActionIcon>\n              )}\n            </Group>\n          ))}\n\n          {/* Rejected files */}\n          {rejectedFiles.map((rejection, index) => (\n            <Group\n              key={`rejected-${index}`}\n              justify="space-between"\n              align="center"\n              data-qa={`rejected-file-${index}`}\n            >\n              <Group gap="xs" align="center">\n                <Tooltip\n                  label={rejection.errors\n                    .map((error) => error.message)\n                    .join(", ")}\n                  withArrow\n                  position="top"\n                  data-qa={`error-tooltip-${index}`}\n                >\n                  <IconAlertCircle\n                    size={24}\n                    style={{ color: "var(--mantine-color-red-6)" }}\n                  />\n                </Tooltip>\n                <Text size="sm" c="red.6">\n                  {rejection.file.name} (\n                  {(rejection.file.size / 1024).toFixed(1)} KB)\n                </Text>\n              </Group>\n              {onDeleteRejected && (\n                <ActionIcon\n                  size="sm"\n                  variant="subtle"\n                  color="red"\n                  onClick={() => onDeleteRejected(index)}\n                  data-qa={`delete-rejected-file-${index}`}\n                  aria-label={`Delete ${rejection.file.name}`}\n                >\n                  <IconX size={16} />\n                </ActionIcon>\n              )}\n            </Group>\n          ))}\n        </Box>\n      )}\n    </>\n  );\n}\n',
  },
  {
    name: "use-dropzone.tsx",
    text: 'import { useState } from "react";\nimport { type FileWithPath, type FileRejection } from "@mantine/dropzone";\n\nexport function useDropzone() {\n  const [files, setFiles] = useState<FileWithPath[]>([]);\n  const [rejectedFiles, setRejectedFiles] = useState<FileRejection[]>([]);\n\n  const handleDrop = (droppedFiles: FileWithPath[]) => {\n    setFiles((prevFiles) => [...prevFiles, ...droppedFiles]);\n    console.log("Files dropped:", droppedFiles);\n  };\n\n  const handleReject = (rejectedFiles: FileRejection[]) => {\n    setRejectedFiles((prevRejected) => [...prevRejected, ...rejectedFiles]);\n    console.log("Files rejected:", rejectedFiles);\n  };\n\n  const handleDelete = (index: number) => {\n    setFiles((currentFiles) => {\n      const newFiles = [...currentFiles];\n      newFiles.splice(index, 1);\n      return newFiles;\n    });\n    console.log("File deleted at index:", index);\n  };\n\n  const handleUpdate = (files: FileWithPath[]) => {\n    setFiles(files);\n    console.log("Files updated:", files);\n  };\n\n  const handleDeleteRejected = (index: number) => {\n    setRejectedFiles((currentRejected) => {\n      const newRejected = [...currentRejected];\n      newRejected.splice(index, 1);\n      return newRejected;\n    });\n    console.log("Rejected file deleted at index:", index);\n  };\n\n  return {\n    files,\n    rejectedFiles,\n    handleDrop,\n    handleReject,\n    handleDelete,\n    handleDeleteRejected,\n    handleUpdate,\n  };\n}\n',
  },
];

export const FILES_TO_TEXT_AS_FILES = FILES_TO_TEXT.map(
  (file) => new File([file.text], file.name, { type: "text/plain" })
);

export const MOCK_SELECTED_FILES = [
  {
    path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
    name: "generate-tests.tsx",
    content:
      'import { createFileRoute } from "@tanstack/react-router";\nimport { useState } from "react";\nimport { Container, Paper, Center, Box, Stepper } from "@mantine/core";\nimport { useDependencies } from "src/hooks/use-dependencies";\nimport { useRepoConnection } from "src/hooks/use-repo-connection";\nimport { StepperNavigationButtons } from "src/components/stepper-navigation-buttons";\nimport { StepOneUploadFiles } from "src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files";\nimport { StepTwoDescribeRelations } from "src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations";\nimport { StepThreeViewResults } from "src/routes/(generate-tests)/-components/step-three-view-results/step-three-view-results";\nimport { useFileTree } from "./-components/step-one-upload-files/use-file-tree";\n\n// Interface to make SelectedRepoFile compatible with FileWithPath\ninterface FileCompatible {\n  path: string;\n  name: string;\n  size: number;\n  text: string;\n}\n\nexport const Route = createFileRoute("/(generate-tests)/generate-tests")({\n  component: Index,\n});\n\nfunction Index() {\n  const [currentStep, setCurrentStep] = useState(0);\n\n  const [repoUrl, setRepoUrl] = useState(\n    "https://github.com/piotrnajda3000/handoff.git"\n  );\n  const [accessToken, setAccessToken] = useState(\n    "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"\n  );\n\n  // Repository connection hook - manages selected files internally\n  const repoConnectionData = useRepoConnection();\n  const { selectedFiles } = repoConnectionData;\n\n  // Convert SelectedRepoFile to FileWithPath for existing dependencies hook\n  const fileCompatibleFiles: FileCompatible[] = selectedFiles.map((file) => ({\n    path: file.path,\n    name: file.name,\n    size: file.size,\n    text: file.content, // Add content for compatibility\n  }));\n\n  // File Tree Management Hook\n  const { fileTree, expandedDirectories, toggleDirectoryExpansion } =\n    useFileTree({\n      repoFiles: repoConnectionData.repoFiles,\n      selectedFiles,\n    });\n\n  // Feature Name State\n  const [featureName, setFeatureName] = useState("");\n\n  const dependenciesData = useDependencies(fileCompatibleFiles);\n\n  const stepTitles = ["Connect Repository", "Generate Tests", "Review Results"];\n  const totalSteps = stepTitles.length;\n\n  const canProceedToNext = currentStep === 0 ? selectedFiles.length > 0 : true;\n\n  const getNextButtonTooltip = () => {\n    if (currentStep === 0) {\n      if (selectedFiles.length === 0) {\n        return "Please select files from your repository to continue";\n      }\n    }\n    if (currentStep === totalSteps - 1) {\n      return "Complete the process";\n    }\n    return "";\n  };\n\n  const handleNext = () => {\n    if (currentStep < totalSteps - 1) {\n      setCurrentStep(currentStep + 1);\n    }\n  };\n\n  const handlePrevious = () => {\n    if (currentStep > 0) {\n      setCurrentStep(currentStep - 1);\n    }\n  };\n\n  const renderStepContent = () => {\n    switch (currentStep) {\n      case 0:\n        return (\n          <StepOneUploadFiles\n            repoConnectionData={repoConnectionData}\n            repoUrl={repoUrl}\n            setRepoUrl={setRepoUrl}\n            accessToken={accessToken}\n            setAccessToken={setAccessToken}\n            fileTree={fileTree}\n            expandedDirectories={expandedDirectories}\n            featureName={featureName}\n            setFeatureName={setFeatureName}\n            toggleDirectoryExpansion={toggleDirectoryExpansion}\n          />\n        );\n      case 1:\n        return (\n          <StepTwoDescribeRelations\n            files={fileCompatibleFiles}\n            dependenciesData={dependenciesData}\n          />\n        );\n      case 2:\n        return <StepThreeViewResults />;\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <Container size="md" className="h-full flex flex-col">\n      <Center className="my-auto">\n        <Paper className="w-full max-w-[700px] h-full shadow-lg rounded-md p-xl">\n          <div className="flex flex-col">\n            {/* Step Progress Indicator */}\n            <Box>\n              <Stepper active={currentStep} size="sm">\n                {stepTitles.map((title, index) => (\n                  <Stepper.Step key={index} label={title} data-qa={`step`} />\n                ))}\n              </Stepper>\n            </Box>\n\n            {/* Step Content */}\n            <div className="mt-xl">{renderStepContent()}</div>\n\n            {/* Navigation */}\n            <div className="mt-xl">\n              <StepperNavigationButtons\n                currentStep={currentStep}\n                totalSteps={totalSteps}\n                onNext={handleNext}\n                onPrevious={handlePrevious}\n                canProceedToNext={canProceedToNext}\n                nextButtonTooltip={getNextButtonTooltip()}\n              />\n            </div>\n          </div>\n        </Paper>\n      </Center>\n    </Container>\n  );\n}\n',
    size: 4902,
    dependents: [],
  },
  {
    path: "ui/src/hooks/use-dependencies.tsx",
    name: "use-dependencies.tsx",
    content:
      'import { useState } from "react";\nimport type { Edge } from "../routes/(generate-tests)/-components/interactive-canvas/interactive-canvas";\n\nexport interface Dependency {\n  id: string;\n  from: string;\n  to: string;\n  connection: string;\n}\n\n// Make the hook more flexible to accept file-like objects\ninterface FileWithPathOrContent {\n  path?: string;\n  name: string;\n  size?: number;\n}\n\nexport function useDependencies(files: FileWithPathOrContent[]) {\n  const [dependencies, setDependencies] = useState<Dependency[]>([]);\n\n  // Generate file options for select dropdowns\n  const fileOptions = files.map((file) => ({\n    value: file.path || file.name,\n    label: file.path || file.name,\n  }));\n\n  const connectionOptions = [\n    { value: "uses", label: "uses" },\n    { value: "tests", label: "tests" },\n    { value: "describes", label: "describes" },\n  ];\n\n  const addDependency = () => {\n    const newDependency: Dependency = {\n      id: crypto.randomUUID(),\n      from: "",\n      to: "",\n      connection: "uses",\n    };\n    setDependencies([...dependencies, newDependency]);\n  };\n\n  const updateDependency = (\n    id: string,\n    field: keyof Dependency,\n    value: string\n  ) => {\n    setDependencies(\n      dependencies.map((dep) =>\n        dep.id === id ? { ...dep, [field]: value } : dep\n      )\n    );\n  };\n\n  const removeDependency = (id: string) => {\n    setDependencies(dependencies.filter((dep) => dep.id !== id));\n  };\n\n  // Convert dependencies to edges for the canvas\n  const convertDependenciesToEdges = (): Edge[] => {\n    // Create mapping from file path/name to node ID\n    const fileToNodeIdMap = new Map<string, string>();\n    files.forEach((file, index) => {\n      const fileIdentifier = file.path || file.name;\n      fileToNodeIdMap.set(fileIdentifier, `file-${index}`);\n    });\n\n    // Convert dependencies to edges\n    return dependencies\n      .filter((dep) => {\n        // Only include dependencies where both from and to files exist\n        return fileToNodeIdMap.has(dep.from) && fileToNodeIdMap.has(dep.to);\n      })\n      .map((dep) => ({\n        id: dep.id,\n        from: fileToNodeIdMap.get(dep.from)!,\n        to: fileToNodeIdMap.get(dep.to)!,\n        description: dep.connection,\n      }));\n  };\n\n  const edges = convertDependenciesToEdges();\n\n  const generateDependencies = () => {\n    // For now, this is a placeholder. In a real implementation, this could:\n    // - Use AI to analyze files and suggest dependencies\n    // - Parse imports/exports to find relationships\n    // - Add some basic dependencies based on file structure\n    console.log("Generate dependencies functionality to be implemented");\n  };\n\n  return {\n    dependencies,\n    fileOptions,\n    connectionOptions,\n    edges,\n    addDependency,\n    updateDependency,\n    removeDependency,\n    generateDependencies,\n  };\n}\n',
    size: 2822,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/hooks/use-repo-connection.ts",
    name: "use-repo-connection.ts",
    content:
      'import { useState, useCallback } from "react";\nimport {\n  type RepoConnection,\n  type RepoFile,\n  type SelectedRepoFile,\n} from "../types/repo";\nimport { apiPost } from "../utils/api";\nimport { getImportedFilesToSelect } from "../utils/import-parser.utils";\n\nexport interface UseRepoConnectionReturn {\n  // Connection state\n  connection: RepoConnection | null;\n  isConnected: boolean;\n  isConnecting: boolean;\n  connectionError: string | null;\n\n  // File listing state\n  repoFiles: RepoFile[];\n  isLoadingFiles: boolean;\n  fileLoadError: string | null;\n\n  // Selected files state\n  selectedFiles: SelectedRepoFile[];\n\n  // File content loading state\n  loadingFiles: Set<string>;\n\n  // Actions\n  connectToRepo: (repoUrl: string, token: string) => Promise<void>;\n  disconnect: () => void;\n  loadRepoFiles: () => Promise<void>;\n  toggleFileSelection: (\n    file: RepoFile,\n    autoSelectImports?: boolean\n  ) => Promise<void>;\n  autoSelectImportedFiles: (file: SelectedRepoFile) => Promise<void>;\n  clearSelectedFiles: () => void;\n}\n\nexport function useRepoConnection(): UseRepoConnectionReturn {\n  const [connection, setConnection] = useState<RepoConnection | null>(null);\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [connectionError, setConnectionError] = useState<string | null>(null);\n\n  const [repoFiles, setRepoFiles] = useState<RepoFile[]>([]);\n  const [isLoadingFiles, setIsLoadingFiles] = useState(false);\n  const [fileLoadError, setFileLoadError] = useState<string | null>(null);\n\n  const [selectedFiles, setSelectedFiles] = useState<SelectedRepoFile[]>([]);\n  const [loadingFiles, setLoadingFiles] = useState<Set<string>>(new Set());\n\n  const parseRepoUrl = (url: string) => {\n    // Support both HTTPS and SSH GitHub URLs\n    const githubHttpsMatch = url.match(\n      /https:\\/\\/github\\.com\\/([^\\/]+)\\/([^\\/]+)(?:\\.git)?/\n    );\n    const githubSshMatch = url.match(\n      /git@github\\.com:([^\\/]+)\\/([^\\/]+)(?:\\.git)?/\n    );\n\n    if (githubHttpsMatch) {\n      return {\n        provider: "github" as const,\n        owner: githubHttpsMatch[1],\n        repo: githubHttpsMatch[2].replace(".git", ""),\n      };\n    }\n\n    if (githubSshMatch) {\n      return {\n        provider: "github" as const,\n        owner: githubSshMatch[1],\n        repo: githubSshMatch[2].replace(".git", ""),\n      };\n    }\n\n    throw new Error(\n      "Unsupported repository URL format. Please use a GitHub HTTPS or SSH URL."\n    );\n  };\n\n  const connectToRepo = useCallback(async (repoUrl: string, token: string) => {\n    setIsConnecting(true);\n    setConnectionError(null);\n\n    try {\n      const { provider, owner, repo } = parseRepoUrl(repoUrl);\n\n      // Test the connection by making a simple API call\n      await apiPost({\n        endpoint: "/repo/test-connection",\n        body: { provider, owner, repo, token },\n      });\n\n      const newConnection: RepoConnection = {\n        provider,\n        url: repoUrl,\n        token,\n        owner,\n        repo,\n      };\n\n      setConnection(newConnection);\n      console.log("Successfully connected to repository:", { owner, repo });\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : "Failed to connect to repository";\n      setConnectionError(errorMessage);\n      console.error("Repository connection failed:", error);\n    } finally {\n      setIsConnecting(false);\n    }\n  }, []);\n\n  const disconnect = useCallback(() => {\n    setConnection(null);\n    setRepoFiles([]);\n    setSelectedFiles([]);\n    setLoadingFiles(new Set());\n    setConnectionError(null);\n    setFileLoadError(null);\n  }, []);\n\n  const loadRepoFiles = useCallback(async () => {\n    if (!connection) return;\n\n    setIsLoadingFiles(true);\n    setFileLoadError(null);\n\n    try {\n      const response = await apiPost<typeof connection, RepoFile[]>({\n        endpoint: "/repo/list-files",\n        body: connection,\n      });\n\n      // Filter to only show supported file types\n      const supportedExtensions = [".js", ".jsx", ".ts", ".tsx"];\n      const filteredFiles = response.filter(\n        (file) =>\n          file.type === "file" &&\n          supportedExtensions.some((ext) =>\n            file.path.toLowerCase().endsWith(ext)\n          )\n      );\n\n      setRepoFiles(filteredFiles);\n      console.log("Loaded repository files:", filteredFiles.length);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : "Failed to load repository files";\n      setFileLoadError(errorMessage);\n      console.error("Failed to load repository files:", error);\n    } finally {\n      setIsLoadingFiles(false);\n    }\n  }, [connection]);\n\n  const selectFileWithoutAutoImports = useCallback(\n    async (file: RepoFile) => {\n      if (!connection) return null;\n\n      // Set loading state for this file\n      setLoadingFiles((prev) => new Set([...prev, file.path]));\n\n      try {\n        const response = await apiPost<\n          { connection: RepoConnection; filePath: string },\n          { content: string }\n        >({\n          endpoint: "/repo/get-file-content",\n          body: { connection, filePath: file.path },\n        });\n\n        const selectedFile: SelectedRepoFile = {\n          path: file.path,\n          name: file.name,\n          content: response.content,\n          size: file.size || 0,\n        };\n\n        setSelectedFiles((prev) => [...prev, selectedFile]);\n        console.log("Added file to selection:", file.path);\n        return selectedFile;\n      } catch (error) {\n        console.error("Failed to fetch file content:", error);\n        return null;\n      } finally {\n        // Remove loading state for this file\n        setLoadingFiles((prev) => {\n          const newSet = new Set(prev);\n          newSet.delete(file.path);\n          return newSet;\n        });\n      }\n    },\n    [connection]\n  );\n\n  const autoSelectImportedFiles = useCallback(\n    async (file: SelectedRepoFile) => {\n      if (!connection) return;\n\n      try {\n        // Get imported files that should be auto-selected\n        const importedFiles = getImportedFilesToSelect(\n          file.content,\n          file.path,\n          repoFiles\n        );\n\n        console.log({\n          content: file.content,\n          path: file.path,\n          repoFiles: repoFiles,\n        });\n\n        console.log(\n          `Found ${importedFiles.length} imported files for ${file.path}:`,\n          importedFiles.map((f) => f.path)\n        );\n\n        // Filter out files that are already selected\n        const filesToSelect = importedFiles.filter(\n          (importedFile) =>\n            !selectedFiles.some(\n              (selected) => selected.path === importedFile.path\n            )\n        );\n\n        if (filesToSelect.length === 0) {\n          console.log("No new imported files to select");\n          return;\n        }\n\n        console.log(`Auto-selecting ${filesToSelect.length} imported files...`);\n\n        // Select each imported file (without triggering auto-select recursively)\n        for (const importedFile of filesToSelect) {\n          await selectFileWithoutAutoImports(importedFile);\n        }\n      } catch (error) {\n        console.error("Failed to auto-select imported files:", error);\n      }\n    },\n    [connection, repoFiles, selectedFiles, selectFileWithoutAutoImports]\n  );\n\n  const toggleFileSelection = useCallback(\n    async (file: RepoFile, autoSelectImports = true) => {\n      if (!connection) return;\n\n      const isSelected = selectedFiles.some((f) => f.path === file.path);\n\n      if (isSelected) {\n        // Remove from selection\n        setSelectedFiles((prev) => prev.filter((f) => f.path !== file.path));\n      } else {\n        // Add to selection - need to fetch file content\n        const selectedFile = await selectFileWithoutAutoImports(file);\n\n        // Auto-select imported files if requested and file was successfully selected\n        if (autoSelectImports && selectedFile) {\n          // Use a small delay to ensure state has updated\n          setTimeout(() => {\n            autoSelectImportedFiles(selectedFile);\n          }, 100);\n        }\n      }\n    },\n    [\n      connection,\n      selectedFiles,\n      selectFileWithoutAutoImports,\n      autoSelectImportedFiles,\n    ]\n  );\n\n  const clearSelectedFiles = useCallback(() => {\n    setSelectedFiles([]);\n  }, []);\n\n  return {\n    // Connection state\n    connection,\n    isConnected: !!connection,\n    isConnecting,\n    connectionError,\n\n    // File listing state\n    repoFiles,\n    isLoadingFiles,\n    fileLoadError,\n\n    // Selected files state\n    selectedFiles,\n\n    // File content loading state\n    loadingFiles,\n\n    // Actions\n    connectToRepo,\n    disconnect,\n    loadRepoFiles,\n    toggleFileSelection,\n    autoSelectImportedFiles,\n    clearSelectedFiles,\n  };\n}\n',
    size: 8799,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/components/stepper-navigation-buttons/index.ts",
    name: "index.ts",
    content:
      'export { StepperNavigationButtons } from "./stepper-navigation-buttons";\n',
    size: 73,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
    name: "step-one-upload-files.tsx",
    content:
      '// # 7. Main Step One Upload Files Component\n// Orchestrates the file upload and selection process with repository connection\n\nimport { Title, Text } from "@mantine/core";\nimport { useCallback } from "react";\nimport { type UseRepoConnectionReturn } from "src/hooks/use-repo-connection";\n\n// # 7.1 Extracted Component Imports\nimport { ConnectionForm } from "src/routes/(generate-tests)/-components/step-one-upload-files/connection-form";\nimport { RepositoryHeader } from "src/routes/(generate-tests)/-components/step-one-upload-files/repository-header";\nimport { FileTreeDisplay } from "src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display";\nimport type { TreeNode } from "./tree-item";\n\n// # 7.2 Component Props Interface\ninterface StepOneUploadFilesProps {\n  repoConnectionData: UseRepoConnectionReturn;\n  repoUrl: string;\n  setRepoUrl: (repoUrl: string) => void;\n  accessToken: string;\n  setAccessToken: (accessToken: string) => void;\n  fileTree: TreeNode[];\n  expandedDirectories: Set<string>;\n  featureName: string;\n  setFeatureName: (featureName: string) => void;\n  toggleDirectoryExpansion: (path: string) => void;\n}\n\n// # 7.3 Main Component Implementation\n// Orchestrates the complete file upload and selection workflow\nexport function StepOneUploadFiles({\n  repoConnectionData,\n  repoUrl,\n  setRepoUrl,\n  accessToken,\n  setAccessToken,\n  fileTree,\n  expandedDirectories,\n  featureName,\n  setFeatureName,\n  toggleDirectoryExpansion,\n}: StepOneUploadFilesProps) {\n  // # 7.3.2 Repository Connection Data\n  const {\n    connection,\n    isConnected,\n    isConnecting,\n    connectionError,\n    repoFiles,\n    isLoadingFiles,\n    fileLoadError,\n    selectedFiles,\n    loadingFiles,\n    connectToRepo,\n    disconnect,\n    loadRepoFiles,\n    toggleFileSelection,\n  } = repoConnectionData;\n\n  // # 7.3.5 Event Handlers (Memoized to prevent unnecessary re-renders)\n\n  // # 7.3.5.1 Connection Handlers\n  const handleConnect = useCallback(async () => {\n    if (!repoUrl.trim() || !accessToken.trim()) {\n      return;\n    }\n    await connectToRepo(repoUrl.trim(), accessToken.trim());\n  }, [repoUrl, accessToken, connectToRepo]);\n\n  const handleDisconnect = useCallback(() => {\n    disconnect();\n    setRepoUrl("");\n    setAccessToken("");\n  }, [disconnect, setRepoUrl, setAccessToken]);\n\n  // # 7.3.5.2 File Management Handlers\n  const handleLoadFiles = useCallback(() => {\n    loadRepoFiles();\n  }, [loadRepoFiles]);\n\n  // # 7.3.5.3 Feature Name Handler\n  const handleFeatureNameChange = useCallback((value: string) => {\n    setFeatureName(value);\n  }, []);\n\n  // # 7.3.6 Conditional Rendering\n\n  // # 7.3.6.1 Connection Form State\n  if (!isConnected) {\n    return (\n      <ConnectionForm\n        repoUrl={repoUrl}\n        accessToken={accessToken}\n        isConnecting={isConnecting}\n        connectionError={connectionError}\n        onRepoUrlChange={setRepoUrl}\n        onAccessTokenChange={setAccessToken}\n        onConnect={handleConnect}\n      />\n    );\n  }\n\n  // # 7.3.6.2 Connected State\n  return (\n    <div className="gap-lg">\n      {/* # 7.3.6.2.1 Page Header */}\n      <div className="text-center">\n        <Title order={1} size="h2" className="mb-md">\n          Repository Connected\n        </Title>\n        <Text size="lg" className="text-gray-600">\n          Select the files you want to analyze from {connection?.owner}/\n          {connection?.repo}\n        </Text>\n      </div>\n\n      {/* # 7.3.6.2.2 Repository Management */}\n      <RepositoryHeader\n        connection={connection}\n        isLoadingFiles={isLoadingFiles}\n        onRefresh={handleLoadFiles}\n        onDisconnect={handleDisconnect}\n      />\n\n      {/* # 7.3.6.2.3 File Tree Display */}\n      <FileTreeDisplay\n        repoFiles={repoFiles}\n        selectedFiles={selectedFiles}\n        fileTree={fileTree}\n        isLoadingFiles={isLoadingFiles}\n        fileLoadError={fileLoadError}\n        loadingFiles={loadingFiles}\n        expandedDirectories={expandedDirectories}\n        featureName={featureName}\n        onLoadFiles={handleLoadFiles}\n        onToggleExpanded={toggleDirectoryExpansion}\n        onToggleSelection={toggleFileSelection}\n        onFeatureNameChange={handleFeatureNameChange}\n      />\n    </div>\n  );\n}\n',
    size: 4227,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/connection-form.tsx",
    name: "connection-form.tsx",
    content:
      '// # 4. Repository Connection Form Component\n// Handles GitHub repository authentication and connection\n\nimport {\n  Stack,\n  Box,\n  Title,\n  Text,\n  TextInput,\n  PasswordInput,\n  Button,\n  Alert,\n  Paper,\n  Group,\n} from "@mantine/core";\nimport { IconBrandGithub, IconAlertCircle } from "@tabler/icons-react";\n\n// # 4.1 Component Props Interface\ninterface ConnectionFormProps {\n  repoUrl: string;\n  accessToken: string;\n  isConnecting: boolean;\n  connectionError: string | null;\n  onRepoUrlChange: (url: string) => void;\n  onAccessTokenChange: (token: string) => void;\n  onConnect: () => void;\n}\n\n// # 4.2 Main Connection Form Component\n// Provides UI for GitHub repository connection with validation and error handling\nexport function ConnectionForm({\n  repoUrl,\n  accessToken,\n  isConnecting,\n  connectionError,\n  onRepoUrlChange,\n  onAccessTokenChange,\n  onConnect,\n}: ConnectionFormProps) {\n  // # 4.2.1 Form Validation\n  const isFormValid = repoUrl.trim() && accessToken.trim();\n\n  return (\n    <Stack className="gap-lg">\n      {/* # 4.2.2 Header Section */}\n      <Box className="text-center">\n        <Title order={1} size="h2" className="mb-md">\n          Welcome to Handoff\n        </Title>\n        <Text className="text-gray-600">\n          Connect your repository to generate natural language test cases\n        </Text>\n      </Box>\n\n      {/* # 4.2.3 Connection Form */}\n      <Paper className="border-gray-200 rounded-md p-xl">\n        <Stack className="gap-md">\n          {/* # 4.2.3.1 Form Header */}\n          <Group className="gap-xs">\n            <IconBrandGithub size={24} />\n            <Title order={3} size="h4">\n              Connect Your Repository\n            </Title>\n          </Group>\n\n          {/* # 4.2.3.2 Form Description */}\n          <Text size="sm" className="text-gray-600">\n            Connect to your GitHub repository (including private repos) to\n            select and analyze your code files.\n          </Text>\n\n          {/* # 4.2.3.3 Repository URL Input */}\n          <TextInput\n            label="Repository URL"\n            placeholder="https://github.com/username/repository or git@github.com:username/repository.git"\n            value={repoUrl}\n            onChange={(e) => onRepoUrlChange(e.currentTarget.value)}\n            required\n          />\n\n          {/* # 4.2.3.4 Access Token Input */}\n          <PasswordInput\n            label="Personal Access Token"\n            placeholder="Your GitHub personal access token"\n            description="Create a token at https://github.com/settings/tokens with \'repo\' scope for private repositories"\n            value={accessToken}\n            onChange={(e) => onAccessTokenChange(e.currentTarget.value)}\n            required\n          />\n\n          {/* # 4.2.3.5 Error Display */}\n          {connectionError && (\n            <Alert\n              icon={<IconAlertCircle size="1rem" />}\n              title="Connection Error"\n              color="red"\n            >\n              {connectionError}\n            </Alert>\n          )}\n\n          {/* # 4.2.3.6 Connect Button */}\n          <Button\n            onClick={onConnect}\n            loading={isConnecting}\n            disabled={!isFormValid}\n            leftSection={<IconBrandGithub size="1rem" />}\n          >\n            {isConnecting ? "Connecting..." : "Connect Repository"}\n          </Button>\n        </Stack>\n      </Paper>\n    </Stack>\n  );\n}\n',
    size: 3400,
    dependents: [
      {
        name: "step-one-upload-files.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/repository-header.tsx",
    name: "repository-header.tsx",
    content:
      '// # 5. Repository Header Component\n// Displays connection status and provides repository management controls\n\nimport { Paper, Group, Text, Button, ActionIcon, Tooltip } from "@mantine/core";\nimport { IconCheck, IconX, IconRefresh } from "@tabler/icons-react";\nimport type { RepoConnection } from "src/types/repo";\n\n// # 5.1 Component Props Interface\ninterface RepositoryHeaderProps {\n  connection: RepoConnection | null;\n  isLoadingFiles: boolean;\n  onRefresh: () => void;\n  onDisconnect: () => void;\n}\n\n// # 5.2 Main Repository Header Component\n// Shows connected repository info and provides tree management controls\nexport function RepositoryHeader({\n  connection,\n  isLoadingFiles,\n  onRefresh,\n  onDisconnect,\n}: RepositoryHeaderProps) {\n  return (\n    <Paper className="border-gray-200 rounded-md p-md">\n      <Group className="justify-between">\n        {/* # 5.2.1 Connection Status */}\n        <Group className="gap-xs">\n          <IconCheck size="1rem" color="green" />\n          <Text size="sm" className="font-medium">\n            Connected to {connection?.owner}/{connection?.repo}\n          </Text>\n        </Group>\n\n        {/* # 5.2.2 Action Controls */}\n        <Group className="gap-xs">\n          {/* # 5.2.2.2 Refresh Control */}\n          <Tooltip label="Refresh file list">\n            <ActionIcon\n              variant="light"\n              onClick={onRefresh}\n              loading={isLoadingFiles}\n            >\n              <IconRefresh size="1rem" />\n            </ActionIcon>\n          </Tooltip>\n\n          {/* # 5.2.2.3 Disconnect Control */}\n          <Button\n            size="xs"\n            variant="subtle"\n            color="red"\n            onClick={onDisconnect}\n            leftSection={<IconX size="1rem" />}\n          >\n            Disconnect\n          </Button>\n        </Group>\n      </Group>\n    </Paper>\n  );\n}\n',
    size: 1857,
    dependents: [
      {
        name: "step-one-upload-files.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
      },
    ],
  },
  {
    path: "ui/src/types/repo.ts",
    name: "repo.ts",
    content:
      '// Repository connection types\nexport interface RepoConnection {\n  provider: "github" | "gitlab" | "bitbucket";\n  url: string;\n  token: string;\n  owner: string;\n  repo: string;\n}\n\nexport interface RepoFile {\n  path: string;\n  name: string;\n  type: "file" | "dir";\n  size?: number;\n  content?: string;\n  sha?: string;\n}\n\nexport interface RepoFileTree {\n  path: string;\n  mode: string;\n  type: "blob" | "tree";\n  sha: string;\n  size?: number;\n  url: string;\n}\n\nexport interface SelectedRepoFile {\n  path: string;\n  name: string;\n  content: string;\n  size: number;\n}\n\n// API Response types\nexport interface GitHubContent {\n  name: string;\n  path: string;\n  sha: string;\n  size: number;\n  url: string;\n  html_url: string;\n  git_url: string;\n  download_url: string;\n  type: "file" | "dir";\n  content?: string;\n  encoding?: string;\n}\n\nexport interface GitHubTreeResponse {\n  sha: string;\n  url: string;\n  tree: RepoFileTree[];\n  truncated: boolean;\n}\n',
    size: 945,
    dependents: [
      {
        name: "repository-header.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/repository-header.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display.tsx",
    name: "file-tree-display.tsx",
    content:
      '// # 6. File Tree Display Component\n// Handles the display of file tree structure with loading and error states\n\nimport React, { useMemo } from "react";\nimport { Box, Text, Loader, Alert, Button, TextInput } from "@mantine/core";\nimport { IconAlertCircle } from "@tabler/icons-react";\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\nimport { TreeItem, type TreeNode } from "./tree-item";\n\n// # 6.1 Component Props Interface\ninterface FileTreeDisplayProps {\n  repoFiles: RepoFile[];\n  selectedFiles: SelectedRepoFile[];\n  fileTree: TreeNode[];\n  isLoadingFiles: boolean;\n  fileLoadError: string | null;\n  loadingFiles: Set<string>;\n  expandedDirectories: Set<string>;\n  featureName: string;\n  onLoadFiles: () => void;\n  onToggleExpanded: (path: string) => void;\n  onToggleSelection: (file: RepoFile) => void;\n  onFeatureNameChange: (value: string) => void;\n}\n\n// # 6.2 Main File Tree Display Component\n// Manages different display states and renders the tree structure\nexport const FileTreeDisplay = React.memo(function FileTreeDisplay({\n  repoFiles,\n  selectedFiles,\n  fileTree,\n  isLoadingFiles,\n  fileLoadError,\n  loadingFiles,\n  expandedDirectories,\n  featureName,\n  onLoadFiles,\n  onToggleExpanded,\n  onToggleSelection,\n  onFeatureNameChange,\n}: FileTreeDisplayProps) {\n  // # 6.2.1 Render Tree Function\n  // Creates TreeItem components for each root node (memoized to prevent recreation)\n  const renderedTree = useMemo(() => {\n    return fileTree.map((node) => (\n      <TreeItem\n        key={node.path}\n        node={node}\n        expandedDirectories={expandedDirectories}\n        selectedFiles={selectedFiles}\n        loadingFiles={loadingFiles}\n        onToggleExpanded={onToggleExpanded}\n        onToggleSelection={onToggleSelection}\n      />\n    ));\n  }, [\n    fileTree,\n    expandedDirectories,\n    selectedFiles,\n    loadingFiles,\n    onToggleExpanded,\n    onToggleSelection,\n  ]);\n\n  return (\n    <>\n      {/* # 6.2.2 Empty State - No Files Loaded */}\n      {!repoFiles.length && !isLoadingFiles && !fileLoadError && (\n        <Box className="my-xl text-center">\n          <Text className="text-gray-600 mb-md" size="sm">\n            Click "Load Files" to browse your repository files\n          </Text>\n          <Button onClick={onLoadFiles} variant="light">\n            Load Files\n          </Button>\n        </Box>\n      )}\n\n      {/* # 6.2.3 Loading State */}\n      {isLoadingFiles && (\n        <Box className="my-xl text-center">\n          <Loader size="sm" className="mb-md" />\n          <Text size="sm" className="text-gray-600">\n            Loading repository files...\n          </Text>\n        </Box>\n      )}\n\n      {/* # 6.2.4 Error State */}\n      {fileLoadError && (\n        <Alert\n          icon={<IconAlertCircle size="1rem" />}\n          title="Error Loading Files"\n          color="red"\n          className="mb-md"\n        >\n          {fileLoadError}\n        </Alert>\n      )}\n\n      {/* # 6.2.5 Files Display */}\n      {repoFiles.length > 0 && (\n        <div>\n          {/* # 6.2.5.0 Feature Name Input */}\n          <TextInput\n            label="Feature Name"\n            description="The feature you are doing the handoff for"\n            value={featureName}\n            onChange={(event) => onFeatureNameChange(event.currentTarget.value)}\n            placeholder="Enter feature name..."\n          />\n\n          {/* # 6.2.5.1 File Count Summary */}\n          <Text size="sm" className="text-gray-600 mt-md mb-xs text-xs">\n            {selectedFiles.length} of {repoFiles.length} files selected  Only\n            JavaScript/TypeScript files are shown\n          </Text>\n\n          {/* # 6.2.5.2 Scrollable Tree Container */}\n          <div className="h-[400px] overflow-y-auto flex flex-col gap-xs">\n            {renderedTree}\n          </div>\n        </div>\n      )}\n    </>\n  );\n});\n',
    size: 3841,
    dependents: [
      {
        name: "step-one-upload-files.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/step-one-upload-files.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/tree-item.tsx",
    name: "tree-item.tsx",
    content:
      '// # 1. Tree Item Component\n// This component renders individual nodes in the file tree structure\n\nimport React, { useCallback, useMemo } from "react";\nimport { Checkbox, ActionIcon, Collapse, Loader } from "@mantine/core";\nimport clsx from "clsx";\nimport {\n  IconFile,\n  IconFolder,\n  IconFolderOpen,\n  IconChevronRight,\n  IconChevronDown,\n} from "@tabler/icons-react";\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\nimport styles from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-item.module.css";\n\n// # 1.1 TreeNode Interface\n// Represents a single node in the file tree structure\nexport interface TreeNode {\n  path: string;\n  name: string;\n  type: "file" | "directory";\n  file?: RepoFile;\n  children: TreeNode[];\n  depth: number;\n}\n\n// # 1.2 TreeItem Props Interface\ninterface TreeItemProps {\n  node: TreeNode;\n  expandedDirectories: Set<string>;\n  selectedFiles: SelectedRepoFile[];\n  loadingFiles: Set<string>;\n  onToggleExpanded: (path: string) => void;\n  onToggleSelection: (file: RepoFile) => void;\n}\n\n// # 1.3 Main TreeItem Component\n// Renders a single tree node with expand/collapse and selection functionality\nexport const TreeItem = React.memo(function TreeItem({\n  node,\n  expandedDirectories,\n  selectedFiles,\n  loadingFiles,\n  onToggleExpanded,\n  onToggleSelection,\n}: TreeItemProps) {\n  // # 1.3.1 Node State Calculations\n  const hasChildren = node.children.length > 0;\n  const isFile = node.type === "file";\n  const isExpanded = expandedDirectories.has(node.path);\n  const isSelected = node.file\n    ? selectedFiles.some((f) => f.path === node.file!.path)\n    : false;\n  const isLoading = node.file ? loadingFiles.has(node.file.path) : false;\n\n  // # 1.3.2 Click Handler\n  // Handles clicks on files (selection) and directories (expand/collapse)\n  const handleClick = useCallback(() => {\n    if (isFile && node.file && !isLoading) {\n      onToggleSelection(node.file);\n    } else if (hasChildren) {\n      onToggleExpanded(node.path);\n    }\n  }, [\n    isFile,\n    node.file,\n    node.path,\n    isLoading,\n    hasChildren,\n    onToggleSelection,\n    onToggleExpanded,\n  ]);\n\n  const paperStyle = useMemo(() => {\n    return {\n      "--node-depth-margin": `${node.depth * 20}px`,\n    } as React.CSSProperties;\n  }, [node.depth]);\n\n  return (\n    <div>\n      {/* # 1.3.3 Node Container */}\n      <div\n        className={`${styles.nodeContainer} ${\n          isFile && isSelected ? styles.selected : ""\n        } p-xs rounded-sm shadow-xs border border-gray-200`}\n        style={paperStyle}\n        onClick={handleClick}\n      >\n        <div className="flex gap-xs  justify-between">\n          {/* # 1.3.4 Left Content Group */}\n          <div\n            className={`${styles.contentGroup} items-center flex flex-1 gap-xs`}\n          >\n            {/* # 1.3.4.1 Expansion Controls */}\n            {!isFile && hasChildren && (\n              <ActionIcon\n                variant="transparent"\n                size="sm"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  onToggleExpanded(node.path);\n                }}\n              >\n                {isExpanded ? (\n                  <IconChevronDown size="0.8rem" />\n                ) : (\n                  <IconChevronRight size="0.8rem" />\n                )}\n              </ActionIcon>\n            )}\n            {!isFile && !hasChildren && (\n              <div className="w-5" /> // Spacer for alignment\n            )}\n\n            {/* # 1.3.4.2 File Selection Checkbox or Loading Spinner */}\n            {isFile ? (\n              <div className={`${styles.checkboxContainer} w-5 h-5`}>\n                {isLoading ? (\n                  <Loader size="xs" />\n                ) : (\n                  <Checkbox\n                    checked={isSelected}\n                    onChange={() => {}} // Controlled by parent click\n                    size="sm"\n                  />\n                )}\n              </div>\n            ) : null}\n\n            {/* # 1.3.4.3 Node Icon */}\n            {isFile ? (\n              <IconFile size="1rem" />\n            ) : (\n              <>\n                {isExpanded ? (\n                  <IconFolderOpen size="1rem" />\n                ) : (\n                  <IconFolder size="1rem" />\n                )}\n              </>\n            )}\n\n            {/* # 1.3.4.4 Node Name */}\n            <div className={styles.nodeNameContainer}>\n              <div\n                className={clsx(\n                  isFile ? "font-medium" : "text-gray-600",\n                  "text-sm select-none"\n                )}\n              >\n                {node.name}\n              </div>\n            </div>\n          </div>\n\n          {/* # 1.3.5 Right Content - File Size */}\n          {isFile && node.file?.size && (\n            <p className="text-gray-600 text-xs">\n              {Math.round(node.file.size / 1024)}KB\n            </p>\n          )}\n        </div>\n      </div>\n\n      {/* # 1.3.6 Children Container */}\n      {!isFile && hasChildren && (\n        <Collapse in={isExpanded} transitionDuration={0}>\n          <div className="mt-xs gap-xs flex flex-col">\n            {node.children.map((child) => (\n              <TreeItem\n                key={child.path}\n                node={child}\n                expandedDirectories={expandedDirectories}\n                selectedFiles={selectedFiles}\n                loadingFiles={loadingFiles}\n                onToggleExpanded={onToggleExpanded}\n                onToggleSelection={onToggleSelection}\n              />\n            ))}\n          </div>\n        </Collapse>\n      )}\n    </div>\n  );\n});\n',
    size: 5619,
    dependents: [
      {
        name: "file-tree-display.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/file-tree-display.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations.tsx",
    name: "step-two-describe-relations.tsx",
    content:
      'import { useState } from "react";\nimport {\n  Stack,\n  Box,\n  Title,\n  Text,\n  Tabs,\n  Button,\n  Select,\n  Group,\n  Paper,\n  ActionIcon,\n  Space,\n} from "@mantine/core";\nimport { IconPlus, IconSparkles, IconTrash } from "@tabler/icons-react";\n// Use a more flexible file interface that works with both uploaded and repo files\ninterface FileWithPathLike {\n  path?: string;\n  name: string;\n  size?: number;\n}\nimport { InteractiveCanvas } from "src/routes/(generate-tests)/-components/interactive-canvas/interactive-canvas";\nimport type { Dependency } from "src/hooks/use-dependencies";\n\ninterface DependenciesData {\n  dependencies: Dependency[];\n  fileOptions: { value: string; label: string }[];\n  connectionOptions: { value: string; label: string }[];\n  edges: Array<{ id: string; from: string; to: string; description: string }>;\n  addDependency: () => void;\n  updateDependency: (\n    id: string,\n    field: keyof Dependency,\n    value: string\n  ) => void;\n  removeDependency: (id: string) => void;\n  generateDependencies: () => void;\n}\n\ninterface StepTwoDescribeRelationsProps {\n  files: FileWithPathLike[];\n  dependenciesData: DependenciesData;\n}\n\nexport function StepTwoDescribeRelations({\n  files,\n  dependenciesData,\n}: StepTwoDescribeRelationsProps) {\n  const [activeTab, setActiveTab] = useState<string>("describe");\n  const {\n    dependencies,\n    fileOptions,\n    connectionOptions,\n    edges,\n    addDependency,\n    updateDependency,\n    removeDependency,\n    generateDependencies,\n  } = dependenciesData;\n\n  return (\n    <Stack className="gap-lg">\n      <Box className="text-center">\n        <Title order={2} className="mb-md">\n          Configure File Relationships\n        </Title>\n        <Text size="lg" className="text-gray-600">\n          Describe file relationships or visualize them interactively\n        </Text>\n      </Box>\n\n      {files.length > 0 ? (\n        <Tabs\n          value={activeTab}\n          onChange={(value) => setActiveTab(value || "describe")}\n        >\n          <Tabs.List grow>\n            <Tabs.Tab value="describe">Describe</Tabs.Tab>\n            <Tabs.Tab value="visualize">Visualize</Tabs.Tab>\n          </Tabs.List>\n\n          <Space h="md" />\n\n          <Tabs.Panel value="describe">\n            <Stack className="gap-md">\n              <Group className="justify-between items-center">\n                <Text size="lg" className="font-medium">\n                  Dependencies\n                </Text>\n                <Group gap="xs">\n                  <Button\n                    leftSection={<IconSparkles size={16} />}\n                    onClick={generateDependencies}\n                    variant="light"\n                  >\n                    Generate\n                  </Button>\n                  <Button\n                    leftSection={<IconPlus size={16} />}\n                    onClick={addDependency}\n                    variant="light"\n                  >\n                    Add\n                  </Button>\n                </Group>\n              </Group>\n\n              {dependencies.length === 0 ? (\n                <Paper className="border-gray-200 rounded-md p-lg">\n                  <Text className="text-center text-gray-600">\n                    No dependencies defined yet. Click "Generate" or "Add" to\n                    get started.\n                  </Text>\n                </Paper>\n              ) : (\n                <Stack className="gap-sm">\n                  {dependencies.map((dependency) => (\n                    <Paper\n                      key={dependency.id}\n                      className="border-gray-200 rounded-md p-md"\n                    >\n                      <Group className="justify-between flex-end">\n                        <Group className="flex-1 flex-end wrap-nowrap">\n                          <Select\n                            label="From"\n                            placeholder="Select file"\n                            data={fileOptions}\n                            value={dependency.from}\n                            comboboxProps={{\n                              width: "max-content",\n                              position: "bottom-start",\n                              middlewares: { flip: false, shift: false },\n                            }}\n                            onChange={(value) =>\n                              updateDependency(\n                                dependency.id,\n                                "from",\n                                value || ""\n                              )\n                            }\n                            style={{ minWidth: 200 }}\n                          />\n                          <Select\n                            label="Connection"\n                            data={connectionOptions}\n                            value={dependency.connection}\n                            onChange={(value) =>\n                              updateDependency(\n                                dependency.id,\n                                "connection",\n                                value || "uses"\n                              )\n                            }\n                            className="min-w-[120px]"\n                          />\n                          <Select\n                            label="To"\n                            placeholder="Select file"\n                            data={fileOptions}\n                            value={dependency.to}\n                            onChange={(value) =>\n                              updateDependency(dependency.id, "to", value || "")\n                            }\n                            className="min-w-[200px]"\n                          />\n                        </Group>\n                        <div className={Select.classes.wrapper}>\n                          <Box className="flex items-center h-[var(--input-height)]">\n                            <ActionIcon\n                              variant="subtle"\n                              color="red"\n                              onClick={() => removeDependency(dependency.id)}\n                            >\n                              <IconTrash size={16} />\n                            </ActionIcon>\n                          </Box>\n                        </div>\n                      </Group>\n                    </Paper>\n                  ))}\n                </Stack>\n              )}\n            </Stack>\n          </Tabs.Panel>\n\n          <Tabs.Panel value="visualize">\n            <Stack className="gap-md">\n              <Text size="sm" className="text-gray-600">\n                Drag nodes to organize them. Use mouse wheel to zoom, click and\n                drag empty space to pan.\n              </Text>\n              <InteractiveCanvas files={files} edges={edges} />\n            </Stack>\n          </Tabs.Panel>\n        </Tabs>\n      ) : (\n        <Text className="text-center text-orange-500">\n          No files available. Please go back to step 1 and upload some files.\n        </Text>\n      )}\n    </Stack>\n  );\n}\n',
    size: 7011,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/interactive-canvas/interactive-canvas.tsx",
    name: "interactive-canvas.tsx",
    content:
      '/* eslint-disable react-refresh/only-export-components */\nimport { useRef, useState, useMemo, useEffect } from "react";\nimport { Box } from "@mantine/core";\n// Make the canvas work with any file-like object that has a name\ninterface FileWithName {\n  name: string;\n}\nimport * as d3 from "d3";\n\n// ## 1. Type Definitions and Interfaces\n// ### 1.1. Point interface for coordinates\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n// ### 1.2. Node position interface (SVG coordinate space)\nexport interface NodePosition {\n  x: number;\n  y: number;\n}\n\n// ### 1.3. File node data interface\ninterface FileNodeData {\n  id: string;\n  name: string;\n  position: NodePosition;\n}\n\n// ### 1.4. Edge interface for connections between nodes\nexport interface Edge {\n  id: string;\n  from: string;\n  to: string;\n  description: string;\n}\n\n// ### 1.5. Canvas state interface\nexport interface CanvasState {\n  zoom: number;\n  pan: Point;\n  selectedNodeId: string | null;\n  isDragging: boolean;\n  dragType: "canvas" | "node" | null;\n  draggedNodeId: string | null;\n  dragStartPoint: Point | null;\n}\n\n// ### 1.6. Interactive canvas component props\ninterface InteractiveCanvasProps {\n  files: FileWithName[];\n  edges?: Edge[];\n}\n\n// ## 2. Constants and Configuration\nconst NODE_WIDTH = 120;\nconst NODE_HEIGHT = 60;\nconst GRID_SPACING = 180;\nexport const MIN_ZOOM = 0.1;\nexport const MAX_ZOOM = 3;\n\n// ## 3. Canvas Action Functions - Pure functions for testability\n\n// ### 3.1. dragCanvas - Pan the canvas view\nexport function dragCanvas(\n  state: CanvasState,\n  startPoint: Point,\n  currentPoint: Point\n): CanvasState {\n  // #### 3.1.1. Calculate movement delta\n  const deltaX = currentPoint.x - startPoint.x;\n  const deltaY = currentPoint.y - startPoint.y;\n\n  // #### 3.1.2. Return new state with updated pan position\n  return {\n    ...state,\n    pan: {\n      x: state.pan.x + deltaX,\n      y: state.pan.y + deltaY,\n    },\n  };\n}\n\n// ### 3.2. zoom - Zoom in/out at a specific point\nexport function zoom(\n  state: CanvasState,\n  zoomPoint: Point,\n  zoomDelta: number\n): CanvasState {\n  // #### 3.2.1. Calculate new zoom level within bounds\n  const newZoom = Math.max(\n    MIN_ZOOM,\n    Math.min(MAX_ZOOM, state.zoom * (1 + zoomDelta))\n  );\n\n  // #### 3.2.2. Early return if zoom didn\'t change\n  if (newZoom === state.zoom) {\n    return state;\n  }\n\n  // #### 3.2.3. Calculate zoom ratio and adjust pan to zoom at point\n  const zoomRatio = newZoom / state.zoom;\n\n  return {\n    ...state,\n    zoom: newZoom,\n    pan: {\n      x: zoomPoint.x - (zoomPoint.x - state.pan.x) * zoomRatio,\n      y: zoomPoint.y - (zoomPoint.y - state.pan.y) * zoomRatio,\n    },\n  };\n}\n\n// ### 3.3. dragNode - Move a specific node\nexport function dragNode(\n  nodePositions: Record<string, NodePosition>,\n  nodeId: string,\n  startPoint: Point,\n  currentPoint: Point,\n  canvasZoom: number,\n  initialNodePosition: NodePosition\n): Record<string, NodePosition> {\n  // #### 3.3.1. Calculate delta in screen space\n  const screenDeltaX = currentPoint.x - startPoint.x;\n  const screenDeltaY = currentPoint.y - startPoint.y;\n\n  // #### 3.3.2. Convert to SVG space (account for zoom)\n  const svgDeltaX = screenDeltaX / canvasZoom;\n  const svgDeltaY = screenDeltaY / canvasZoom;\n\n  // #### 3.3.3. Return new node positions with updated node\n  return {\n    ...nodePositions,\n    [nodeId]: {\n      x: initialNodePosition.x + svgDeltaX,\n      y: initialNodePosition.y + svgDeltaY,\n    },\n  };\n}\n\n// ### 3.4. clickNode - Handle node selection/interaction\nexport function clickNode(state: CanvasState, nodeId: string): CanvasState {\n  return {\n    ...state,\n    selectedNodeId: state.selectedNodeId === nodeId ? null : nodeId,\n  };\n}\n\n// ## 4. InteractiveCanvas Component\nexport function InteractiveCanvas({\n  files,\n  edges = [],\n}: InteractiveCanvasProps) {\n  // ### 4.1. State Management\n  // #### 4.1.1. Canvas state (zoom, pan, selection, dragging)\n  const [canvasState, setCanvasState] = useState<CanvasState>({\n    zoom: 1,\n    pan: { x: 0, y: 0 },\n    selectedNodeId: null,\n    isDragging: false,\n    dragType: null,\n    draggedNodeId: null,\n    dragStartPoint: null,\n  });\n\n  // #### 4.1.2. Node positions state\n  const [nodePositions, setNodePositions] = useState<\n    Record<string, NodePosition>\n  >({});\n\n  // ### 4.2. References for D3 Operations\n  const containerRef = useRef<HTMLDivElement>(null);\n  const svgRef = useRef<SVGSVGElement>(null);\n  const gRef = useRef<SVGGElement>(null);\n  const zoomBehaviorRef = useRef<d3.ZoomBehavior<\n    SVGSVGElement,\n    unknown\n  > | null>(null);\n  const initialNodePositionRef = useRef<NodePosition>({ x: 0, y: 0 });\n\n  // #### 4.2.1. State refs for drag callbacks (to avoid stale closures)\n  const canvasStateRef = useRef(canvasState);\n  const nodePositionsRef = useRef(nodePositions);\n\n  // ### 4.3. Sync Effects - Keep refs in sync with state\n  useEffect(() => {\n    canvasStateRef.current = canvasState;\n  }, [canvasState]);\n\n  useEffect(() => {\n    nodePositionsRef.current = nodePositions;\n  }, [nodePositions]);\n\n  // ### 4.4. Computed Data\n  // #### 4.4.1. Generate file nodes data with positions\n  const fileNodes = useMemo((): FileNodeData[] => {\n    return files.map((file, index) => ({\n      id: `file-${index}`,\n      name: file.name,\n      position:\n        nodePositions[`file-${index}`] ||\n        calculateInitialPosition(index, files.length),\n    }));\n  }, [files, nodePositions]);\n\n  // ### 4.5. Helper Functions\n  // #### 4.5.1. Calculate initial grid position for nodes\n  function calculateInitialPosition(\n    index: number,\n    totalFiles: number\n  ): NodePosition {\n    const nodesPerRow = Math.ceil(Math.sqrt(totalFiles));\n    const row = Math.floor(index / nodesPerRow);\n    const col = index % nodesPerRow;\n\n    return {\n      x: col * GRID_SPACING + NODE_WIDTH / 2,\n      y: row * GRID_SPACING + NODE_HEIGHT / 2,\n    };\n  }\n\n  // ### 4.6. Initialization Effects\n  // #### 4.6.1. Initialize node positions when files change\n  useEffect(() => {\n    const initialPositions: Record<string, NodePosition> = {};\n    files.forEach((_, index) => {\n      const nodeId = `file-${index}`;\n      if (!nodePositions[nodeId]) {\n        initialPositions[nodeId] = calculateInitialPosition(\n          index,\n          files.length\n        );\n      }\n    });\n\n    if (Object.keys(initialPositions).length > 0) {\n      setNodePositions((prev) => ({ ...prev, ...initialPositions }));\n    }\n  }, [files, nodePositions]);\n\n  // ### 4.7. D3 Setup Effects\n  // #### 4.7.1. Initialize SVG and setup D3 behaviors (only once)\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const container = d3.select(containerRef.current);\n\n    // ##### 4.7.1.1. Clear any existing content\n    container.selectAll("*").remove();\n\n    // ##### 4.7.1.2. Create SVG element\n    const svg = container\n      .append("svg")\n      .attr("width", "100%")\n      .attr("height", "100%")\n      .style("user-select", "none");\n\n    svgRef.current = svg.node();\n\n    // ##### 4.7.1.3. Create main group for zoom/pan transforms\n    const g = svg.append("g");\n    gRef.current = g.node();\n\n    // ##### 4.7.1.4. Setup grid pattern for visual grid background\n    const defs = svg.append("defs");\n    const pattern = defs\n      .append("pattern")\n      .attr("id", "grid")\n      .attr("width", 20)\n      .attr("height", 20)\n      .attr("patternUnits", "userSpaceOnUse");\n\n    pattern\n      .append("path")\n      .attr("d", "M 20 0 L 0 0 0 20")\n      .attr("fill", "none")\n      .attr("stroke", "var(--mantine-color-gray-2)")\n      .attr("stroke-width", 0.5)\n      .attr("opacity", 0.5);\n\n    // ##### 4.7.1.5. Add grid background rectangle\n    g.append("rect")\n      .attr("x", -2000)\n      .attr("y", -2000)\n      .attr("width", 4000)\n      .attr("height", 4000)\n      .attr("fill", "url(#grid)");\n\n    // ##### 4.7.1.6. Add arrow marker definition for edges\n    const arrowMarker = defs\n      .append("marker")\n      .attr("id", "arrow")\n      .attr("viewBox", "0 -5 10 10")\n      .attr("refX", 8)\n      .attr("refY", 0)\n      .attr("markerWidth", 6)\n      .attr("markerHeight", 6)\n      .attr("orient", "auto");\n\n    arrowMarker\n      .append("path")\n      .attr("d", "M0,-5L10,0L0,5")\n      .attr("fill", "var(--mantine-color-gray-6)");\n\n    // ##### 4.7.1.7. Setup zoom behavior - apply to SVG, not container\n    const zoomBehavior = d3\n      .zoom<SVGSVGElement, unknown>()\n      .scaleExtent([MIN_ZOOM, MAX_ZOOM])\n      .on("zoom", (event) => {\n        const transform = event.transform;\n\n        // Update canvas state with new zoom/pan values\n        setCanvasState((prev) => ({\n          ...prev,\n          zoom: transform.k,\n          pan: { x: transform.x, y: transform.y },\n        }));\n\n        // Apply transform to the main group\n        g.attr("transform", transform.toString());\n      });\n\n    zoomBehaviorRef.current = zoomBehavior;\n\n    // ##### 4.7.1.8. Apply zoom behavior to SVG element for proper event handling\n    svg.call(zoomBehaviorRef.current);\n\n    // ##### 4.7.1.9. Sync initial state with D3 zoom\n    const initialTransform = d3.zoomIdentity\n      .translate(canvasState.pan.x, canvasState.pan.y)\n      .scale(canvasState.zoom);\n\n    svg.call(zoomBehavior.transform, initialTransform);\n\n    // ##### 4.7.1.10. Cleanup function to remove event listeners\n    return () => {\n      if (zoomBehaviorRef.current) {\n        svg.on(".zoom", null);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Remove dependencies to prevent recreation\n\n  // #### 4.5.2. Calculate edge connection points between nodes\n  const calculateEdgePoints = (fromPos: NodePosition, toPos: NodePosition) => {\n    // ##### 4.5.2.1. Calculate direction vector between nodes\n    const dx = toPos.x - fromPos.x;\n    const dy = toPos.y - fromPos.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // ##### 4.5.2.2. Handle case where nodes are at same position\n    if (distance === 0) {\n      return { x1: fromPos.x, y1: fromPos.y, x2: toPos.x, y2: toPos.y };\n    }\n\n    // ##### 4.5.2.3. Normalize direction vector to unit vector\n    const unitX = dx / distance;\n    const unitY = dy / distance;\n\n    // ##### 4.5.2.4. Calculate connection points at node edges\n    // From node: start from edge in direction of target\n    const fromRadius = Math.max(NODE_WIDTH, NODE_HEIGHT) / 2;\n    const x1 = fromPos.x + unitX * fromRadius;\n    const y1 = fromPos.y + unitY * fromRadius;\n\n    // To node: end at edge from direction of source\n    const toRadius = Math.max(NODE_WIDTH, NODE_HEIGHT) / 2;\n    const x2 = toPos.x - unitX * toRadius;\n    const y2 = toPos.y - unitY * toRadius;\n\n    return { x1, y1, x2, y2 };\n  };\n\n  // ### 4.8. Rendering Effects\n  // #### 4.8.1. Render edges with D3\n  useEffect(() => {\n    if (!gRef.current) return;\n\n    const g = d3.select(gRef.current);\n\n    // ##### 4.8.1.1. Helper function to get node position by ID\n    const getNodePosition = (nodeId: string): NodePosition | null => {\n      const node = fileNodes.find((n) => n.id === nodeId);\n      return node ? node.position : null;\n    };\n\n    // ##### 4.8.1.2. Filter valid edges (both from and to nodes exist)\n    const validEdges = edges.filter((edge) => {\n      const fromPos = getNodePosition(edge.from);\n      const toPos = getNodePosition(edge.to);\n      return fromPos && toPos;\n    });\n\n    // ##### 4.8.1.3. Data join for edges using D3 pattern\n    const edgeLines = g\n      .selectAll<SVGLineElement, Edge>("line.edge")\n      .data(validEdges, (d) => d.id);\n\n    // ##### 4.8.1.4. Enter selection for new edges\n    const enterEdges = edgeLines\n      .enter()\n      .append("line")\n      .attr("class", "edge")\n      .attr("stroke", "var(--mantine-color-gray-6)")\n      .attr("stroke-width", 2)\n      .attr("marker-end", "url(#arrow)")\n      .attr("opacity", 0.7);\n\n    // ##### 4.8.1.5. Merge enter and update selections\n    const allEdges = enterEdges.merge(edgeLines);\n\n    // ##### 4.8.1.6. Update edge positions with proper node-to-node connections\n    allEdges.each(function (d) {\n      const fromPos = getNodePosition(d.from);\n      const toPos = getNodePosition(d.to);\n\n      if (fromPos && toPos) {\n        const { x1, y1, x2, y2 } = calculateEdgePoints(fromPos, toPos);\n\n        d3.select(this)\n          .attr("x1", x1)\n          .attr("y1", y1)\n          .attr("x2", x2)\n          .attr("y2", y2);\n      }\n    });\n\n    // ##### 4.8.1.7. Remove edges that are no longer needed\n    edgeLines.exit().remove();\n\n    // ##### 4.8.1.8. Data join for edge labels\n    const edgeLabels = g\n      .selectAll<SVGTextElement, Edge>("text.edge-label")\n      .data(validEdges, (d) => d.id);\n\n    // ##### 4.8.1.9. Enter selection for new edge labels\n    const enterLabels = edgeLabels\n      .enter()\n      .append("text")\n      .attr("class", "edge-label")\n      .attr("text-anchor", "middle")\n      .attr("dominant-baseline", "middle")\n      .style("font-size", "10px")\n      .style("font-family", "var(--mantine-font-family)")\n      .style("fill", "var(--mantine-color-gray-7)")\n      .style("background", "white")\n      .style("pointer-events", "none");\n\n    // ##### 4.8.1.10. Merge enter and update selections for labels\n    const allLabels = enterLabels.merge(edgeLabels);\n\n    // ##### 4.8.1.11. Update edge label positions and text - position above the line\n    allLabels.each(function (d) {\n      const fromPos = getNodePosition(d.from);\n      const toPos = getNodePosition(d.to);\n\n      if (fromPos && toPos) {\n        const { x1, y1, x2, y2 } = calculateEdgePoints(fromPos, toPos);\n\n        // Calculate midpoint of the actual edge line\n        const midX = (x1 + x2) / 2;\n        const midY = (y1 + y2) / 2;\n\n        // Calculate perpendicular offset to position text above the line\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        if (distance > 0) {\n          // Perpendicular vector (rotated 90 degrees)\n          const perpX = -dy / distance;\n          const perpY = dx / distance;\n\n          // Offset text above the line\n          const offsetDistance = 12; // pixels above the line\n          const textX = midX + perpX * offsetDistance;\n          const textY = midY + perpY * offsetDistance;\n\n          d3.select(this).attr("x", textX).attr("y", textY).text(d.description);\n        }\n      }\n    });\n\n    // ##### 4.8.1.12. Remove labels that are no longer needed\n    edgeLabels.exit().remove();\n  }, [edges, fileNodes, nodePositions]);\n\n  // #### 4.8.2. Render nodes with D3\n  useEffect(() => {\n    if (!gRef.current) return;\n\n    const g = d3.select(gRef.current);\n\n    // ##### 4.8.2.1. Setup drag behavior for nodes\n    const dragBehavior = d3\n      .drag<SVGGElement, FileNodeData>()\n      .on("start", (event, d) => {\n        // Prevent canvas zoom/pan while dragging nodes\n        event.sourceEvent.stopPropagation();\n\n        // Store initial position for the pure function\n        initialNodePositionRef.current = d.position;\n\n        // Store drag start point in screen coordinates\n        const startPoint = {\n          x: event.sourceEvent.clientX,\n          y: event.sourceEvent.clientY,\n        };\n\n        setCanvasState((prev) => ({\n          ...prev,\n          isDragging: true,\n          dragType: "node",\n          draggedNodeId: d.id,\n          dragStartPoint: startPoint,\n        }));\n      })\n      .on("drag", (event, d) => {\n        event.sourceEvent.stopPropagation();\n\n        // Get current state from refs to avoid stale closures\n        const currentCanvasState = canvasStateRef.current;\n        const currentNodePositions = nodePositionsRef.current;\n\n        if (!currentCanvasState.dragStartPoint) return;\n\n        // Get current mouse position in screen coordinates\n        const currentPoint: Point = {\n          x: event.sourceEvent.clientX,\n          y: event.sourceEvent.clientY,\n        };\n\n        // Use pure function to calculate new node positions\n        const newNodePositions = dragNode(\n          currentNodePositions,\n          d.id,\n          currentCanvasState.dragStartPoint,\n          currentPoint,\n          currentCanvasState.zoom,\n          initialNodePositionRef.current\n        );\n\n        setNodePositions(newNodePositions);\n      })\n      .on("end", (event, d) => {\n        event.sourceEvent.stopPropagation();\n\n        const currentCanvasState = canvasStateRef.current;\n\n        if (!currentCanvasState.dragStartPoint) {\n          // Reset state if no drag start point (error case)\n          setCanvasState((prev) => ({\n            ...prev,\n            isDragging: false,\n            dragType: null,\n            draggedNodeId: null,\n            dragStartPoint: null,\n          }));\n          return;\n        }\n\n        // Get end position in screen coordinates\n        const endPoint: Point = {\n          x: event.sourceEvent.clientX,\n          y: event.sourceEvent.clientY,\n        };\n\n        // Check if this was a click vs drag (movement threshold)\n        const isClick =\n          Math.abs(endPoint.x - currentCanvasState.dragStartPoint.x) < 5 &&\n          Math.abs(endPoint.y - currentCanvasState.dragStartPoint.y) < 5;\n\n        if (isClick) {\n          // Handle click - toggle node selection\n          const newCanvasState = clickNode(currentCanvasState, d.id);\n          setCanvasState({\n            ...newCanvasState,\n            isDragging: false,\n            dragType: null,\n            draggedNodeId: null,\n            dragStartPoint: null,\n          });\n        } else {\n          // Handle drag end - just reset drag state\n          setCanvasState((prev) => ({\n            ...prev,\n            isDragging: false,\n            dragType: null,\n            draggedNodeId: null,\n            dragStartPoint: null,\n          }));\n        }\n      });\n\n    // ##### 4.8.2.2. Data join for nodes using D3 pattern\n    const nodeGroups = g\n      .selectAll<SVGGElement, FileNodeData>("g.file-node")\n      .data(fileNodes, (d) => d.id);\n\n    // ##### 4.8.2.3. Enter selection for new nodes\n    const enterGroups = nodeGroups\n      .enter()\n      .append("g")\n      .attr("class", "file-node")\n      .style("cursor", "move")\n      .call(dragBehavior);\n\n    // ##### 4.8.2.4. Add rectangle shape to new node groups\n    enterGroups\n      .append("rect")\n      .attr("width", NODE_WIDTH)\n      .attr("height", NODE_HEIGHT)\n      .attr("rx", 8)\n      .attr("x", -NODE_WIDTH / 2)\n      .attr("y", -NODE_HEIGHT / 2);\n\n    // ##### 4.8.2.5. Add text labels to new node groups\n    enterGroups\n      .append("text")\n      .attr("text-anchor", "middle")\n      .attr("dominant-baseline", "middle")\n      .style("font-size", "12px")\n      .style("font-family", "var(--mantine-font-family)")\n      .style("font-weight", "500")\n      .style("pointer-events", "none")\n      .text((d) =>\n        d.name.length > 15 ? `${d.name.substring(0, 12)}...` : d.name\n      );\n\n    // ##### 4.8.2.6. Merge enter and update selections\n    const allGroups = enterGroups.merge(nodeGroups);\n\n    // ##### 4.8.2.7. Update node positions\n    allGroups.attr(\n      "transform",\n      (d) => `translate(${d.position.x}, ${d.position.y})`\n    );\n\n    // ##### 4.8.2.8. Update visual states based on selection and drag\n    allGroups\n      .select("rect")\n      .attr("fill", (d) => {\n        if (canvasState.selectedNodeId === d.id)\n          return "var(--mantine-color-blue-2)";\n        return "var(--mantine-color-blue-1)";\n      })\n      .attr("stroke", (d) => {\n        if (canvasState.selectedNodeId === d.id)\n          return "var(--mantine-color-blue-6)";\n        return "var(--mantine-color-blue-3)";\n      })\n      .attr("stroke-width", (d) => {\n        if (canvasState.selectedNodeId === d.id) return 3;\n        return 1;\n      })\n      .style("opacity", (d) => {\n        if (canvasState.draggedNodeId === d.id) return 0.8;\n        return 1;\n      });\n\n    // ##### 4.8.2.9. Update text color\n    allGroups.select("text").attr("fill", "var(--mantine-color-blue-9)");\n\n    // ##### 4.8.2.10. Setup hover effects for interactive feedback\n    allGroups\n      .on("mouseenter", function (_event, d) {\n        if (canvasState.draggedNodeId !== d.id) {\n          d3.select(this)\n            .select("rect")\n            .attr("stroke", "var(--mantine-color-blue-4)")\n            .attr("stroke-width", 2);\n        }\n      })\n      .on("mouseleave", function (_event, d) {\n        if (canvasState.draggedNodeId !== d.id) {\n          const isSelected = canvasState.selectedNodeId === d.id;\n          d3.select(this)\n            .select("rect")\n            .attr(\n              "stroke",\n              isSelected\n                ? "var(--mantine-color-blue-6)"\n                : "var(--mantine-color-blue-3)"\n            )\n            .attr("stroke-width", isSelected ? 3 : 1);\n        }\n      });\n\n    // ##### 4.8.2.11. Remove nodes that are no longer needed\n    nodeGroups.exit().remove();\n  }, [fileNodes, canvasState, nodePositions]);\n\n  // ### 4.9. Component Render - Container for D3 SVG canvas\n  return (\n    <Box\n      ref={containerRef}\n      style={{\n        width: "100%",\n        height: 400,\n        border: "1px solid var(--mantine-color-gray-3)",\n        borderRadius: "var(--mantine-radius-md)",\n        overflow: "hidden",\n        // Dynamic cursor based on interaction state\n        cursor: canvasState.isDragging\n          ? canvasState.dragType === "canvas"\n            ? "grabbing"\n            : "move"\n          : "grab",\n      }}\n    />\n  );\n}\n',
    size: 21386,
    dependents: [
      {
        name: "step-two-describe-relations.tsx",
        path: "ui/src/routes/(generate-tests)/-components/step-two-describe-relations/step-two-describe-relations.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-three-view-results/step-three-view-results.tsx",
    name: "step-three-view-results.tsx",
    content:
      'import { Stack, Box, Title, Text } from "@mantine/core";\n\nexport function StepThreeViewResults() {\n  return (\n    <Stack gap="lg">\n      <Box ta="center">\n        <Title order={2} mb="md">\n          Review Results\n        </Title>\n        <Text c="dimmed" size="lg">\n          Review and download your generated test cases\n        </Text>\n      </Box>\n      {/* This will be implemented later */}\n      <Text ta="center" c="green">\n        Coming soon: Generated test results\n      </Text>\n    </Stack>\n  );\n}\n',
    size: 510,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/use-file-tree.ts",
    name: "use-file-tree.ts",
    content:
      '// # 3. File Tree State Management Hook\n// Custom hook for managing file tree state and operations\n\nimport { useState, useEffect, useMemo, useCallback } from "react";\nimport { type RepoFile, type SelectedRepoFile } from "src/types/repo";\nimport { type TreeNode } from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-item";\nimport {\n  buildFileTree,\n  getFirstLevelDirectories,\n} from "src/routes/(generate-tests)/-components/step-one-upload-files/tree-utils";\n\n// # 3.1 Hook Interface\ninterface UseFileTreeProps {\n  repoFiles: RepoFile[];\n  selectedFiles: SelectedRepoFile[];\n}\n\n// # 3.2 Hook Return Type\ninterface UseFileTreeReturn {\n  fileTree: TreeNode[];\n  expandedDirectories: Set<string>;\n  toggleDirectoryExpansion: (path: string) => void;\n}\n\n// # 3.3 Main Hook Implementation\n// Manages tree state, expansion, and provides utility functions\nexport function useFileTree({\n  repoFiles,\n}: UseFileTreeProps): UseFileTreeReturn {\n  // # 3.3.1 State Management\n  const [expandedDirectories, setExpandedDirectories] = useState<Set<string>>(\n    new Set()\n  );\n\n  // # 3.3.2 Build Tree Structure\n  // Build tree structure from files (memoized to prevent unnecessary re-renders)\n  const fileTree = useMemo(() => {\n    return repoFiles.length > 0 ? buildFileTree(repoFiles) : [];\n  }, [repoFiles]);\n\n  // # 3.3.3 Directory Expansion Functions\n\n  // # 3.3.3.1 Toggle Single Directory\n  const toggleDirectoryExpansion = useCallback((path: string) => {\n    setExpandedDirectories((prev) => {\n      const newSet = new Set(prev);\n      if (newSet.has(path)) {\n        newSet.delete(path);\n      } else {\n        newSet.add(path);\n      }\n      return newSet;\n    });\n  }, []);\n\n  // # 3.3.4 Auto-expand Effect\n  // Auto-expand first level directories when files are first loaded\n  useEffect(() => {\n    if (repoFiles.length > 0 && expandedDirectories.size === 0) {\n      const firstLevelDirs = getFirstLevelDirectories(fileTree);\n      setExpandedDirectories(new Set(firstLevelDirs));\n    }\n  }, [repoFiles.length, fileTree, expandedDirectories.size]);\n\n  // # 3.3.5 Return Hook Interface\n  return {\n    fileTree,\n    expandedDirectories,\n    toggleDirectoryExpansion,\n  };\n}\n',
    size: 2190,
    dependents: [
      {
        name: "generate-tests.tsx",
        path: "ui/src/routes/(generate-tests)/generate-tests.tsx",
      },
    ],
  },
  {
    path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/tree-utils.ts",
    name: "tree-utils.ts",
    content:
      '// # 2. Tree Utility Functions\n// Contains helper functions for building and managing file tree structures\n\nimport type { RepoFile } from "src/types/repo";\nimport type { TreeNode } from "./tree-item";\n\n// # 2.1 Build File Tree Function\n// Converts a flat list of RepoFile objects into a hierarchical tree structure\nexport function buildFileTree(files: RepoFile[]): TreeNode[] {\n  // # 2.1.1 Initialize Tree Structure\n  const tree: TreeNode[] = [];\n  const pathToNode: Map<string, TreeNode> = new Map();\n\n  // # 2.1.2 Sort Files for Proper Tree Building\n  // Sort files by path to ensure proper hierarchical construction\n  const sortedFiles = [...files].sort((a, b) => a.path.localeCompare(b.path));\n\n  // # 2.1.3 Process Each File\n  for (const file of sortedFiles) {\n    const pathParts = file.path.split("/");\n    let currentPath = "";\n\n    // # 2.1.4 Build Path Hierarchy\n    // Create directory nodes for each part of the file path\n    for (let i = 0; i < pathParts.length; i++) {\n      const part = pathParts[i];\n      const parentPath = currentPath;\n      currentPath = currentPath ? `${currentPath}/${part}` : part;\n\n      // # 2.1.5 Create Node if Not Exists\n      if (!pathToNode.has(currentPath)) {\n        const isFile = i === pathParts.length - 1;\n        const node: TreeNode = {\n          path: currentPath,\n          name: part,\n          type: isFile ? "file" : "directory",\n          file: isFile ? file : undefined,\n          children: [],\n          depth: i,\n        };\n\n        pathToNode.set(currentPath, node);\n\n        // # 2.1.6 Link to Parent or Root\n        if (parentPath && pathToNode.has(parentPath)) {\n          pathToNode.get(parentPath)!.children.push(node);\n        } else if (i === 0) {\n          tree.push(node);\n        }\n      }\n    }\n  }\n\n  return tree;\n}\n\n// # 2.2 Collect Directory Paths Function\n// Recursively collects all directory paths from a tree structure\nexport function collectDirectoryPaths(nodes: TreeNode[]): Set<string> {\n  const allDirectoryPaths = new Set<string>();\n\n  const traverse = (nodeList: TreeNode[]) => {\n    nodeList.forEach((node) => {\n      if (node.type === "directory") {\n        allDirectoryPaths.add(node.path);\n        if (node.children.length > 0) {\n          traverse(node.children);\n        }\n      }\n    });\n  };\n\n  traverse(nodes);\n  return allDirectoryPaths;\n}\n\n// # 2.3 Get First Level Directories Function\n// Extracts only the top-level directory paths from a tree\nexport function getFirstLevelDirectories(tree: TreeNode[]): string[] {\n  return tree\n    .filter((node) => node.type === "directory" && node.depth === 0)\n    .map((node) => node.path);\n}\n',
    size: 2632,
    dependents: [
      {
        name: "use-file-tree.ts",
        path: "ui/src/routes/(generate-tests)/-components/step-one-upload-files/use-file-tree.ts",
      },
    ],
  },
];
